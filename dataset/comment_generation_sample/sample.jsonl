{"patch": "@@ -53,7 +53,7 @@ public class ProtocGapicPluginGeneratorTest {\n                 model.getFiles().stream().map(ProtoFile::getProto).collect(Collectors.toList()))\n             // Only the file to generate a client for (don't generate dependencies)\n             .addFileToGenerate(\"multiple_services.proto\")\n-            .setParameter(\"language=java\")\n+            .setParameter(\"language=java,transport=grpc\")\n             .build();\n \n     CodeGeneratorResponse response = ProtocGeneratorMain.generate(codeGeneratorRequest);", "y": 1, "oldf": "/* Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.api.codegen.gapic;\n\nimport com.google.api.codegen.CodegenTestUtil;\nimport com.google.api.codegen.ProtocGeneratorMain;\nimport com.google.api.codegen.protoannotations.GapicCodeGeneratorAnnotationsTest;\nimport com.google.api.tools.framework.model.Model;\nimport com.google.api.tools.framework.model.ProtoFile;\nimport com.google.api.tools.framework.model.testing.TestDataLocator;\nimport com.google.common.truth.Truth;\nimport com.google.protobuf.compiler.PluginProtos.CodeGeneratorRequest;\nimport com.google.protobuf.compiler.PluginProtos.CodeGeneratorResponse;\nimport java.util.stream.Collectors;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\npublic class ProtocGapicPluginGeneratorTest {\n\n  private static String[] protoFiles = {\"multiple_services.proto\"};\n  private static TestDataLocator testDataLocator;\n  private static Model model;\n  @ClassRule public static TemporaryFolder tempDir = new TemporaryFolder();\n\n  @BeforeClass\n  public static void startUp() {\n    testDataLocator = TestDataLocator.create(GapicCodeGeneratorAnnotationsTest.class);\n    testDataLocator.addTestDataSource(CodegenTestUtil.class, \"testsrc/common\");\n\n    model = CodegenTestUtil.readModel(testDataLocator, tempDir, protoFiles, new String[] {});\n  }\n\n  @Test\n  public void testGenerator() {\n    CodeGeneratorRequest codeGeneratorRequest =\n        CodeGeneratorRequest.newBuilder()\n            // All proto files, including dependencies\n            .addAllProtoFile(\n                model.getFiles().stream().map(ProtoFile::getProto).collect(Collectors.toList()))\n            // Only the file to generate a client for (don't generate dependencies)\n            .addFileToGenerate(\"multiple_services.proto\")\n            .setParameter(\"language=java\")\n            .build();\n\n    CodeGeneratorResponse response = ProtocGeneratorMain.generate(codeGeneratorRequest);\n\n    // TODO(andrealin): Look into setting these up as baseline files.\n    Truth.assertThat(response).isNotNull();\n    Truth.assertThat(response.getError()).isEmpty();\n    Truth.assertThat(response.getFileCount()).isEqualTo(15);\n    Truth.assertThat(response.getFile(0).getContent()).contains(\"DecrementerServiceClient\");\n  }\n\n  @Test\n  public void testFailingGenerator() {\n    CodeGeneratorRequest codeGeneratorRequest =\n        CodeGeneratorRequest.newBuilder()\n            .addAllProtoFile(\n                model.getFiles().stream().map(ProtoFile::getProto).collect(Collectors.toList()))\n            // File does not exist.\n            .addFileToGenerate(\"fuuuuudge.proto\")\n            .build();\n\n    CodeGeneratorResponse response = ProtocGeneratorMain.generate(codeGeneratorRequest);\n\n    Truth.assertThat(response).isNotNull();\n    Truth.assertThat(response.getError()).isNotEmpty();\n  }\n}\n", "idx": 1, "id": 30879, "msg": "can we also test for `transport=rest`?", "proj": "googleapis-gapic-generator", "lang": "java"}
{"patch": "@@ -182,7 +182,9 @@ abstract class AbstractSolrBackendFactory implements FactoryInterface\n      */\n     protected function createBackend(Connector $connector)\n     {\n+        $config = $this->config->get($this->mainConfig);\n         $backend = new $this->backendClass($connector);\n+        $backend->setPageSize($config->Index->record_batch_size);\n         $backend->setQueryBuilder($this->createQueryBuilder());\n         $backend->setSimilarBuilder($this->createSimilarBuilder());\n         if ($this->logger) {", "y": 1, "oldf": "<?php\n\n/**\n * Abstract factory for SOLR backends.\n *\n * PHP version 7\n *\n * Copyright (C) Villanova University 2013.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n * @category VuFind\n * @package  Search\n * @author   David Maus <maus@hab.de>\n * @license  http://opensource.org/licenses/gpl-2.0.php GNU General Public License\n * @link     https://vufind.org Main Site\n */\nnamespace VuFind\\Search\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\n\nuse Laminas\\Config\\Config;\nuse Laminas\\ServiceManager\\Factory\\FactoryInterface;\nuse VuFind\\Search\\Solr\\DeduplicationListener;\nuse VuFind\\Search\\Solr\\FilterFieldConversionListener;\nuse VuFind\\Search\\Solr\\HideFacetValueListener;\nuse VuFind\\Search\\Solr\\HierarchicalFacetListener;\nuse VuFind\\Search\\Solr\\InjectConditionalFilterListener;\nuse VuFind\\Search\\Solr\\InjectHighlightingListener;\nuse VuFind\\Search\\Solr\\InjectSpellingListener;\nuse VuFind\\Search\\Solr\\MultiIndexListener;\n\nuse VuFind\\Search\\Solr\\V3\\ErrorListener as LegacyErrorListener;\nuse VuFind\\Search\\Solr\\V4\\ErrorListener;\nuse VuFindSearch\\Backend\\BackendInterface;\nuse VuFindSearch\\Backend\\Solr\\Backend;\nuse VuFindSearch\\Backend\\Solr\\Connector;\nuse VuFindSearch\\Backend\\Solr\\HandlerMap;\nuse VuFindSearch\\Backend\\Solr\\LuceneSyntaxHelper;\n\nuse VuFindSearch\\Backend\\Solr\\QueryBuilder;\n\nuse VuFindSearch\\Backend\\Solr\\SimilarBuilder;\n\n/**\n * Abstract factory for SOLR backends.\n *\n * @category VuFind\n * @package  Search\n * @author   David Maus <maus@hab.de>\n * @license  http://opensource.org/licenses/gpl-2.0.php GNU General Public License\n * @link     https://vufind.org Main Site\n */\nabstract class AbstractSolrBackendFactory implements FactoryInterface\n{\n    /**\n     * Logger.\n     *\n     * @var \\Laminas\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    /**\n     * Superior service manager.\n     *\n     * @var ContainerInterface\n     */\n    protected $serviceLocator;\n\n    /**\n     * Primary configuration file identifier.\n     *\n     * @var string\n     */\n    protected $mainConfig = 'config';\n\n    /**\n     * Search configuration file identifier.\n     *\n     * @var string\n     */\n    protected $searchConfig;\n\n    /**\n     * Facet configuration file identifier.\n     *\n     * @var string\n     */\n    protected $facetConfig;\n\n    /**\n     * YAML searchspecs filename.\n     *\n     * @var string\n     */\n    protected $searchYaml;\n\n    /**\n     * VuFind configuration reader\n     *\n     * @var \\VuFind\\Config\\PluginManager\n     */\n    protected $config;\n\n    /**\n     * Solr core name\n     *\n     * @var string\n     */\n    protected $solrCore = '';\n\n    /**\n     * Solr field used to store unique identifiers\n     *\n     * @var string\n     */\n    protected $uniqueKey = 'id';\n\n    /**\n     * Solr connector class\n     *\n     * @var string\n     */\n    protected $connectorClass = Connector::class;\n\n    /**\n     * Solr backend class\n     *\n     * @var string\n     */\n    protected $backendClass = Backend::class;\n\n    /**\n     * Constructor\n     */\n    public function __construct()\n    {\n    }\n\n    /**\n     * Create service\n     *\n     * @param ContainerInterface $sm      Service manager\n     * @param string             $name    Requested service name (unused)\n     * @param array              $options Extra options (unused)\n     *\n     * @return Backend\n     *\n     * @SuppressWarnings(PHPMD.UnusedFormalParameter)\n     */\n    public function __invoke(ContainerInterface $sm, $name, array $options = null)\n    {\n        $this->serviceLocator = $sm;\n        $this->config = $this->serviceLocator\n            ->get(\\VuFind\\Config\\PluginManager::class);\n        if ($this->serviceLocator->has(\\VuFind\\Log\\Logger::class)) {\n            $this->logger = $this->serviceLocator->get(\\VuFind\\Log\\Logger::class);\n        }\n        $connector = $this->createConnector();\n        $backend   = $this->createBackend($connector);\n        $this->createListeners($backend);\n        return $backend;\n    }\n\n    /**\n     * Create the SOLR backend.\n     *\n     * @param Connector $connector Connector\n     *\n     * @return Backend\n     */\n    protected function createBackend(Connector $connector)\n    {\n        $backend = new $this->backendClass($connector);\n        $backend->setQueryBuilder($this->createQueryBuilder());\n        $backend->setSimilarBuilder($this->createSimilarBuilder());\n        if ($this->logger) {\n            $backend->setLogger($this->logger);\n        }\n        return $backend;\n    }\n\n    /**\n     * Create listeners.\n     *\n     * @param Backend $backend Backend\n     *\n     * @return void\n     */\n    protected function createListeners(Backend $backend)\n    {\n        $events = $this->serviceLocator->get('SharedEventManager');\n\n        // Load configurations:\n        $config = $this->config->get($this->mainConfig);\n        $search = $this->config->get($this->searchConfig);\n        $facet = $this->config->get($this->facetConfig);\n\n        // Highlighting\n        $this->getInjectHighlightingListener($backend, $search)->attach($events);\n\n        // Conditional Filters\n        if (isset($search->ConditionalHiddenFilters)\n            && $search->ConditionalHiddenFilters->count() > 0\n        ) {\n            $this->getInjectConditionalFilterListener($search)->attach($events);\n        }\n\n        // Spellcheck\n        if ($config->Spelling->enabled ?? true) {\n            $dictionaries = ($config->Spelling->simple ?? false)\n                ? ['basicSpell'] : ['default', 'basicSpell'];\n            $spellingListener = new InjectSpellingListener($backend, $dictionaries);\n            $spellingListener->attach($events);\n        }\n\n        // Apply field stripping if applicable:\n        if (isset($search->StripFields) && isset($search->IndexShards)) {\n            $strip = $search->StripFields->toArray();\n            foreach ($strip as $k => $v) {\n                $strip[$k] = array_map('trim', explode(',', $v));\n            }\n            $mindexListener = new MultiIndexListener(\n                $backend,\n                $search->IndexShards->toArray(),\n                $strip,\n                $this->loadSpecs()\n            );\n            $mindexListener->attach($events);\n        }\n\n        // Apply deduplication if applicable:\n        if (isset($search->Records->deduplication)) {\n            $this->getDeduplicationListener(\n                $backend, $search->Records->deduplication\n            )->attach($events);\n        }\n\n        // Attach hierarchical facet listener:\n        $this->getHierarchicalFacetListener($backend)->attach($events);\n\n        // Apply legacy filter conversion if necessary:\n        $facets = $this->config->get($this->facetConfig);\n        if (!empty($facets->LegacyFields)) {\n            $filterFieldConversionListener = new FilterFieldConversionListener(\n                $facets->LegacyFields->toArray()\n            );\n            $filterFieldConversionListener->attach($events);\n        }\n\n        // Attach hide facet value listener:\n        if ($hfvListener = $this->getHideFacetValueListener($backend, $facet)) {\n            $hfvListener->attach($events);\n        }\n\n        // Attach error listeners for Solr 3.x and Solr 4.x (for backward\n        // compatibility with VuFind 1.x instances).\n        $legacyErrorListener = new LegacyErrorListener($backend);\n        $legacyErrorListener->attach($events);\n        $errorListener = new ErrorListener($backend);\n        $errorListener->attach($events);\n    }\n\n    /**\n     * Get the Solr core.\n     *\n     * @return string\n     */\n    protected function getSolrCore()\n    {\n        return $this->solrCore;\n    }\n\n    /**\n     * Get the Solr URL.\n     *\n     * @param string $config name of configuration file (null for default)\n     *\n     * @return string|array\n     */\n    protected function getSolrUrl($config = null)\n    {\n        $url = $this->config->get($config ?? $this->mainConfig)->Index->url;\n        $core = $this->getSolrCore();\n        if (is_object($url)) {\n            return array_map(\n                function ($value) use ($core) {\n                    return \"$value/$core\";\n                },\n                $url->toArray()\n            );\n        }\n        return \"$url/$core\";\n    }\n\n    /**\n     * Get all hidden filter settings.\n     *\n     * @return array\n     */\n    protected function getHiddenFilters()\n    {\n        $search = $this->config->get($this->searchConfig);\n        $hf = [];\n\n        // Hidden filters\n        if (isset($search->HiddenFilters)) {\n            foreach ($search->HiddenFilters as $field => $value) {\n                $hf[] = sprintf('%s:\"%s\"', $field, $value);\n            }\n        }\n\n        // Raw hidden filters\n        if (isset($search->RawHiddenFilters)) {\n            foreach ($search->RawHiddenFilters as $filter) {\n                $hf[] = $filter;\n            }\n        }\n\n        return $hf;\n    }\n\n    /**\n     * Create the SOLR connector.\n     *\n     * @return Connector\n     */\n    protected function createConnector()\n    {\n        $config = $this->config->get($this->mainConfig);\n        $searchConfig = $this->config->get($this->searchConfig);\n        $defaultFields = $searchConfig->General->default_record_fields ?? '*';\n\n        $handlers = [\n            'select' => [\n                'fallback' => true,\n                'defaults' => ['fl' => $defaultFields],\n                'appends'  => ['fq' => []],\n            ],\n            'terms' => [\n                'functions' => ['terms'],\n            ],\n        ];\n\n        foreach ($this->getHiddenFilters() as $filter) {\n            array_push($handlers['select']['appends']['fq'], $filter);\n        }\n\n        $connector = new $this->connectorClass(\n            $this->getSolrUrl(), new HandlerMap($handlers), $this->uniqueKey\n        );\n        $connector->setTimeout(\n            isset($config->Index->timeout) ? $config->Index->timeout : 30\n        );\n\n        if ($this->logger) {\n            $connector->setLogger($this->logger);\n        }\n        if ($this->serviceLocator->has(\\VuFindHttp\\HttpService::class)) {\n            $connector->setProxy(\n                $this->serviceLocator->get(\\VuFindHttp\\HttpService::class)\n            );\n        }\n        return $connector;\n    }\n\n    /**\n     * Create the query builder.\n     *\n     * @return QueryBuilder\n     */\n    protected function createQueryBuilder()\n    {\n        $specs   = $this->loadSpecs();\n        $config = $this->config->get($this->mainConfig);\n        $defaultDismax = isset($config->Index->default_dismax_handler)\n            ? $config->Index->default_dismax_handler : 'dismax';\n        $builder = new QueryBuilder($specs, $defaultDismax);\n\n        // Configure builder:\n        $search = $this->config->get($this->searchConfig);\n        $caseSensitiveBooleans\n            = isset($search->General->case_sensitive_bools)\n            ? $search->General->case_sensitive_bools : true;\n        $caseSensitiveRanges\n            = isset($search->General->case_sensitive_ranges)\n            ? $search->General->case_sensitive_ranges : true;\n        $helper = new LuceneSyntaxHelper(\n            $caseSensitiveBooleans, $caseSensitiveRanges\n        );\n        $builder->setLuceneHelper($helper);\n\n        return $builder;\n    }\n\n    /**\n     * Create the similar records query builder.\n     *\n     * @return SimilarBuilder\n     */\n    protected function createSimilarBuilder()\n    {\n        return new SimilarBuilder(\n            $this->config->get($this->searchConfig), $this->uniqueKey\n        );\n    }\n\n    /**\n     * Load the search specs.\n     *\n     * @return array\n     */\n    protected function loadSpecs()\n    {\n        return $this->serviceLocator->get(\\VuFind\\Config\\SearchSpecsReader::class)\n            ->get($this->searchYaml);\n    }\n\n    /**\n     * Get a deduplication listener for the backend\n     *\n     * @param BackendInterface $backend Search backend\n     * @param bool             $enabled Whether deduplication is enabled\n     *\n     * @return DeduplicationListener\n     */\n    protected function getDeduplicationListener(BackendInterface $backend, $enabled)\n    {\n        return new DeduplicationListener(\n            $backend,\n            $this->serviceLocator,\n            $this->searchConfig,\n            'datasources',\n            $enabled\n        );\n    }\n\n    /**\n     * Get a hide facet value listener for the backend\n     *\n     * @param BackendInterface $backend Search backend\n     * @param Config           $facet   Configuration of facets\n     *\n     * @return mixed null|HideFacetValueListener\n     */\n    protected function getHideFacetValueListener(\n        BackendInterface $backend,\n        Config $facet\n    ) {\n        if (!isset($facet->HideFacetValue)\n            || ($facet->HideFacetValue->count()) == 0\n        ) {\n            return null;\n        }\n        return new HideFacetValueListener(\n            $backend,\n            $facet->HideFacetValue->toArray()\n        );\n    }\n\n    /**\n     * Get a hierarchical facet listener for the backend\n     *\n     * @param BackendInterface $backend Search backend\n     *\n     * @return HierarchicalFacetListener\n     */\n    protected function getHierarchicalFacetListener(BackendInterface $backend)\n    {\n        return new HierarchicalFacetListener(\n            $backend,\n            $this->serviceLocator,\n            $this->facetConfig\n        );\n    }\n\n    /**\n     * Get a highlighting listener for the backend\n     *\n     * @param BackendInterface $backend Search backend\n     * @param Config           $search  Search configuration\n     *\n     * @return InjectHighlightingListener\n     */\n    protected function getInjectHighlightingListener(BackendInterface $backend,\n        Config $search\n    ) {\n        $fl = isset($search->General->highlighting_fields)\n            ? $search->General->highlighting_fields : '*';\n        return new InjectHighlightingListener($backend, $fl);\n    }\n\n    /**\n     * Get a Conditional Filter Listener\n     *\n     * @param Config $search Search configuration\n     *\n     * @return InjectConditionalFilterListener\n     */\n    protected function getInjectConditionalFilterListener(Config $search)\n    {\n        $listener = new InjectConditionalFilterListener(\n            $search->ConditionalHiddenFilters->toArray()\n        );\n        $listener->setAuthorizationService(\n            $this->serviceLocator\n                ->get(\\LmcRbacMvc\\Service\\AuthorizationService::class)\n        );\n        return $listener;\n    }\n}\n", "idx": 1, "id": 30188, "msg": "If record_batch_size is not set in config.ini, this code will trigger a notice about an undefined value. I would suggest either wrapping the setPageSize() call in an `if (!empty(...)) {` check, or else providing a default value in the set call (i.e. `$config->Index->record_batch_size ?? 100`).", "proj": "vufind-org-vufind", "lang": "php"}
{"patch": "@@ -1,6 +1,6 @@\n <script type=\"text/javascript\">\n   window.analytics||(window.analytics=[]),window.analytics.methods=[\"identify\",\"track\",\"trackLink\",\"trackForm\",\"trackClick\",\"trackSubmit\",\"page\",\"pageview\",\"ab\",\"alias\",\"ready\",\"group\",\"on\",\"once\",\"off\"],window.analytics.factory=function(t){return function(){var a=Array.prototype.slice.call(arguments);return a.unshift(t),window.analytics.push(a),window.analytics}};for(var i=0;i<window.analytics.methods.length;i++){var method=window.analytics.methods[i];window.analytics[method]=window.analytics.factory(method)}window.analytics.load=function(t){var a=document.createElement(\"script\");a.type=\"text/javascript\",a.async=!0,a.src=(\"https:\"===document.location.protocol?\"https://\":\"http://\")+\"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/\"+t+\"/analytics.min.js\";var n=document.getElementsByTagName(\"script\")[0];n.parentNode.insertBefore(a,n)},window.analytics.SNIPPET_VERSION=\"2.0.8\",\n-  window.analytics.load(\"2nexpdgku3\");\n+  window.analytics.load(<%= ENV['SEGMENT_KEY']%>);\n   window.analytics.page();\n </script>\n ", "y": 1, "oldf": "<script type=\"text/javascript\">\n  window.analytics||(window.analytics=[]),window.analytics.methods=[\"identify\",\"track\",\"trackLink\",\"trackForm\",\"trackClick\",\"trackSubmit\",\"page\",\"pageview\",\"ab\",\"alias\",\"ready\",\"group\",\"on\",\"once\",\"off\"],window.analytics.factory=function(t){return function(){var a=Array.prototype.slice.call(arguments);return a.unshift(t),window.analytics.push(a),window.analytics}};for(var i=0;i<window.analytics.methods.length;i++){var method=window.analytics.methods[i];window.analytics[method]=window.analytics.factory(method)}window.analytics.load=function(t){var a=document.createElement(\"script\");a.type=\"text/javascript\",a.async=!0,a.src=(\"https:\"===document.location.protocol?\"https://\":\"http://\")+\"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/\"+t+\"/analytics.min.js\";var n=document.getElementsByTagName(\"script\")[0];n.parentNode.insertBefore(a,n)},window.analytics.SNIPPET_VERSION=\"2.0.8\",\n  window.analytics.load(\"2nexpdgku3\");\n  window.analytics.page();\n</script>\n\n<% if signed_in? %>\n  <%= render 'shared/signed_in_analytics' %>\n<% end %>\n", "idx": 1, "id": 9132, "msg": "I didn't realize we were hardcoding this, thanks for moving it to an env value.", "proj": "thoughtbot-upcase", "lang": "rb"}
{"patch": "@@ -99,7 +99,7 @@ module.exports = function fileItem (props) {\n         }\n       </h4>\n       <div class=\"UppyDashboardItem-status\">\n-        ${file.data.size && html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`}\n+        ${isNaN(file.data.size) ? '' : html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`}\n         ${file.source && html`<div class=\"UppyDashboardItem-sourceIcon\">\n             ${acquirers.map(acquirer => {\n               if (acquirer.id === file.source) return html`<span title=\"${props.i18n('fileSource')}: ${acquirer.name}\">${acquirer.icon()}</span>`", "y": 1, "oldf": "const html = require('yo-yo')\nconst { getETA,\n         getSpeed,\n         prettyETA,\n         getFileNameAndExtension,\n         truncateString,\n         copyToClipboard } = require('../../core/Utils')\nconst prettyBytes = require('prettier-bytes')\nconst FileItemProgress = require('./FileItemProgress')\nconst getFileTypeIcon = require('./getFileTypeIcon')\nconst { iconEdit, iconCopy, iconRetry } = require('./icons')\n\nmodule.exports = function fileItem (props) {\n  const file = props.file\n  const acquirers = props.acquirers\n\n  const isProcessing = file.progress.preprocess || file.progress.postprocess\n  const isUploaded = file.progress.uploadComplete && !isProcessing && !file.error\n  const uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing\n  const uploadInProgress = (file.progress.uploadStarted && !file.progress.uploadComplete) || isProcessing\n  const isPaused = file.isPaused || false\n  const error = file.error || false\n\n  const fileName = getFileNameAndExtension(file.meta.name).name\n  const truncatedFileName = props.isWide ? truncateString(fileName, 15) : fileName\n\n  const onPauseResumeCancelRetry = (ev) => {\n    if (isUploaded) return\n    if (error) {\n      props.retryUpload(file.id)\n      return\n    }\n    if (props.resumableUploads) {\n      props.pauseUpload(file.id)\n    } else {\n      props.cancelUpload(file.id)\n    }\n  }\n\n  return html`<li class=\"UppyDashboardItem\n                        ${uploadInProgress ? 'is-inprogress' : ''}\n                        ${isProcessing ? 'is-processing' : ''}\n                        ${isUploaded ? 'is-complete' : ''}\n                        ${isPaused ? 'is-paused' : ''}\n                        ${error ? 'is-error' : ''}\n                        ${props.resumableUploads ? 'is-resumable' : ''}\"\n                  id=\"uppy_${file.id}\"\n                  title=\"${file.meta.name}\">\n      <div class=\"UppyDashboardItem-preview\">\n        <div class=\"UppyDashboardItem-previewInnerWrap\" style=\"background-color: ${getFileTypeIcon(file.type).color}\">\n          ${file.preview\n            ? html`<img alt=\"${file.name}\" src=\"${file.preview}\">`\n            : html`<div class=\"UppyDashboardItem-previewIconWrap\">\n                <span class=\"UppyDashboardItem-previewIcon\" style=\"color: ${getFileTypeIcon(file.type).color}\">${getFileTypeIcon(file.type).icon}</span>\n                <svg class=\"UppyDashboardItem-previewIconBg\" width=\"72\" height=\"93\" viewBox=\"0 0 72 93\"><g><path d=\"M24.08 5h38.922A2.997 2.997 0 0 1 66 8.003v74.994A2.997 2.997 0 0 1 63.004 86H8.996A2.998 2.998 0 0 1 6 83.01V22.234L24.08 5z\" fill=\"#FFF\"/><path d=\"M24 5L6 22.248h15.007A2.995 2.995 0 0 0 24 19.244V5z\" fill=\"#E4E4E4\"/></g></svg>\n              </div>`\n          }\n        </div>\n        <div class=\"UppyDashboardItem-progress\">\n          <button class=\"UppyDashboardItem-progressBtn\"\n                  type=\"button\"\n                  title=\"${isUploaded\n                          ? 'upload complete'\n                          : props.resumableUploads\n                            ? file.isPaused\n                              ? 'resume upload'\n                              : 'pause upload'\n                            : 'cancel upload'\n                        }\"\n                  onclick=${onPauseResumeCancelRetry}>\n            ${error\n              ? iconRetry()\n              : FileItemProgress({\n                progress: file.progress.percentage,\n                fileID: file.id\n              })\n            }\n          </button>\n          ${props.showProgressDetails\n            ? html`<div class=\"UppyDashboardItem-progressInfo\"\n                        title=\"${props.i18n('fileProgress')}\"\n                        aria-label=\"${props.i18n('fileProgress')}\">\n                ${!file.isPaused && !isUploaded\n                  ? html`<span>${prettyETA(getETA(file.progress))} \u30fb \u2191 ${prettyBytes(getSpeed(file.progress))}/s</span>`\n                  : null\n                }\n              </div>`\n            : null\n          }\n        </div>\n      </div>\n    <div class=\"UppyDashboardItem-info\">\n      <h4 class=\"UppyDashboardItem-name\" title=\"${fileName}\">\n        ${file.uploadURL\n          ? html`<a href=\"${file.uploadURL}\" target=\"_blank\">\n              ${file.extension ? truncatedFileName + '.' + file.extension : truncatedFileName}\n            </a>`\n          : file.extension ? truncatedFileName + '.' + file.extension : truncatedFileName\n        }\n      </h4>\n      <div class=\"UppyDashboardItem-status\">\n        ${file.data.size && html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`}\n        ${file.source && html`<div class=\"UppyDashboardItem-sourceIcon\">\n            ${acquirers.map(acquirer => {\n              if (acquirer.id === file.source) return html`<span title=\"${props.i18n('fileSource')}: ${acquirer.name}\">${acquirer.icon()}</span>`\n            })}\n          </div>`\n        }\n      </div>\n      ${!uploadInProgressOrComplete\n        ? html`<button class=\"UppyDashboardItem-edit\"\n                       type=\"button\"\n                       aria-label=\"Edit file\"\n                       title=\"Edit file\"\n                       onclick=${(e) => props.showFileCard(file.id)}>\n                        ${iconEdit()}</button>`\n        : null\n      }\n      ${file.uploadURL\n        ? html`<button class=\"UppyDashboardItem-copyLink\"\n                       type=\"button\"\n                       aria-label=\"Copy link\"\n                       title=\"Copy link\"\n                       onclick=${() => {\n                         copyToClipboard(file.uploadURL, props.i18n('copyLinkToClipboardFallback'))\n                          .then(() => {\n                            props.log('Link copied to clipboard.')\n                            props.info(props.i18n('copyLinkToClipboardSuccess'), 'info', 3000)\n                          })\n                          .catch(props.log)\n                       }}>${iconCopy()}</button>`\n        : null\n      }\n    </div>\n    <div class=\"UppyDashboardItem-action\">\n      ${!isUploaded\n        ? html`<button class=\"UppyDashboardItem-remove\"\n                       type=\"button\"\n                       aria-label=\"Remove file\"\n                       title=\"Remove file\"\n                       onclick=${() => props.removeFile(file.id)}>\n                 <svg class=\"UppyIcon\" width=\"22\" height=\"21\" viewBox=\"0 0 18 17\">\n                   <ellipse cx=\"8.62\" cy=\"8.383\" rx=\"8.62\" ry=\"8.383\"/>\n                   <path stroke=\"#FFF\" fill=\"#FFF\" d=\"M11 6.147L10.85 6 8.5 8.284 6.15 6 6 6.147 8.35 8.43 6 10.717l.15.146L8.5 8.578l2.35 2.284.15-.146L8.65 8.43z\"/>\n                 </svg>\n               </button>`\n        : null\n      }\n    </div>\n  </li>`\n}\n", "idx": 1, "id": 10142, "msg": "We are trying to support IE 10-11, so we'll need a polyfill for this one, I think.", "proj": "transloadit-uppy", "lang": "js"}
{"patch": "@@ -38,6 +38,9 @@ const { useSelect, useDispatch } = Data;\n function ResetButton( { children } ) {\n \tconst postResetURL = useSelect( ( select ) => select( CORE_SITE ).getAdminURL( 'googlesitekit-splash', { notification: 'reset_success' } ) );\n \n+\tconst isNavigating = useSelect( ( select ) => select( CORE_LOCATION ).isNavigating() );\n+\tconst navigatingURL = useSelect( ( select ) => select( CORE_LOCATION ).getNavigateURL() );\n+\n \tconst [ dialogActive, setDialogActive ] = useState( false );\n \n \tuseEffect( () => {", "y": 1, "oldf": "/**\n * ResetButton component.\n *\n * Site Kit by Google, Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * WordPress dependencies\n */\nimport { __ } from '@wordpress/i18n';\nimport { Fragment, useState, useEffect, useCallback, createInterpolateElement } from '@wordpress/element';\nimport { ESCAPE } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport Data from 'googlesitekit-data';\nimport { clearWebStorage } from '../util';\nimport Dialog from './Dialog';\nimport Modal from './Modal';\nimport Link from './Link';\nimport { CORE_SITE } from '../googlesitekit/datastore/site/constants';\nimport { CORE_LOCATION } from '../googlesitekit/datastore/location/constants';\nconst { useSelect, useDispatch } = Data;\n\nfunction ResetButton( { children } ) {\n\tconst postResetURL = useSelect( ( select ) => select( CORE_SITE ).getAdminURL( 'googlesitekit-splash', { notification: 'reset_success' } ) );\n\n\tconst [ dialogActive, setDialogActive ] = useState( false );\n\n\tuseEffect( () => {\n\t\tconst handleCloseModal = ( event ) => {\n\t\t\tif ( ESCAPE === event.keyCode ) {\n\t\t\t\t// Only close the modal if the \"Escape\" key is pressed.\n\t\t\t\tsetDialogActive( false );\n\t\t\t}\n\t\t};\n\n\t\tif ( dialogActive ) {\n\t\t\t// When the dialogActive changes and it is set to true(has opened), add the event listener.\n\t\t\tglobal.addEventListener( 'keyup', handleCloseModal, false );\n\t\t}\n\t\t// Remove the event listener when the dialog is removed; there's no need\n\t\t// to have it attached when it won't be used.\n\t\treturn () => {\n\t\t\tif ( dialogActive ) {\n\t\t\t\t// When the dialogActive is true(is open) and its value changes, remove the event listener.\n\t\t\t\tglobal.removeEventListener( 'keyup', handleCloseModal );\n\t\t\t}\n\t\t};\n\t}, [ dialogActive ] );\n\n\tconst { reset } = useDispatch( CORE_SITE );\n\tconst { navigateTo } = useDispatch( CORE_LOCATION );\n\n\tconst handleUnlinkConfirm = useCallback( async () => {\n\t\tawait reset();\n\t\tclearWebStorage();\n\t\tnavigateTo( postResetURL );\n\t}, [ reset, postResetURL ] );\n\n\tconst toggleDialogActive = useCallback( () => {\n\t\tsetDialogActive( ! dialogActive );\n\t}, [ dialogActive ] );\n\n\tconst openDialog = useCallback( () => {\n\t\tsetDialogActive( true );\n\t}, [] );\n\n\treturn (\n\t\t<Fragment>\n\t\t\t<Link\n\t\t\t\tclassName=\"googlesitekit-reset-button\"\n\t\t\t\tonClick={ openDialog }\n\t\t\t\tinherit\n\t\t\t>\n\t\t\t\t{ children || __( 'Reset Site Kit', 'google-site-kit' ) }\n\t\t\t</Link>\n\t\t\t<Modal>\n\t\t\t\t<Dialog\n\t\t\t\t\tdialogActive={ dialogActive }\n\t\t\t\t\thandleConfirm={ handleUnlinkConfirm }\n\t\t\t\t\thandleDialog={ toggleDialogActive }\n\t\t\t\t\ttitle={ __( 'Reset Site Kit', 'google-site-kit' ) }\n\t\t\t\t\tsubtitle={ createInterpolateElement(\n\t\t\t\t\t\t__( `Resetting will disconnect all users and remove all Site Kit settings and data within WordPress. <br />You and any other users who wish to use Site Kit will need to reconnect to restore access.`, 'google-site-kit' ),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbr: <br />,\n\t\t\t\t\t\t} ) }\n\t\t\t\t\tconfirmButton={ __( 'Reset', 'google-site-kit' ) }\n\t\t\t\t\tdanger\n\t\t\t\t/>\n\t\t\t</Modal>\n\t\t</Fragment>\n\t);\n}\n\nexport default ResetButton;\n", "idx": 1, "id": 35547, "msg": "It looks like there's a new `isNavigatingTo( url )` selector for this very purpose so let's use this here instead. This way we just need to use the one selector rather than two. Let's assign that to a similar-named variable here (e.g. `isNavigatingToPostResetURL`) rather than the prop it's used with.", "proj": "google-site-kit-wp", "lang": "js"}
{"patch": "@@ -29,8 +29,8 @@\n \n namespace lbann {\n \n-void im2col(const Mat& im,\n-            Mat& col,\n+void im2col(const AbsMat& im,\n+            AbsMat& col,\n             const int num_channels,\n             const int im_num_dims,\n             const int * im_dims,", "y": 1, "oldf": "////////////////////////////////////////////////////////////////////////////////\n// Copyright (c) 2014-2016, Lawrence Livermore National Security, LLC.\n// Produced at the Lawrence Livermore National Laboratory.\n// Written by the LBANN Research Team (B. Van Essen, et al.) listed in\n// the CONTRIBUTORS file. <lbann-dev@llnl.gov>\n//\n// LLNL-CODE-697807.\n// All rights reserved.\n//\n// This file is part of LBANN: Livermore Big Artificial Neural Network\n// Toolkit. For details, see http://software.llnl.gov/LBANN or\n// https://github.com/LLNL/LBANN.\n//\n// Licensed under the Apache License, Version 2.0 (the \"Licensee\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at:\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the license.\n////////////////////////////////////////////////////////////////////////////////\n\n#include \"lbann/utils/im2col.hpp\"\n#include \"lbann/utils/exception.hpp\"\n\nnamespace lbann {\n\nvoid im2col(const Mat& im,\n            Mat& col,\n            const int num_channels,\n            const int im_num_dims,\n            const int * im_dims,\n            const int * im_pads,\n            const int * window_dims,\n            const int * window_strides) {\n\n  // Input and output parameters\n  const int col_height = col.Height();\n  const int col_width = col.Width();\n  const DataType *__restrict__ im_buffer = im.LockedBuffer();\n  DataType *__restrict__ col_buffer = col.Buffer();\n\n  // im2col parameters\n  std::vector<int> offset_start(im_num_dims);\n  std::vector<int> offset_end(im_num_dims);\n  std::vector<int> offset_stride(im_num_dims);\n  std::vector<int> offset_num(im_num_dims);\n  for(int d = 0; d < im_num_dims; ++d) {\n    offset_start[d] = -im_pads[d];\n    offset_end[d] = im_dims[d] + im_pads[d] - window_dims[d] + 1;\n    offset_stride[d] = window_strides[d];\n    offset_num[d] = (offset_end[d] - offset_start[d] + offset_stride[d] - 1) / offset_stride[d];\n  }\n\n  #ifdef LBANN_DEBUG\n  const int im_size = im.Height();\n  // Check matrix dimensions\n  const int expected_im_size = std::accumulate(im_dims,\n                                               im_dims + im_num_dims,\n                                               num_channels,\n                                               std::multiplies<int>());\n  const int expected_col_height = std::accumulate(window_dims,\n                                                  window_dims + im_num_dims,\n                                                  num_channels,\n                                                  std::multiplies<int>());\n  const int expected_col_width = std::accumulate(offset_num.begin(),\n                                                 offset_num.end(),\n                                                 1,\n                                                 std::multiplies<int>());\n  if(im_size != expected_im_size || im.Width() != 1) {\n    std::stringstream ss;\n    ss << \"im2col: im matrix has invalid dimensions \"\n       << \"(expected \" << expected_im_size << \" x \" << 1 << \", \"\n       << \"found \" << im_size << \" x \" << im.Width() << \")\";\n    throw lbann_exception(ss.str());\n  }\n  if(col_height != expected_col_height\n     || col_width != expected_col_width) {\n    std::stringstream ss;\n    ss << \"im2col: col matrix has invalid dimensions \"\n       << \"(expected \" << expected_col_height << \" x \" << expected_col_width << \", \"\n       << \"found \" << col_height << \" x \" << col_width << \")\";\n    throw lbann_exception(ss.str());\n  }\n  #endif // LBANN_DEBUG  \n\n  // Call optimized routine for 1x1 im2col\n  std::vector<int> zeros(im_num_dims, 0), ones(im_num_dims, 1);\n  if(std::equal(im_pads, im_pads + im_num_dims, zeros.begin())\n     && std::equal(window_dims, window_dims + im_num_dims, ones.begin())\n     && std::equal(window_strides, window_strides + im_num_dims, ones.begin())) {\n    im2col_1x1(im_buffer, col_buffer, num_channels, im_num_dims, im_dims);\n    return;\n  }\n\n  // Call optimized routine for 2D data\n  if(im_num_dims == 2) {\n    im2col_2d(im_buffer, col_buffer,\n              im_dims[1], im_dims[0], im_pads[1], im_pads[0], num_channels,\n              window_dims[1], window_dims[0],\n              window_strides[1], window_strides[0]);\n    return;\n  }\n\n  // Iterate through col matrix columns\n  #pragma omp parallel for\n  for(int col_col = 0; col_col < col_width; ++col_col) {\n\n    // Initialize arrays\n    std::vector<int> offset_pos(im_num_dims);\n    std::vector<int> window_pos(im_num_dims);\n\n    // Get position of current offset\n    int col_col_remainder = col_col;\n    for(int d = im_num_dims-1; d >= 0; --d) {\n      const int offset = col_col_remainder % offset_num[d];\n      offset_pos[d] = offset_start[d] + offset * offset_stride[d];\n      col_col_remainder /= offset_num[d];\n    }\n\n    // Iterate through col matrix entries\n    for(int col_row = 0; col_row < col_height; ++col_row) {\n      const int col_index = col_row + col_col * col_height;\n\n      // Get position in window and channel\n      int col_row_remainder = col_row;\n      for(int d = im_num_dims-1; d >= 0; --d) {\n        window_pos[d] = col_row_remainder % window_dims[d];\n        col_row_remainder /= window_dims[d];\n      }\n      const int channel = col_row_remainder;\n\n      // Get im matrix entry\n      bool im_pos_valid = true;\n      int im_index = channel;\n      for(int d = 0; d < im_num_dims; ++d) {\n        const int im_pos = offset_pos[d] + window_pos[d];\n        im_pos_valid = im_pos_valid && 0 <= im_pos && im_pos < im_dims[d];\n        im_index = im_pos + im_index * im_dims[d];\n      }\n\n      // Copy im matrix entry to col matrix if valid\n      col_buffer[col_index] = (im_pos_valid ?\n                               im_buffer[im_index] : DataType(0));\n\n    }\n  }\n\n}\n\nvoid col2im(const Mat& col,\n            Mat& im,\n            const int num_channels,\n            const int im_num_dims,\n            const int * im_dims,\n            const int * im_pads,\n            const int * window_dims,\n            const int * window_strides) {\n\n  // Input and output parameters\n  const DataType *__restrict__ col_buffer = col.LockedBuffer();\n  DataType *__restrict__ im_buffer = im.Buffer();\n\n  // col2im parameters\n  std::vector<int> offset_start(im_num_dims);\n  std::vector<int> offset_end(im_num_dims);\n  std::vector<int> offset_stride(im_num_dims);\n  std::vector<int> offset_num(im_num_dims);\n  for(int d = 0; d < im_num_dims; ++d) {\n    offset_start[d] = -im_pads[d];\n    offset_end[d] = im_dims[d] + im_pads[d] - window_dims[d] + 1;\n    offset_stride[d] = window_strides[d];\n    offset_num[d] = (offset_end[d] - offset_start[d] + offset_stride[d] - 1) / offset_stride[d];\n  }\n\n  #ifdef LBANN_DEBUG\n  const int im_size = im.Height();\n  const int col_height = col.Height();\n  const int col_width = col.Width();\n  // Check matrix dimensions\n  const int expected_im_size = std::accumulate(im_dims,\n                                               im_dims + im_num_dims,\n                                               num_channels,\n                                               std::multiplies<int>());\n  const int expected_col_height = std::accumulate(window_dims,\n                                                  window_dims + im_num_dims,\n                                                  num_channels,\n                                                  std::multiplies<int>());\n  const int expected_col_width = std::accumulate(offset_num.begin(),\n                                                 offset_num.end(),\n                                                 1,\n                                                 std::multiplies<int>());\n  if(im_size != expected_im_size || im.Width() != 1) {\n    std::stringstream ss;\n    ss << \"im2col: im matrix has invalid dimensions \"\n       << \"(expected \" << expected_im_size << \" x \" << 1 << \", \"\n       << \"found \" << im_size << \" x \" << im.Width() << \")\";\n    throw lbann_exception(ss.str());\n  }\n  if(col_height != expected_col_height\n     || col_width != expected_col_width) {\n    std::stringstream ss;\n    ss << \"im2col: col matrix has invalid dimensions \"\n       << \"(expected \" << expected_col_height << \" x \" << expected_col_width << \", \"\n       << \"found \" << col_height << \" x \" << col_width << \")\";\n    throw lbann_exception(ss.str());\n  }\n  #endif // LBANN_DEBUG  \n\n  // Call optimized routine for 1x1 col2im\n  std::vector<int> zeros(im_num_dims, 0), ones(im_num_dims, 1);\n  if(std::equal(im_pads, im_pads + im_num_dims, zeros.begin())\n     && std::equal(window_dims, window_dims + im_num_dims, ones.begin())\n     && std::equal(window_strides, window_strides + im_num_dims, ones.begin())) {\n    col2im_1x1(col_buffer, im_buffer, num_channels, im_num_dims, im_dims);\n    return;\n  }\n\n  // Call optimized routine for 2D data\n  if(im_num_dims == 2) {\n    col2im_2d(col_buffer, im_buffer,\n              im_dims[1], im_dims[0], im_pads[1], im_pads[0], num_channels,\n              window_dims[1], window_dims[0],\n              window_strides[1], window_strides[0]);\n    return;\n  }\n\n  // Default algorithm\n  col2im(col, im, num_channels, im_num_dims,\n         im_dims, im_pads, window_dims, window_strides,\n         std::plus<DataType>());\n\n}\n\nvoid col2im(const Mat& col,\n            Mat& im,\n            const int num_channels,\n            const int im_num_dims,\n            const int * im_dims,\n            const int * im_pads,\n            const int * window_dims,\n            const int * window_strides,\n            std::function<DataType(const DataType&,const DataType&)> reduction_op) {\n\n  // Input and output parameters\n  const int col_height = col.Height();\n  const int im_size = im.Height();\n  const DataType *__restrict__ col_buffer = col.LockedBuffer();\n  DataType *__restrict__ im_buffer = im.Buffer();\n\n  // im2col parameters\n  std::vector<int> offset_start(im_num_dims);\n  std::vector<int> offset_end(im_num_dims);\n  std::vector<int> offset_stride(im_num_dims);\n  std::vector<int> offset_num(im_num_dims);\n  for(int d = 0; d < im_num_dims; ++d) {\n    offset_start[d] = -im_pads[d];\n    offset_end[d] = im_dims[d] + im_pads[d] - window_dims[d] + 1;\n    offset_stride[d] = window_strides[d];\n    offset_num[d] = (offset_end[d] - offset_start[d] + offset_stride[d] - 1) / offset_stride[d];\n  }\n\n  // Call optimized routine for 1x1 col2im\n  std::vector<int> zeros(im_num_dims, 0), ones(im_num_dims, 1);\n  if(std::equal(im_pads, im_pads + im_num_dims, zeros.begin())\n     && std::equal(window_dims, window_dims + im_num_dims, ones.begin())\n     && std::equal(window_strides, window_strides + im_num_dims, ones.begin())) {\n    col2im_1x1(col_buffer, im_buffer, num_channels, im_num_dims, im_dims);\n    return;\n  }\n\n  // Iterate through im matrix entries\n  #pragma omp parallel for\n  for(int im_index = 0; im_index < im_size; ++im_index) {\n\n    // Initialize arrays\n    std::vector<int> im_pos(im_num_dims);\n    std::vector<int> first_offset(im_num_dims);\n    std::vector<int> last_offset(im_num_dims);\n    std::vector<int> offset(im_num_dims);\n\n    // Get position of im matrix entry\n    int im_index_remainder = im_index;\n    for(int d = im_num_dims-1; d >= 0; --d) {\n      im_pos[d] = im_index_remainder % im_dims[d];\n      im_index_remainder /= im_dims[d];\n    }\n    const int channel = im_index_remainder;\n\n    // Initialize im matrix entry\n    DataType im_entry = 0;\n    bool im_entry_initialized = false;\n    bool offsets_finished = false;\n\n    // Get window offsets containing im matrix entry\n    for(int d = 0; d < im_num_dims; ++d) {\n      first_offset[d] = (im_pos[d] - offset_start[d] - window_dims[d] + offset_stride[d]) / offset_stride[d];\n      first_offset[d] = std::max(first_offset[d], 0);\n      last_offset[d] = (im_pos[d] - offset_start[d]) / offset_stride[d];\n      last_offset[d] = std::min(last_offset[d], offset_num[d] - 1);\n      offset[d] = first_offset[d];\n      if(first_offset[d] > last_offset[d]) {\n        offsets_finished = true;\n      }\n    }\n\n    // Iterate through window offsets containing im matrix entry\n    while(!offsets_finished) {\n\n      // Get col matrix entry corresponding to im matrix entry\n      int col_row = channel;\n      int col_col = 0;\n      for(int d = 0; d < im_num_dims; ++d) {\n        const int window_pos = im_pos[d] - (offset_start[d] + offset[d] * offset_stride[d]);\n        col_row = window_pos + col_row * window_dims[d];\n        col_col = offset[d] + col_col * offset_num[d];\n      }\n      const int col_index = col_row + col_col * col_height;\n\n      // Add col matrix entry to im matrix entry\n      const DataType col_entry = col_buffer[col_index];\n      im_entry = (im_entry_initialized ?\n                  reduction_op(im_entry, col_entry) :\n                  col_entry);\n      im_entry_initialized = true;\n\n      // Move to next window offset\n      ++offset[im_num_dims-1];\n      for(int d = im_num_dims-1; d >= 1; --d) {\n        if(offset[d] > last_offset[d]) {\n          offset[d] = first_offset[d];\n          ++offset[d-1];\n        }\n      }\n      offsets_finished = offset[0] > last_offset[0];\n      \n    }\n\n    // Update output entry\n    im_buffer[im_index] = im_entry;\n\n  }\n\n}\n\nvoid im2col_1x1(const DataType * input_buffer,\n                DataType * output_buffer,\n                const int num_channels,\n                const int num_input_dims,\n                const int * input_dims) {\n  const int spatial_size = std::accumulate(input_dims,\n                                           input_dims + num_input_dims,\n                                           1,\n                                           std::multiplies<int>());\n  const Mat input_matrix(spatial_size, num_channels, input_buffer, spatial_size);\n  Mat output_matrix(num_channels, spatial_size, output_buffer, num_channels);\n  El::Transpose(input_matrix, output_matrix);\n}\n\nvoid im2col_2d(const DataType *__restrict__ input_buffer,\n               DataType *__restrict__ output_buffer,\n               const int input_dim_x,\n               const int input_dim_y,\n               const int input_pad_x,\n               const int input_pad_y,\n               const int num_channels,\n               const int window_dim_x,\n               const int window_dim_y,\n               const int offset_stride_x,\n               const int offset_stride_y) {\n\n  // im2col parameters\n  const int offset_start_x = -input_pad_x;\n  const int offset_start_y = -input_pad_y;\n  const int offset_end_x = input_dim_x + input_pad_x - window_dim_x + 1;\n  const int offset_end_y = input_dim_y + input_pad_y - window_dim_y + 1;\n  const int offset_num_x = (offset_end_x - offset_start_x + offset_stride_x - 1) / offset_stride_x;\n  const int offset_num_y = (offset_end_y - offset_start_y + offset_stride_y - 1) / offset_stride_y;\n  const int output_height = num_channels * window_dim_x * window_dim_y;\n\n  // Iterate through output matrix entries\n  #pragma omp parallel for collapse(5)\n  for(int offset_y = 0; offset_y < offset_num_y; ++offset_y) {\n    for(int offset_x = 0; offset_x < offset_num_x; ++offset_x) {\n      for(int channel = 0; channel < num_channels; ++channel) {\n        for(int window_pos_y = 0;\n            window_pos_y < window_dim_y;\n            ++window_pos_y) {\n          for(int window_pos_x = 0;\n              window_pos_x < window_dim_x;\n              ++window_pos_x) {\n\n            // Get input entry\n            const int offset_pos_y = offset_start_y + offset_y * offset_stride_y;\n            const int offset_pos_x = offset_start_x + offset_x * offset_stride_x;\n            const int input_pos_y = offset_pos_y + window_pos_y;\n            const int input_pos_x = offset_pos_x + window_pos_x;\n            const int input_index = (input_pos_x\n                                     + input_pos_y * input_dim_x\n                                     + channel * input_dim_x * input_dim_y);\n            const bool input_pos_valid = (0 <= input_pos_y\n                                          && input_pos_y < input_dim_y\n                                          && 0 <= input_pos_x\n                                          && input_pos_x < input_dim_x);\n\n            // Get output entry\n            const int output_row = (window_pos_x\n                                    + window_pos_y * window_dim_x\n                                    + channel * window_dim_x * window_dim_y);\n            const int output_col = offset_x + offset_y * offset_num_x;\n            const int output_index = output_row + output_col * output_height;\n\n            // Copy input entry to output entry if valid\n            output_buffer[output_index]\n              = input_pos_valid ? input_buffer[input_index] : DataType(0);\n\n          }\n        }\n      }\n    }\n  }\n\n}\n\nvoid col2im_1x1(const DataType * input_buffer,\n                DataType * output_buffer,\n                const int num_channels,\n                const int num_output_dims,\n                const int * output_dims) {\n  const int spatial_size = std::accumulate(output_dims,\n                                           output_dims + num_output_dims,\n                                           1,\n                                           std::multiplies<int>());\n  const Mat input_matrix(num_channels, spatial_size, input_buffer, num_channels);\n  Mat output_matrix(spatial_size, num_channels, output_buffer, spatial_size);\n  El::Transpose(input_matrix, output_matrix);\n}\n\nvoid col2im_2d(const DataType *__restrict__ input_buffer,\n               DataType *__restrict__ output_buffer,\n               const int output_dim_x,\n               const int output_dim_y,\n               const int output_pad_x,\n               const int output_pad_y,\n               const int num_channels,\n               const int window_dim_x,\n               const int window_dim_y,\n               const int offset_stride_x,\n               const int offset_stride_y) {\n\n  // col2im parameters\n  const int offset_start_x = -output_pad_x;\n  const int offset_start_y = -output_pad_y;\n  const int offset_end_x = output_dim_x + output_pad_x - window_dim_x + 1;\n  const int offset_end_y = output_dim_y + output_pad_y - window_dim_y + 1;\n  const int offset_num_x = (offset_end_x - offset_start_x + offset_stride_x - 1) / offset_stride_x;\n  const int offset_num_y = (offset_end_y - offset_start_y + offset_stride_y - 1) / offset_stride_y;\n  const int input_height = num_channels * window_dim_x * window_dim_y;\n\n  // Iterate through output entries\n  #pragma omp parallel for collapse(3)\n  for(int channel = 0; channel < num_channels; ++channel) {\n    for(int output_pos_y = 0;\n        output_pos_y < output_dim_y;\n        ++output_pos_y) {\n      for(int output_pos_x = 0;\n          output_pos_x < output_dim_x;\n          ++output_pos_x) {\n\n        // Get output entry\n        const int output_index = (output_pos_x\n                                  + output_pos_y * output_dim_x\n                                  + channel * output_dim_x * output_dim_y);\n        DataType output_entry = 0;\n\n        // Get window offsets containing output entry\n        const int offset_x_lower = (output_pos_x - offset_start_x - window_dim_x + offset_stride_x) / offset_stride_x;\n        const int offset_y_lower = (output_pos_y - offset_start_y - window_dim_y + offset_stride_y) / offset_stride_y;\n        const int offset_x_upper = (output_pos_x - offset_start_x) / offset_stride_x;\n        const int offset_y_upper = (output_pos_y - offset_start_y) / offset_stride_y;\n        const int first_offset_x = std::max(offset_x_lower, 0);\n        const int first_offset_y = std::max(offset_y_lower, 0);\n        const int last_offset_x = std::min(offset_x_upper, offset_num_x - 1);\n        const int last_offset_y = std::min(offset_y_upper, offset_num_y - 1);\n\n        // Iterate through window offsets\n        for(int offset_y = first_offset_y;\n            offset_y <= last_offset_y;\n            ++offset_y) {\n          const int window_pos_y = output_pos_y - (offset_start_y + offset_y * offset_stride_y);\n          for(int offset_x = first_offset_x;\n              offset_x <= last_offset_x;\n              ++offset_x) {\n            const int window_pos_x = output_pos_x - (offset_start_x + offset_x * offset_stride_x);\n\n            // Get input entry\n            const int input_row = (window_pos_x\n                                   + window_pos_y * window_dim_x\n                                   + channel * window_dim_x * window_dim_y);\n            const int input_col = offset_x + offset_y * offset_num_x;\n            const int input_index = input_row + input_col * input_height;\n\n            // Add input entry to output entry\n            output_entry += input_buffer[input_index];\n\n          }\n        }\n\n        // Update output entry\n        output_buffer[output_index] = output_entry;\n\n      }\n    }\n  }\n\n}\n\n}  // namespace lbann\n", "idx": 1, "id": 12526, "msg": "I think im2col should only accommodate CPUMat.", "proj": "LLNL-lbann", "lang": "cpp"}
{"patch": "@@ -24,6 +24,8 @@ from google.cloud.forseti.notifier.notifiers import cscc_notifier\n from google.cloud.forseti.notifier.notifiers.inventory_summary import InventorySummary\n from google.cloud.forseti.services.inventory.storage import DataAccess\n from google.cloud.forseti.services.scanner import dao as scanner_dao\n+from google.cloud.forseti.common.util.email.email_factory import EmailFactory\n+from google.cloud.forseti.notifier.notifiers import email_violations\n # pylint: enable=line-too-long\n \n ", "y": 1, "oldf": "# Copyright 2017 The Forseti Security Authors. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Notifier runner.\"\"\"\n\nimport importlib\nimport inspect\n\n# pylint: disable=line-too-long\nfrom google.cloud.forseti.common.util import logger\nfrom google.cloud.forseti.common.util import string_formats\nfrom google.cloud.forseti.notifier.notifiers.base_notification import BaseNotification\nfrom google.cloud.forseti.notifier.notifiers import cscc_notifier\nfrom google.cloud.forseti.notifier.notifiers.inventory_summary import InventorySummary\nfrom google.cloud.forseti.services.inventory.storage import DataAccess\nfrom google.cloud.forseti.services.scanner import dao as scanner_dao\n# pylint: enable=line-too-long\n\n\nLOGGER = logger.get_logger(__name__)\n\n\n# pylint: disable=inconsistent-return-statements\ndef find_notifiers(notifier_name):\n    \"\"\"Get the first class in the given sub module\n\n    Args:\n        notifier_name (str): Name of the notifier.\n\n    Return:\n        class: The class in the sub module\n    \"\"\"\n    try:\n        module = importlib.import_module(\n            'google.cloud.forseti.notifier.notifiers.{0}'.format(\n                notifier_name))\n        for filename in dir(module):\n            obj = getattr(module, filename)\n\n            if inspect.isclass(obj) \\\n                    and issubclass(obj, BaseNotification) \\\n                    and obj is not BaseNotification:\n                return obj\n    except ImportError:\n        LOGGER.exception('Can\\'t import notifier %s', notifier_name)\n\n# pylint: enable=inconsistent-return-statements\n\n\ndef convert_to_timestamp(violations):\n    \"\"\"Convert violation created_at_datetime to timestamp string.\n\n    Args:\n        violations (dict): List of violations as dict with\n            created_at_datetime.\n\n    Returns:\n        list: List of violations as dict with created_at_datetime\n            converted to timestamp string.\n    \"\"\"\n    for violation in violations:\n        violation['created_at_datetime'] = (\n            violation['created_at_datetime'].strftime(\n                string_formats.TIMESTAMP_TIMEZONE))\n\n    return violations\n\n\n# pylint: disable=too-many-branches,too-many-statements\ndef run(inventory_index_id,\n        scanner_index_id,\n        progress_queue,\n        service_config=None):\n    \"\"\"Run the notifier.\n\n    Entry point when the notifier is run as a library.\n\n    Args:\n        inventory_index_id (int64): Inventory index id.\n        scanner_index_id (int64): Scanner index id.\n        progress_queue (Queue): The progress queue.\n        service_config (ServiceConfig): Forseti 2.0 service configs.\n    Returns:\n        int: Status code.\n    \"\"\"\n    # pylint: disable=too-many-locals\n    global_configs = service_config.get_global_config()\n    notifier_configs = service_config.get_notifier_config()\n\n    with service_config.scoped_session() as session:\n        if scanner_index_id:\n            inventory_index_id = (\n                DataAccess.get_inventory_index_id_by_scanner_index_id(\n                    session,\n                    scanner_index_id))\n        else:\n            if not inventory_index_id:\n                inventory_index_id = (\n                    DataAccess.get_latest_inventory_index_id(session))\n            scanner_index_id = scanner_dao.get_latest_scanner_index_id(\n                session, inventory_index_id)\n\n        if not scanner_index_id:\n            LOGGER.error(\n                'No success or partial success scanner index found for '\n                'inventory index: \"%s\".', str(inventory_index_id))\n        else:\n            # get violations\n            violation_access = scanner_dao.ViolationAccess(session)\n            violations = violation_access.list(\n                scanner_index_id=scanner_index_id)\n            violations_as_dict = []\n            for violation in violations:\n                violations_as_dict.append(\n                    scanner_dao.convert_sqlalchemy_object_to_dict(violation))\n            violations_as_dict = convert_to_timestamp(violations_as_dict)\n            violation_map = scanner_dao.map_by_resource(violations_as_dict)\n\n            for retrieved_v in violation_map:\n                log_message = (\n                    'Retrieved {} violations for resource \\'{}\\''.format(\n                        len(violation_map[retrieved_v]), retrieved_v))\n                LOGGER.info(log_message)\n                progress_queue.put(log_message)\n\n            # build notification notifiers\n            notifiers = []\n            for resource in notifier_configs['resources']:\n                if violation_map.get(resource['resource']) is None:\n                    log_message = 'Resource \\'{}\\' has no violations'.format(\n                        resource['resource'])\n                    progress_queue.put(log_message)\n                    LOGGER.info(log_message)\n                    continue\n                if not resource['should_notify']:\n                    LOGGER.debug('Not notifying for: %s', resource['resource'])\n                    continue\n                for notifier in resource['notifiers']:\n                    log_message = (\n                        'Running \\'{}\\' notifier for resource \\'{}\\''.format(\n                            notifier['name'], resource['resource']))\n                    progress_queue.put(log_message)\n                    LOGGER.info(log_message)\n                    chosen_pipeline = find_notifiers(notifier['name'])\n                    notifiers.append(chosen_pipeline(\n                        resource['resource'], inventory_index_id,\n                        violation_map[resource['resource']], global_configs,\n                        notifier_configs, notifier['configuration']))\n\n            # Run the notifiers.\n            for notifier in notifiers:\n                notifier.run()\n\n            # Run the CSCC notifier.\n            violation_configs = notifier_configs.get('violation')\n            if violation_configs:\n                if violation_configs.get('cscc').get('enabled'):\n                    source_id = violation_configs.get('cscc').get('source_id')\n                    if source_id:\n                        # beta mode\n                        LOGGER.debug(\n                            'Running CSCC notifier with beta API. source_id: '\n                            '%s', source_id)\n                        (cscc_notifier.CsccNotifier(inventory_index_id)\n                         .run(violations_as_dict, source_id=source_id))\n                    else:\n                        # alpha mode\n                        LOGGER.debug('Running CSCC notifier with alpha API.')\n                        gcs_path = (\n                            violation_configs.get('cscc').get('gcs_path'))\n                        mode = violation_configs.get('cscc').get('mode')\n                        organization_id = (\n                            violation_configs.get('cscc').get(\n                                'organization_id'))\n                        (cscc_notifier.CsccNotifier(inventory_index_id)\n                         .run(violations_as_dict, gcs_path, mode,\n                              organization_id))\n\n        InventorySummary(service_config, inventory_index_id).run()\n\n        log_message = 'Notification completed!'\n        progress_queue.put(log_message)\n        progress_queue.put(None)\n        LOGGER.info(log_message)\n        return 0\n    # pylint: enable=too-many-branches,too-many-statements\n", "idx": 1, "id": 32995, "msg": "alpha sort the imports", "proj": "forseti-security-forseti-security", "lang": "py"}
{"patch": "@@ -1067,7 +1067,7 @@ fpga_result mmio_error(struct RASCommandLine *rasCmdLine)\n \tif ( rasCmdLine->function >0 )\n \t\tfunction = rasCmdLine->bus;\n \n-\tsnprintf(sysfs_path, sizeof(sysfs_path),\n+\tsnprintf_s_iiii(sysfs_path, sizeof(sysfs_path),\n \t\t\tDEVICEID_PATH,0,bus,device,function);\n \n \tresult = sysfs_read_u64(sysfs_path, &value);", "y": 1, "oldf": "// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n#include <errno.h>\n#include <stdbool.h>\n#include <malloc.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <getopt.h>\n#include <time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <uuid/uuid.h>\n\n#include \"safe_string/safe_string.h\"\n#include \"opae/fpga.h\"\n#include \"types_int.h\"\n#include \"common_int.h\"\n\n// SYSFS FME Errors\n#define FME_SYSFS_FME_ERRORS                   \"errors/fme-errors/errors\"\n#define FME_SYSFS_PCIE0_ERRORS                 \"errors/pcie0_errors\"\n#define FME_SYSFS_PCIE1_ERRORS                 \"errors/pcie1_errors\"\n\n#define FME_SYSFS_BBS_ERRORS                   \"errors/bbs_errors\"\n#define FME_SYSFS_GBS_ERRORS                   \"errors/gbs_errors\"\n#define FME_SYSFS_WARNING_ERRORS               \"errors/warning_errors\"\n\n#define FME_SYSFS_NONFATAL_ERRORS              \"errors/nonfatal_errors\"\n#define FME_SYSFS_CATFATAL_ERRORS              \"errors/catfatal_errors\"\n#define FME_SYSFS_INJECT_ERROR                 \"errors/inject_error\"\n\n#define FME_SYSFS_ERR_REVISION                 \"errors/revision\"\n\n#define PORT_SYSFS_ERR                         \"errors/errors\"\n#define PORT_SYSFS_ERR_CLEAR                   \"errors/clear\"\n\n// SYFS Thermal\n#define FME_SYSFS_THERMAL_MGMT_TEMP            \"thermal_mgmt/temperature\"\n#define FME_SYSFS_THERMAL_MGMT_THRESHOLD_TRIP  \"thermal_mgmt/threshold_trip\"\n\n// SYSFS Power\n#define FME_SYSFS_POWER_MGMT_CONSUMED          \"power_mgmt/consumed\"\n\n// MMIO scratchpad\n#define PORT_SCRATCHPAD0                       0x0028\n#define NLB_CSR_SCRATCHPAD                     (0x40000 + 0x0104 )\n#define PORT_MMIO_LEN                          (0x40000 + 0x0512 )\n\n#define MMO_WRITE64_VALUE                      0xF1F1F1F1F1F1F1F1\n#define MMO_WRITE32_VALUE                      0xF1F1F1\n\n#define FPGA_CSR_LEN                           64\n\n#define DEVICEID_PATH        \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/device\"\n#define FPGA_PORT_RES_PATH   \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/resource2\"\n\n\n#define FPGA_SET_BIT(val, index) val |= (1 << index)\n#define FPGA_CLEAR_BIT(val, index) val &= ~(1 << index)\n#define FPGA_TOGGLE_BIT(val, index) val ^= (1 << index)\n#define FPGA_BIT_IS_SET(val, index) (((val) >> (index)) & 1)\n\n/* Type definitions */\ntypedef struct {\n\tuint32_t uint[16];\n} cache_line;\n\n\nint usleep(unsigned);\n\n#ifndef CL\n# define CL(x)                       ((x) * 64)\n#endif // CL\n#ifndef LOG2_CL\n# define LOG2_CL                     6\n#endif // LOG2_CL\n#ifndef MB\n# define MB(x)                       ((x) * 1024 * 1024)\n#endif // MB\n\n#define CACHELINE_ALIGNED_ADDR(p) ((p) >> LOG2_CL)\n\n#define LPBK1_BUFFER_SIZE            MB(1)\n#define LPBK1_BUFFER_ALLOCATION_SIZE MB(2)\n#define LPBK1_DSM_SIZE               MB(2)\n#define CSR_SRC_ADDR                 0x0120\n#define CSR_DST_ADDR                 0x0128\n#define CSR_CTL                      0x0138\n#define CSR_CFG                      0x0140\n#define CSR_NUM_LINES                0x0130\n#define DSM_STATUS_TEST_COMPLETE     0x40\n#define CSR_AFU_DSM_BASEL            0x0110\n#define CSR_AFU_DSM_BASEH            0x0114\n\n/* SKX-P NLB0 AFU_ID */\n#define SKX_P_NLB0_AFUID \"D8424DC4-A4A3-C413-F89E-433683F9040B\"\n\nstatic const char * const FME_ERROR[] = {\n\t\t\"Fabric error detected\", \\\n\t\t\"Fabric fifo under / overflow error detected\", \\\n\t\t\"KTI CDC Parity Error detected\", \\\n\t\t\"KTI CDC Parity Error detected\", \\\n\t\t\"IOMMU Parity error detected\", \\\n\t\t\"AFU PF/VF access mismatch detected\", \\\n\t\t\"Indicates an MBP event error detected\", \\\n};\n\nstatic const char * const PCIE0_ERROR[] = {\n\t\t\"TLP format/type error detected\", \\\n\t\t\"TTLP MW address error detected\", \\\n\t\t\"TLP MW length error detected\", \\\n\t\t\"TLP MR address error detected\", \\\n\t\t\"TLP MR length error detected\", \\\n\t\t\"TLP CPL tag error detected\", \\\n\t\t\"TLP CPL status error detected\", \\\n\t\t\"TLP CPL timeout error detected\", \\\n\t\t\"CCI bridge parity error detected\", \\\n\t\t\"TLP with EP  error  detected\", \\\n};\n\nstatic const char * const PCIE1_ERROR[] = {\n\t\t\"TLP format/type error detected\", \\\n\t\t\"TTLP MW address error detected\", \\\n\t\t\"TLP MW length error detected\", \\\n\t\t\"TLP MR address error detected\", \\\n\t\t\"TLP MR length error detected\", \\\n\t\t\"TLP CPL tag error detected\", \\\n\t\t\"TLP CPL status error detected\", \\\n\t\t\"TLP CPL timeout error detected\", \\\n\t\t\"CCI bridge parity error detected\", \\\n\t\t\"TLP with EP  error  detected\", \\\n};\n\nstatic const char * const RAS_NONFATAL_ERROR [] = {\n\t\t\"Temperature threshold triggered AP1 detected\", \\\n\t\t\"Temperature threshold triggered AP2 detected\", \\\n\t\t\"PCIe error detected\", \\\n\t\t\"AFU port Fatal error detected\", \\\n\t\t\"ProcHot event error detected\", \\\n\t\t\"AFU PF/VF access mismatch error detected\", \\\n\t\t\"Injected Warning Error detected\", \\\n\t\t\"Reserved\", \\\n\t\t\"Reserved\", \\\n\t\t\"Temperature threshold triggered AP6 detected\", \\\n\t\t\"Power threshold triggered AP1 error detected\", \\\n\t\t\"Power threshold triggered AP2 error detected\", \\\n\t\t\"MBP event error detected\", \\\n};\n\nstatic const char * const RAS_CATFATAL_ERROR[] = {\n\t\t\"KTI link layer error detected.\", \\\n\t\t\"tag-n-cache error detected.\", \\\n\t\t\"CCI error detected.\", \\\n\t\t\"KTI protocol error detected.\", \\\n\t\t\"Fatal DRAM error detected\", \\\n\t\t\"IOMMU fatal parity error detected.\", \\\n\t\t\"Fabric fatal error detected\", \\\n\t\t\"Poison error from any of PCIe ports detected\", \\\n\t\t\"Injected Fatal Error detected\", \\\n\t\t\"Catastrophic CRC error detected\", \\\n\t\t\"Catastrophic thermal runaway event detected\", \\\n\t\t\"Injected Catastrophic Error detected\", \\\n};\n\nstatic const char * const RAS_INJECT_ERROR[] = {\n\t\t\"Set Catastrophic  error .\", \\\n\t\t\"Set Fatal error.\", \\\n\t\t\"Ser Non-fatal error .\", \\\n};\n\nstatic const char * const RAS_GBS_ERROR [] = {\n\t\t\"Temperature threshold triggered AP1 detected\", \\\n\t\t\"Temperature threshold triggered AP2 detected\", \\\n\t\t\"PCIe error detected\", \\\n\t\t\"AFU port Fatal error detected\", \\\n\t\t\"ProcHot event error detected\", \\\n\t\t\"AFU PF/VF access mismatch error detected\", \\\n\t\t\"Injected Warning Error detected\", \\\n\t\t\"Poison error from any of PCIe ports detected\", \\\n\t\t\"GBS CRC errordetected \", \\\n\t\t\"Temperature threshold triggered AP6 detected\", \\\n\t\t\"Power threshold triggered AP1 error detected\", \\\n\t\t\"Power threshold triggered AP2 error detected\", \\\n\t\t\"MBP event error detected\", \\\n};\n\nstatic const char * const RAS_BBS_ERROR[] = {\n\t\t\"KTI link layer error detected.\", \\\n\t\t\"tag-n-cache error detected.\", \\\n\t\t\"CCI error detected.\", \\\n\t\t\"KTI protocol error detected.\", \\\n\t\t\"Fatal DRAM error detected\", \\\n\t\t\"IOMMU fatal parity error detected.\", \\\n\t\t\"Fabric fatal error detected\", \\\n\t\t\"Poison error from any of PCIe ports detected\", \\\n\t\t\"Injected Fatal Error detected\", \\\n\t\t\"Catastrophic CRC error detected\", \\\n\t\t\"Catastrophic thermal runaway event detected\", \\\n\t\t\"Injected Catastrophic Error detected\", \\\n};\n\nstatic const char * const RAS_WARNING_ERROR[] = {\n\t\t\"Green bitstream fatal event error detected.\", \\\n};\n\nstatic const char * const PORT_ERROR[] = {\n\t\t\"Tx Channel 0 overflow error detected.\", \\\n\t\t\"Tx Channel 0 invalid request encodingr error detected.\", \\\n\t\t\"Tx Channel 0 cl_len=3 not supported error detected.\", \\\n\t\t\"Tx Channel 0 request with cl_len=2 does NOT have a 2CL aligned address error detected.\", \\\n\t\t\"Tx Channel 0 request with cl_len=4 does NOT have a 4CL aligned address error detected.\", \\\n\t\t\"RSVD.\", \"RSVD.\", \"RSVD.\",\"RSVD.\",\\\n\t\t\"AFU MMIO RD received while PORT is in reset error detected\", \\\n\t\t\"AFU MMIO WR received while PORT is in reset error detected\", \\\n\t\t\"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\",\\\n\t\t\"Tx Channel 1 invalid request encoding error detected\", \\\n\t\t\"Tx Channel 1 cl_len=3 not supported error detected.\", \\\n\t\t\"Tx Channel 1 request with cl_len=2 does NOT have a 2CL aligned address error detected\", \\\n\t\t\"Tx Channel 1 request with cl_len=4 does NOT have a 4CL aligned address error detected\", \\\n\t\t\"Tx Channel 1 insufficient data payload Error detected\", \\\n\t\t\"Tx Channel 1 data payload overrun error detected\", \\\n\t\t\"Tx Channel 1 incorrect address on subsequent payloads error detected\", \\\n\t\t\"Tx Channel 1 Non-zero SOP detected for requests!=WrLine_* error detected\", \\\n\t\t\"Tx Channel 1 Illegal VC_SEL. Atomic request is only supported on VL0 error detected\", \\\n\t\t\"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\",\\\n\t\t\"MMIO TimedOut error detected\", \\\n\t\t\"Tx Channel 2 fifo overflo error detected\", \\\n\t\t\"MMIO Read response received, with no matching request pending error detected\", \\\n\t\t\"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\", \"RSVD.\", \\\n\t\t\"Number of pending requests: counter overflow error detected\", \\\n\t\t\"Request with Address violating SMM range error detected\", \\\n\t\t\"Request with Address violating second SMM range error detected\", \\\n\t\t\"Request with Address violating ME stolen range\", \\\n\t\t\"Request with Address violating Generic protected range error detected \", \\\n\t\t\"Request with Address violating Legacy Range Low error detected\", \\\n\t\t\"Request with Address violating Legacy Range High error detected\", \\\n\t\t\"Request with Address violating VGA memory range error detected\", \\\n\t\t\"Page Fault error detected\", \\\n\t\t\"PMR Erro error detected\", \\\n\t\t\"AP6 event detected \", \\\n\t\t\"VF FLR detected on port when PORT configured in PF access mode error detected \", \\\n};\n\n// RAS Error Inject CSR\nstruct ras_inject_error {\n\tunion {\n\t\tuint64_t csr;\n\t\tstruct {\n\t\t\t/* Catastrophic  error */\n\t\t\tuint64_t  catastrophicr_error : 1;\n\t\t\t/* Fatal error */\n\t\t\tuint64_t  fatal_error : 1;\n\t\t\t/* Non-fatal error */\n\t\t\tuint64_t  nonfatal_error : 1;\n\t\t\t/* Reserved */\n\t\t\tuint64_t  rsvd : 61;\n\t\t};\n\t};\n};\n\n#define GETOPT_STRING \":hB:D:F:S:PQRNTCEGHIO\"\n\nstruct option longopts[] = {\n\t\t{\"help\",                no_argument,       NULL, 'h'},\n\t\t{\"bus-number\",          required_argument, NULL, 'B'},\n\t\t{\"device-number\",       required_argument, NULL, 'D'},\n\t\t{\"function-number\",     required_argument, NULL, 'F'},\n\t\t{\"socket-number\",       required_argument, NULL, 'S'},\n\t\t{\"print-error\",         no_argument,       NULL, 'P'},\n\t\t{\"catast-error\",        no_argument,       NULL, 'Q'},\n\t\t{\"fatal-error\",         no_argument,       NULL, 'R'},\n\t\t{\"nofatal-error\",       no_argument,       NULL, 'N'},\n\t\t{\"thermal-trip\",        no_argument,       NULL, 'T'},\n\t\t{\"clearinj-error\",      no_argument,       NULL, 'C'},\n\t\t{\"mwaddress-error\",     no_argument,       NULL, 'E'},\n\t\t{\"mraddress-error\",     no_argument,       NULL, 'G'},\n\t\t{\"mwlength-error\",      no_argument,       NULL, 'H'},\n\t\t{\"mrlength-error\",      no_argument,       NULL, 'I'},\n\t\t{\"pagefault-error\",     no_argument,       NULL, 'O'},\n\t\t{0,0,0,0}\n};\n\n// RAS Command line struct\nstruct  RASCommandLine\n{\n\tuint32_t          flags;\n#define RASAPP_CMD_FLAG_HELP      0x00000001\n#define RASAPP_CMD_FLAG_VERSION   0x00000002\n#define RASAPP_CMD_PARSE_ERROR    0x00000003\n\n#define RASAPP_CMD_FLAG_BUS       0x00000008\n#define RASAPP_CMD_FLAG_DEV       0x00000010\n#define RASAPP_CMD_FLAG_FUNC      0x00000020\n#define RASAPP_CMD_FLAG_SOCKET    0x00000040\n\n\tint      bus;\n\tint      device;\n\tint      function;\n\tint      socket;\n\tbool     print_error;\n\tbool     catast_error;\n\tbool     fatal_error;\n\tbool     nonfatal_error;\n\tbool     clear_injerror;\n\tbool     mwaddress_error;\n\tbool     mraddress_error;\n\tbool     mwlength_error;\n\tbool     mrlength_error;\n\tbool     pagefault_error;\n};\n\nstruct RASCommandLine rasCmdLine = { 0, -1, -1, -1, -1, false,\n\t\t\t\tfalse, false, false,false,\n\t\t\t\tfalse, false, false, false, false};\n\n// RAS Command line input help\nvoid RASAppShowHelp()\n{\n\tprintf(\"Usage:\\n\");\n\tprintf(\"./ras \\n\");\n\tprintf(\"<Bus>              --bus=<BUS NUMBER>           \"\n\t\t\"OR  -B=<BUS NUMBER>\\n\");\n\tprintf(\"<Device>           --device=<DEVICE NUMBER>     \"\n\t\t\"OR  -D=<DEVICE NUMBER>\\n\");\n\tprintf(\"<Function>         --function=<FUNCTION NUMBER> \"\n\t\t\"OR  -F=<FUNCTION NUMBER>\\n\");\n\tprintf(\"<Socket>           --socket=<socket NUMBER>    \"\n\t\t\" OR  -S=<SOCKET NUMBER>\\n\");\n\tprintf(\"<Print Error>      --print-error                OR  -P \\n\");\n\tprintf(\"<Catast Error>     --catast-error               OR  -Q \\n\");\n\tprintf(\"<Fatal Error>      --fatal-error                OR  -R \\n\");\n\tprintf(\"<NoFatal Error>    --nofatal-error              OR  -N \\n\");\n\tprintf(\"<Clear Inj Error>  --clearinj-error             OR  -C \\n\");\n\tprintf(\"<MW Address error> --mwaddress-error            OR  -E \\n\");\n\tprintf(\"<MR Address error> --mwaddress-error            OR  -G \\n\");\n\tprintf(\"<MW Length error>  --mwlength-error             OR  -H \\n\");\n\tprintf(\"<MR Length error>  --mrlength-error             OR  -I \\n\");\n\tprintf(\"<Page Fault Error> --pagefault-error            OR  -O \\n\");\n\tprintf(\"\\n\");\n\n}\n\n/*\n * macro to check return codes, print error message, and goto cleanup label\n * NOTE: this changes the program flow (uses goto)!\n */\n#define ON_ERR_GOTO(res, label, desc)                    \\\n\t\tdo {                                       \\\n\t\t\tif ((res) != FPGA_OK) {            \\\n\t\t\t\tprint_err((desc), (res));  \\\n\t\t\t\tgoto label;                \\\n\t\t\t}                                  \\\n\t\t} while (0)\n\nvoid print_err(const char *s, fpga_result res)\n{\n\tfprintf(stderr, \"Error %s: %s\\n\", s, fpgaErrStr(res));\n}\n\nfpga_result print_ras_errors(fpga_token token);\nfpga_result print_pwr_temp(fpga_token token);\nfpga_result clear_inject_ras_errors(fpga_token token,\n\t\t\t\t\tstruct RASCommandLine *rasCmdLine);\nfpga_result inject_ras_errors(fpga_token token,\n\t\t\t\tstruct RASCommandLine *rasCmdLine);\nfpga_result mmio_error(struct RASCommandLine *rasCmdLine);\nfpga_result print_port_errors(fpga_token token);\nfpga_result clear_port_errors(fpga_token token);\nfpga_result page_fault_errors();\nint ParseCmds(struct RASCommandLine *rasCmdLine, int argc, char *argv[]);\n\nint main( int argc, char** argv )\n{\n\tfpga_result result          = 0;\n\tfpga_properties filter      = NULL;\n\tfpga_token fme_token ;\n\tuint32_t num_matches        = 1;\n\n\t// Parse command line\n\tif ( argc < 2 ) {\n\t\tRASAppShowHelp();\n\treturn 1;\n\t} else if ( 0!= ParseCmds(&rasCmdLine, argc, argv) ) {\n\t\tFPGA_ERR( \"Error scanning command line \\n.\");\n\treturn 2;\n\t}\n\n\tprintf(\" ------- Command line Input Start ---- \\n \\n\");\n\n\tprintf(\" Bus                   : %d\\n\", rasCmdLine.bus);\n\tprintf(\" Device                : %d \\n\", rasCmdLine.device);\n\tprintf(\" Function              : %d \\n\", rasCmdLine.function);\n\tprintf(\" Socket                : %d \\n\", rasCmdLine.socket);\n\tprintf(\" Print Error           : %d \\n\", rasCmdLine.print_error);\n\tprintf(\" Catas Error           : %d \\n\", rasCmdLine.catast_error);\n\tprintf(\" Fatal Error           : %d \\n\", rasCmdLine.fatal_error);\n\tprintf(\" NonFatal Error        : %d \\n\", rasCmdLine.nonfatal_error);\n\tprintf(\" Clear Error           : %d \\n\", rasCmdLine.clear_injerror);\n \tprintf(\" MW Address Error      : %d \\n\", rasCmdLine.mwaddress_error);\n\tprintf(\" MR Address Error      : %d \\n\", rasCmdLine.mraddress_error);\n\tprintf(\" MW Length Error       : %d \\n\", rasCmdLine.mwlength_error);\n\tprintf(\" MR Length Error       : %d \\n\", rasCmdLine.mrlength_error);\n\tprintf(\" Page Fault Error      : %d \\n\", rasCmdLine.pagefault_error);\n\n\tprintf(\" ------- Command line Input END ---- \\n\\n\");\n\n\t// Enum FPGA device\n\tresult = fpgaGetProperties(NULL, &filter);\n\tON_ERR_GOTO(result, out_exit, \"creating properties object\");\n\n\tresult = fpgaPropertiesSetObjectType(filter, FPGA_DEVICE);\n\tON_ERR_GOTO(result, out_destroy_prop, \"setting object type\");\n\n\tif (rasCmdLine.bus >0){\n\t\tresult = fpgaPropertiesSetBus(filter, rasCmdLine.bus);\n\t\tON_ERR_GOTO(result, out_destroy_prop, \"setting bus\");\n\t}\n\n\tif (rasCmdLine.device >0) {\n\t\tresult = fpgaPropertiesSetDevice(filter, rasCmdLine.device);\n\t\tON_ERR_GOTO(result, out_destroy_prop, \"setting device\");\n\t}\n\n\tif (rasCmdLine.function >0){\n\t\tresult = fpgaPropertiesSetFunction(filter, rasCmdLine.function);\n\t\tON_ERR_GOTO(result, out_destroy_prop, \"setting function\");\n\t}\n\n\tif (rasCmdLine.socket >0){\n\t\tresult = fpgaPropertiesSetSocketID(filter, rasCmdLine.socket);\n\t\tON_ERR_GOTO(result, out_destroy_prop, \"setting socket\");\n\t}\n\n\tresult = fpgaEnumerate(&filter, 1, &fme_token,1, &num_matches);\n\tON_ERR_GOTO(result, out_destroy_prop, \"enumerating FPGAs\");\n\n\tif (num_matches < 1) {\n\t\tfprintf(stderr, \"FPGA Resource not found.\\n\");\n\t\tresult = fpgaDestroyProperties(&filter);\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\tfprintf(stderr, \"FME Resource found.\\n\");\n\n\t// Inject error\n\tif (rasCmdLine.catast_error ||\n\t\trasCmdLine.fatal_error ||\n\t\trasCmdLine.nonfatal_error) {\n\n\t\t// Inject RAS ERROR\n\t\tresult = inject_ras_errors(fme_token,&rasCmdLine);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to print fme errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\t}\n\n\t// inject MMIO error\n\tif ( (rasCmdLine.mwaddress_error == true) ||\n\t\t(rasCmdLine.mraddress_error == true) ||\n\t\t(rasCmdLine.mwlength_error == true) ||\n\t\t(rasCmdLine.mrlength_error == true) ) {\n\n\t\tresult = mmio_error(&rasCmdLine);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed set MMIO errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\t}\n\n\t// Clear Inject Error\n\tif (rasCmdLine.clear_injerror ) {\n\n\t\t// clear RAS ERROR\n\t\tresult = clear_inject_ras_errors(fme_token,&rasCmdLine);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to clear inject errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\n\t\t// clear Port ERROR\n\t\tresult = clear_port_errors(fme_token);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to clear port errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\t}\n\n\tif (rasCmdLine.pagefault_error) {\n\t\t// Page fault error\n\t\tresult = page_fault_errors();\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to trigger page fault errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\t}\n\n\n\tsleep(1);\n\n\tif (rasCmdLine.print_error) {\n\t// Print RAS Error\n\t\tresult = print_ras_errors(fme_token);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to print fme errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\n\t\t// Print port Error\n\t\tresult = print_port_errors(fme_token);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to print port errors\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\n\t\t// Print power and temp\n\t\tresult = print_pwr_temp(fme_token);\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get power and temp\");\n\t\t\tgoto out_destroy_prop;\n\t\t}\n\t}\n\n\n\t/* Destroy properties object */\nout_destroy_prop:\n\tresult = fpgaDestroyProperties(&filter);\n\tON_ERR_GOTO(result, out_exit, \"destroying properties object\");\n\nout_exit:\n\treturn result;\n\n}\n\n// Print Error\nfpga_result print_errors(fpga_token token,\n\t\t\tconst char * err_path,\n\t\t\tconst char * const* err_strings,\n\t\t\tint size)\n{\n\tstruct _fpga_token  *_token       = 0;\n\tint i                             = 0;\n\tuint64_t value                    = 0;\n\tchar syfs_path[SYSFS_PATH_MAX]    = {0};\n\tfpga_result result                = FPGA_OK;\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tif(err_path == NULL ||\n\t\terr_strings == NULL) {\n\t\tFPGA_ERR(\"Invalid input sting\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tsnprintf_s_ss(syfs_path, sizeof(syfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\terr_path );\n\n\t// Read error.\n\tresult = sysfs_read_u64(syfs_path, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to get errors\");\n\t\treturn result;\n\t}\n\n\tprintf(\" CSR : 0x%lx \\n\", value);\n\tfor (i = 0; i < FPGA_CSR_LEN; i++) {\n\t\tif ((i < size) && FPGA_BIT_IS_SET(value, i)) {\n\t\t\tprintf(\"\\t %s \\n\", err_strings[i]);\n\t\t}\n\t}\n\treturn result;\n}\n\n// prints RAS errors\nfpga_result print_ras_errors(fpga_token token)\n{\n\tstruct _fpga_token  *_token       = 0;\n\tuint64_t revision                 = 0;\n\tchar syfs_path[SYSFS_PATH_MAX]    = {0};\n\tfpga_result result                = FPGA_OK;\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tprintf(\"\\n ==========================================\\n\");\n\tprintf(\" ----------- PRINT FME ERROR  START-------- \\n \\n\");\n\n\t// get revision\n\tsnprintf_s_ss(syfs_path, sizeof(syfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\tFME_SYSFS_ERR_REVISION );\n\n\t// Read revision.\n\tresult = sysfs_read_u64(syfs_path, &revision);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to get fme revison\");\n\t\treturn result;\n\t}\n\tprintf(\" fme error revison : %ld \\n\", revision);\n\n\t// Revision 0\n\tif( revision == 1 ) {\n\n\t\t// Non Fatal Error\n\t\tprintf(\"\\n ------- Non Fatal error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_NONFATAL_ERRORS,\n\t\t\t\t\tRAS_NONFATAL_ERROR,\n\t\t\t\t\tsizeof(RAS_NONFATAL_ERROR) /sizeof(RAS_NONFATAL_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme non fatal errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// Fatal Error\n\t\tprintf(\"\\n ------- Fatal error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\tFME_SYSFS_CATFATAL_ERRORS,\n\t\t\t\tRAS_CATFATAL_ERROR,\n\t\t\t\tsizeof(RAS_CATFATAL_ERROR) /sizeof(RAS_CATFATAL_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme fatal errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// Injected error\n\t\tprintf(\"\\n ------- Injected error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_INJECT_ERROR,\n\t\t\t\t\tRAS_INJECT_ERROR,\n\t\t\t\t\tsizeof(RAS_INJECT_ERROR) /sizeof(RAS_INJECT_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme Injected errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// FME error\n\t\tprintf(\"\\n ------- FME error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_FME_ERRORS,\n\t\t\t\t\tFME_ERROR,\n\t\t\t\t\tsizeof(FME_ERROR) /sizeof(FME_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme  errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// PCIe0 error\n\t\tprintf(\"\\n ------- PCIe0 error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_PCIE0_ERRORS,\n\t\t\t\t\tPCIE0_ERROR,\n\t\t\t\t\tsizeof(PCIE0_ERROR) /sizeof(PCIE0_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get pcie0  errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// PCIe1 error\n\t\tprintf(\"\\n ------- PCIe1 error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_PCIE1_ERRORS,\n\t\t\t\t\tPCIE1_ERROR,\n\t\t\t\t\tsizeof(PCIE1_ERROR) /sizeof(PCIE1_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get pcie1  errors\");\n\t\t\treturn result;\n\t\t}\n\n\t// Revision 0\n\t} else if( revision == 0){\n\n\t\t// GBS Error\n\t\tprintf(\"\\n ------- GBS error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_GBS_ERRORS,\n\t\t\t\t\tRAS_GBS_ERROR,\n\t\t\t\t\tsizeof(RAS_GBS_ERROR) /sizeof(RAS_GBS_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme gbs errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// BBS Error\n\t\tprintf(\"\\n ------- BBS error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_BBS_ERRORS,\n\t\t\t\t\tRAS_BBS_ERROR,\n\t\t\t\t\tsizeof(RAS_BBS_ERROR) /sizeof(RAS_BBS_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme bbs errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// Injected error\n\t\tprintf(\"\\n ------- Injected error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_INJECT_ERROR,\n\t\t\t\t\tRAS_INJECT_ERROR,\n\t\t\t\t\tsizeof(RAS_INJECT_ERROR) /sizeof(RAS_INJECT_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme Injected errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// FME error\n\t\tprintf(\"\\n ------- FME error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_FME_ERRORS,\n\t\t\t\t\tFME_ERROR,\n\t\t\t\t\tsizeof(FME_ERROR) /sizeof(FME_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get fme  errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// PCIe0 error\n\t\tprintf(\"\\n ------- PCIe0 error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_PCIE0_ERRORS,\n\t\t\t\t\tPCIE0_ERROR,\n\t\t\t\t\tsizeof(PCIE0_ERROR) /sizeof(PCIE0_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get pcie0  errors\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// PCIe1 error\n\t\tprintf(\"\\n ------- PCIe1 error ------------ \\n\");\n\t\tresult = print_errors(token,\n\t\t\t\t\tFME_SYSFS_PCIE1_ERRORS,\n\t\t\t\t\tPCIE1_ERROR,\n\t\t\t\t\tsizeof(PCIE1_ERROR) /sizeof(PCIE1_ERROR[0]));\n\n\t\tif (result != FPGA_OK) {\n\t\t\tFPGA_ERR(\"Failed  to get pcie1  errors\");\n\t\t\treturn result;\n\t\t}\n\n\t} else {\n\t\tprintf(\"\\n Invalid FME Error Revision \\n\");\n\t}\n\n\tprintf(\"\\n ----------- PRINT FME ERROR  END----------\\n\");\n\tprintf(\" ========================================== \\n \\n\");\n\treturn result;\n}\n// prints PORT errors\nfpga_result print_port_errors(fpga_token token)\n{\n\tstruct _fpga_token  *_token       = 0;\n\tint i                             = 0;\n\tuint64_t value                    = 0;\n\tint size                          = 0;\n\tchar sysfs_port[SYSFS_PATH_MAX]   = {0};\n\tfpga_result result                = FPGA_OK;\n\tchar *p                           = 0;\n\tint device_id                     = 0;\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tprintf(\"\\n ==========================================\\n\");\n\tprintf(\" ----------- PRINT PORT ERROR  START-------- \\n \\n\");\n\n\tp = strstr(_token->sysfspath, FPGA_SYSFS_FME);\n\tif (NULL == p)\n\t\treturn FPGA_INVALID_PARAM;\n\tp = strrchr(_token->sysfspath, '.');\n\tif (NULL == p)\n\t\treturn FPGA_INVALID_PARAM;\n\n\tdevice_id = atoi(p + 1);\n\n\tsnprintf_s_iis(sysfs_port, SYSFS_PATH_MAX,\n\t\tSYSFS_FPGA_CLASS_PATH SYSFS_AFU_PATH_FMT\"/%s\",\n\t\tdevice_id, device_id,PORT_SYSFS_ERR);\n\n\t// Read port error.\n\tresult = sysfs_read_u64(sysfs_port, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to get fme errors\");\n\t\treturn result;\n\t}\n\n\tprintf(\"\\n \\n Port error CSR : 0x%lx \\n\", value);\n\n\tsize = sizeof(PORT_ERROR) /sizeof(PORT_ERROR[0]);\n\n\tfor (i = 0; i < 64; i++) {\n\t\tif ( FPGA_BIT_IS_SET(value, i) && (i < size)) {\n\t\t\tprintf(\"\\t %s \\n\", PORT_ERROR[i]);\n\t\t}\n\t}\n\n\tprintf(\"\\n ----------- PRINT PORT ERROR  END----------\\n\");\n\tprintf(\" ========================================== \\n \\n\");\n\n\treturn result;\n\n}\n\n// clear PORT errors\nfpga_result clear_port_errors(fpga_token token)\n{\n\tstruct _fpga_token  *_token       = 0;\n\tuint64_t value                    = 0;\n\tchar sysfs_port[SYSFS_PATH_MAX]   = {0};\n\tfpga_result result                = FPGA_OK;\n \tchar *p                           = 0;\n\tint device_id                     = 0;\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tprintf(\" ----------- Clear port error-------- \\n \\n\");\n\n\tp = strstr(_token->sysfspath, FPGA_SYSFS_FME);\n\tif (NULL == p)\n\t\treturn FPGA_INVALID_PARAM;\n\tp = strrchr(_token->sysfspath, '.');\n\tif (NULL == p)\n\t\treturn FPGA_INVALID_PARAM;\n\n\tdevice_id = atoi(p + 1);\n\n\tsnprintf_s_iis(sysfs_port, SYSFS_PATH_MAX,\n\t\tSYSFS_FPGA_CLASS_PATH SYSFS_AFU_PATH_FMT\"/%s\",\n\t\tdevice_id, device_id,PORT_SYSFS_ERR);\n\n\t// Read port error.\n\tresult = sysfs_read_u64(sysfs_port, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to get port errors\");\n\t\treturn result;\n\t}\n\n\tprintf(\"\\n \\n Port error CSR : 0x%lx \\n\", value);\n\n\tsnprintf_s_iis(sysfs_port, SYSFS_PATH_MAX,\n\t\tSYSFS_FPGA_CLASS_PATH SYSFS_AFU_PATH_FMT\"/%s\",\n\t\tdevice_id, device_id,PORT_SYSFS_ERR_CLEAR);\n\n\tresult = sysfs_write_u64(sysfs_port, value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to write errors\");\n\t}\n\n\treturn result;\n}\n\n// Inject RAS errors\nfpga_result inject_ras_errors(fpga_token token,\n\t\t\t\tstruct RASCommandLine *rasCmdLine)\n{\n\tstruct _fpga_token  *_token           = NULL;\n\tstruct ras_inject_error  inj_error    = {{0}};\n\tchar sysfs_path[SYSFS_PATH_MAX]       = {0};\n\tfpga_result result                    = FPGA_OK;\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tprintf(\"----------- INJECT ERROR START -------- \\n \\n\");\n\n\tsnprintf_s_ss(sysfs_path, sizeof(sysfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\tFME_SYSFS_INJECT_ERROR);\n\tresult = sysfs_read_u64(sysfs_path, &inj_error.csr);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to get fme errors\");\n\t\treturn result;\n\t}\n\n\tprintf(\"inj_error.csr: %ld \\n\", inj_error.csr);\n\n\tif (rasCmdLine->catast_error ) {\n\t\tinj_error.catastrophicr_error = 1;\n\t}\n\n\tif (rasCmdLine->fatal_error ) {\n\t\tinj_error.fatal_error = 1;\n\t}\n\n\tif (rasCmdLine->nonfatal_error ) {\n\t\tinj_error.nonfatal_error = 1;\n\t}\n\n\tprintf(\"inj_error.csr: %ld \\n\", inj_error.csr);\n\n\tresult = sysfs_write_u64(sysfs_path ,inj_error.csr);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed to write RAS inject errors\");\n\t\treturn result;\n\t}\n\n\tprintf(\"----------- INJECT ERROR  END-------- \\n \\n\");\n\treturn result;\n}\n\n// Clear Inject RAS errors\nfpga_result clear_inject_ras_errors(fpga_token token,\n\t\t\t\t\tstruct RASCommandLine *rasCmdLine)\n{\n\tstruct _fpga_token  *_token           = NULL;\n\tstruct ras_inject_error  inj_error    = {{0}};\n\tchar sysfs_path[SYSFS_PATH_MAX]       = {0};\n\tfpga_result result                    = FPGA_OK;\n\n\tUNUSED_PARAM(rasCmdLine);\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tsnprintf_s_ss(sysfs_path, sizeof(sysfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\tFME_SYSFS_INJECT_ERROR);\n\tresult = sysfs_read_u64(sysfs_path, &inj_error.csr);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed  to read inject error\");\n\t\treturn result;\n\t}\n\n\tprintf(\" Clear inj_error.csr: 0x%lx \\n\", inj_error.csr);\n\n\tresult = sysfs_write_u64(sysfs_path ,0x0);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed to clear inject errors\");\n\t\treturn result;\n\t}\n\treturn result;\n}\n\n// Print FPGA power and temperature\nfpga_result print_pwr_temp(fpga_token token)\n{\n\tstruct _fpga_token  *_token       = 0;\n\tuint64_t value                    = 0;\n\tchar sysfs_path[SYSFS_PATH_MAX]   = {0};\n\tfpga_result result                = FPGA_OK;\n\n\t_token = (struct _fpga_token*)token;\n\tif (_token == NULL) {\n\t\tFPGA_ERR(\"Token not found\");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tprintf(\"\\n ----------- POWER & THERMAL -------------\\n\");\n\tprintf(\" ========================================== \\n \\n\");\n\n\tsnprintf_s_ss(sysfs_path, sizeof(sysfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\tFME_SYSFS_POWER_MGMT_CONSUMED);\n\tresult = sysfs_read_u64(sysfs_path, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed to get power consumed\");\n\t\treturn result;\n\t}\n\tprintf(\" Power consumed       : %lu watts \\n\",value);\n\n\tsnprintf_s_ss(sysfs_path, sizeof(sysfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\tFME_SYSFS_THERMAL_MGMT_TEMP);\n\tresult = sysfs_read_u64(sysfs_path, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed to get temperature\");\n\t\treturn result;\n\t}\n\tprintf(\" Temperature          : %lu Centigrade \\n\",value );\n\n\tsnprintf_s_ss(sysfs_path, sizeof(sysfs_path), \"%s/%s\",\n\t\t\t_token->sysfspath,\n\t\t\tFME_SYSFS_THERMAL_MGMT_THRESHOLD_TRIP);\n\tresult = sysfs_read_u64(sysfs_path, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed to get temperature\");\n\t\treturn result;\n\t}\n\tprintf(\" Thermal Trip         : %lu Centigrade \\n\",value );\n\n\tprintf(\"\\n ----------- POWER & THERMAL -------------\\n\");\n\tprintf(\" ========================================== \\n \\n\");\n\n\treturn result;\n}\n\n// MMIO erros\nfpga_result mmio_error(struct RASCommandLine *rasCmdLine)\n{\n\tchar sysfs_path[SYSFS_PATH_MAX]   = {0};\n\tfpga_result result                = FPGA_OK;\n\tint bus                           = 0;\n\tint device                        = 0;\n\tint function                      = 0;\n\tuint64_t value                    = 0;\n\tint fd                            = 0;\n\tuint8_t *ptr                      = 0;\n\n\tif (rasCmdLine  == NULL ) {\n\t\tFPGA_ERR(\"Invalid input \");\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\tif ( rasCmdLine->bus >0 )\n\t\tbus = rasCmdLine->bus;\n\n\tif ( rasCmdLine->device >0 )\n\t\tdevice = rasCmdLine->bus;\n\n\tif ( rasCmdLine->function >0 )\n\t\tfunction = rasCmdLine->bus;\n\n\tsnprintf(sysfs_path, sizeof(sysfs_path),\n\t\t\tDEVICEID_PATH,0,bus,device,function);\n\n\tresult = sysfs_read_u64(sysfs_path, &value);\n\tif (result != FPGA_OK) {\n\t\tFPGA_ERR(\"Failed to read Device id\");\n\t\treturn result;\n\t}\n\n\tif(value != FPGA_INTEGRATED_DEVICEID) {\n\t\tFPGA_ERR(\"Failed  to read Device id\");\n\t\treturn FPGA_NOT_SUPPORTED;\n\t}\n\n\tsnprintf(sysfs_path, sizeof(sysfs_path),\n\t\t\tFPGA_PORT_RES_PATH,0,bus,device,function);\n\n\tfd = open(sysfs_path, O_RDWR);\n\tif (fd < 0) {\n\t\tFPGA_ERR(\"Failed to open FPGA PCIE BAR2\");\n\t\treturn FPGA_EXCEPTION;\n\t}\n\n\tptr =  mmap(NULL, PORT_MMIO_LEN,\n\t\t\tPROT_READ|PROT_WRITE,MAP_SHARED, fd, 0);\n\tif (ptr == MAP_FAILED ) {\n\t\tFPGA_ERR(\"Failed to map FPGA PCIE BAR2\");\n\t\tresult = FPGA_EXCEPTION;\n\t\tgoto out_close ;\n\t}\n\n\t// Memory Write length error\n\tif(rasCmdLine->mwlength_error) {\n\n\t\tFPGA_DBG(\"Memory Write length error \\n\");\n\t\t*((volatile uint64_t *) (ptr + PORT_SCRATCHPAD0+3))\n\t\t\t\t= (uint16_t)MMO_WRITE64_VALUE;\n\t}\n\n\t// Memory Read length error\n\tif(rasCmdLine->mrlength_error) {\n\n\t\tFPGA_DBG(\" Memory Read length error \\n\");\n\t\tvalue = *((volatile uint64_t *) (ptr + PORT_SCRATCHPAD0+3));\n\t\tFPGA_DBG(\" Memory Read length value %lx\\n\",value);\n\t}\n\n\t// Memory Read addresss error\n\tif(rasCmdLine->mraddress_error) {\n\n\t\tFPGA_DBG(\"Memory Read addresss error \\n\");\n\t\tvalue = *((volatile uint16_t *) (ptr + NLB_CSR_SCRATCHPAD +3));\n\t\tFPGA_DBG(\"Memory Read addresss value  %lx\\n\",value);\n\n\t\tvalue = *((volatile uint64_t *) (ptr + PORT_SCRATCHPAD0+3));\n\t\tFPGA_DBG(\"Memory Read addresss value  %lx\\n\",value);\n\t}\n\n\t// Memory Write addresss error\n\tif(rasCmdLine->mwaddress_error) {\n\n\t\tFPGA_DBG(\"Memory Write addresss error \\n\");\n\t\t*((volatile uint16_t *) (ptr + NLB_CSR_SCRATCHPAD +3))\n\t\t\t\t= (uint16_t)MMO_WRITE32_VALUE;\n\t}\n\n\tif(ptr)\n\t\tmunmap(ptr, PORT_MMIO_LEN);\nout_close:\n\tif(fd >=0)\n\t\tclose(fd);\n\n\treturn result;\n}\n// page fault errors\nfpga_result page_fault_errors()\n{\n\tfpga_properties    filter = NULL;\n\tfpga_token         accelerator_token;\n\tfpga_handle        accelerator_handle;\n\tfpga_guid          guid;\n\tuint32_t           num_matches;\n\n\tvolatile uint64_t *dsm_ptr    = NULL;\n\tvolatile uint64_t *input_ptr  = NULL;\n\tvolatile uint64_t *output_ptr = NULL;\n\n\tuint64_t        dsm_wsid;\n\tuint64_t        input_wsid;\n\tuint64_t        output_wsid;\n\tfpga_result     res = FPGA_OK;\n\n\n\tif (uuid_parse(SKX_P_NLB0_AFUID, guid) < 0) {\n\t\tfprintf(stderr, \"Error parsing guid '%s'\\n\", SKX_P_NLB0_AFUID);\n\t\tgoto out_exit;\n\t}\n\n\t/* Look for accelerator with MY_ACCELERATOR_ID */\n\tres = fpgaGetProperties(NULL, &filter);\n\tON_ERR_GOTO(res, out_exit, \"creating properties object\");\n\n\tres = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\n\tON_ERR_GOTO(res, out_destroy_prop, \"setting object type\");\n\n\tres = fpgaPropertiesSetGUID(filter, guid);\n\tON_ERR_GOTO(res, out_destroy_prop, \"setting GUID\");\n\n\tif (rasCmdLine.bus >0){\n\t\tres = fpgaPropertiesSetBus(filter, rasCmdLine.bus);\n\t\tON_ERR_GOTO(res, out_destroy_prop, \"setting bus\");\n\t}\n\n\tif (rasCmdLine.device >0) {\n\t\tres = fpgaPropertiesSetDevice(filter, rasCmdLine.device);\n\t\tON_ERR_GOTO(res, out_destroy_prop, \"setting device\");\n\t}\n\n\tif (rasCmdLine.function >0){\n\t\tres = fpgaPropertiesSetFunction(filter, rasCmdLine.function);\n\t\tON_ERR_GOTO(res, out_destroy_prop, \"setting function\");\n\t}\n\n\tres = fpgaEnumerate(&filter, 1, &accelerator_token, 1, &num_matches);\n\tON_ERR_GOTO(res, out_destroy_prop, \"enumerating accelerators\");\n\n\tif (num_matches < 1) {\n\t\tfprintf(stderr, \"accelerator not found.\\n\");\n\t\tres = fpgaDestroyProperties(&filter);\n\t\treturn FPGA_INVALID_PARAM;\n\t}\n\n\t/* Open accelerator and map MMIO */\n\tres = fpgaOpen(accelerator_token, &accelerator_handle, FPGA_OPEN_SHARED);\n\tON_ERR_GOTO(res, out_destroy_tok, \"opening accelerator\");\n\n\tres = fpgaMapMMIO(accelerator_handle, 0, NULL);\n\tON_ERR_GOTO(res, out_close, \"mapping MMIO space\");\n\n\t/* Allocate buffers */\n\tres = fpgaPrepareBuffer(accelerator_handle, LPBK1_DSM_SIZE,\n\t\t\t\t(void **)&dsm_ptr, &dsm_wsid, 0);\n\tON_ERR_GOTO(res, out_close, \"allocating DSM buffer\");\n\n\tres = fpgaPrepareBuffer(accelerator_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n\t\t\t   (void **)&input_ptr, &input_wsid, 0);\n\tON_ERR_GOTO(res, out_free_dsm, \"allocating input buffer\");\n\n\tres = fpgaPrepareBuffer(accelerator_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n\t\t\t   (void **)&output_ptr, &output_wsid, 0);\n\tON_ERR_GOTO(res, out_free_input, \"allocating output buffer\");\n\n\tprintf(\"Running Test\\n\");\n\n\t/* Initialize buffers */\n\tmemset((void *)dsm_ptr,    0,    LPBK1_DSM_SIZE);\n\tmemset((void *)input_ptr,  0xAF, LPBK1_BUFFER_SIZE);\n\tmemset((void *)output_ptr, 0xBE, LPBK1_BUFFER_SIZE);\n\n\tcache_line *cl_ptr = (cache_line *)input_ptr;\n\tfor (uint32_t i = 0; i < LPBK1_BUFFER_SIZE / CL(1); ++i) {\n\t\tcl_ptr[i].uint[15] = i+1; /* set the last uint in every cacheline */\n\t}\n\n\t/* Reset accelerator */\n\tres = fpgaReset(accelerator_handle);\n\tON_ERR_GOTO(res, out_free_output, \"resetting accelerator\");\n\n\t/* Program DMA addresses */\n\tuint64_t iova;\n\tres = fpgaGetIOAddress(accelerator_handle, dsm_wsid, &iova);\n\tON_ERR_GOTO(res, out_free_output, \"getting DSM IOVA\");\n\n\tres = fpgaWriteMMIO64(accelerator_handle, 0, CSR_AFU_DSM_BASEL, iova);\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_AFU_DSM_BASEL\");\n\n\tres = fpgaWriteMMIO32(accelerator_handle, 0, CSR_CTL, 0);\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n\tres = fpgaWriteMMIO32(accelerator_handle, 0, CSR_CTL, 1);\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n\n\tres = fpgaGetIOAddress(accelerator_handle, input_wsid, &iova);\n\tON_ERR_GOTO(res, out_free_output, \"getting input IOVA\");\n\n\t// Free Input buffer\n\tres = fpgaReleaseBuffer(accelerator_handle, input_wsid);\n\tres = fpgaWriteMMIO64(accelerator_handle, 0, CSR_SRC_ADDR, CACHELINE_ALIGNED_ADDR(iova));\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_SRC_ADDR\");\n\n\tres = fpgaGetIOAddress(accelerator_handle, output_wsid, &iova);\n\tON_ERR_GOTO(res, out_free_output, \"getting output IOVA\");\n\tres = fpgaWriteMMIO64(accelerator_handle, 0, CSR_DST_ADDR, CACHELINE_ALIGNED_ADDR(iova));\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_DST_ADDR\");\n\n\n\tres = fpgaWriteMMIO32(accelerator_handle, 0, CSR_NUM_LINES, LPBK1_BUFFER_SIZE / CL(1));\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_NUM_LINES\");\n\tres = fpgaWriteMMIO32(accelerator_handle, 0, CSR_CFG, 0x42000);\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n\n\t/* Start the test */\n\tres = fpgaWriteMMIO32(accelerator_handle, 0, CSR_CTL, 3);\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n\n\t/* Wait for test completion */\n\tusleep(10000);\n\n\n\t/* Stop the device */\n\tres = fpgaWriteMMIO32(accelerator_handle, 0, CSR_CTL, 7);\n\tON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n\n\tprintf(\"Done Running Test\\n\");\n\n\t/* Release buffers */\nout_free_output:\n\tres = fpgaReleaseBuffer(accelerator_handle, output_wsid);\n\tON_ERR_GOTO(res, out_free_input, \"releasing output buffer\");\nout_free_input:\n//\tres = fpgaReleaseBuffer(accelerator_handle, input_wsid);\n//\tON_ERR_GOTO(res, out_free_dsm, \"releasing input buffer\");\nout_free_dsm:\n\tres = fpgaReleaseBuffer(accelerator_handle, dsm_wsid);\n\tON_ERR_GOTO(res, out_unmap, \"releasing DSM buffer\");\n\n\t/* Unmap MMIO space */\nout_unmap:\n\tres = fpgaUnmapMMIO(accelerator_handle, 0);\n\tON_ERR_GOTO(res, out_close, \"unmapping MMIO space\");\n\n\t/* Release accelerator */\nout_close:\n\tres = fpgaClose(accelerator_handle);\n\tON_ERR_GOTO(res, out_destroy_tok, \"closing accelerator\");\n\n\t/* Destroy token */\nout_destroy_tok:\n\tres = fpgaDestroyToken(&accelerator_token);\n\tON_ERR_GOTO(res, out_destroy_prop, \"destroying token\");\n\n\t/* Destroy properties object */\nout_destroy_prop:\n\tres = fpgaDestroyProperties(&filter);\n\tON_ERR_GOTO(res, out_exit, \"destroying properties object\");\n\nout_exit:\n\treturn res;\n\n}\n// parse Input command line\nint ParseCmds(struct RASCommandLine *rasCmdLine, int argc, char *argv[])\n{\n\tint getopt_ret     = 0;\n\tint option_index   = 0;\n\tchar *endptr       = NULL;\n\n\twhile( -1 != ( getopt_ret = getopt_long(argc, argv,\n\t\t\t\t\t\tGETOPT_STRING,\n\t\t\t\t\t\tlongopts,\n\t\t\t\t\t\t&option_index))){\n\t\tconst char *tmp_optarg = optarg;\n\n\t\tif ((optarg) &&\n\t\t\t\t('=' == *tmp_optarg)){\n\t\t\t++tmp_optarg;\n\t\t}\n\n\t\tswitch(getopt_ret){\n\t\tcase 'h':\n\t\t\t// Command line help\n\t\t\tRASAppShowHelp();\n\t\t\treturn -2;\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\t// bus number\n\t\t\tif (tmp_optarg == NULL ) break;\n\t\t\tendptr = NULL;\n\t\t\trasCmdLine->bus = strtol(tmp_optarg, &endptr, 0);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\t// Device number\n\t\t\tif (tmp_optarg == NULL ) break;\n\t\t\tendptr = NULL;\n\t\t\trasCmdLine->device = strtol(tmp_optarg, &endptr, 0);\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\t// Function number\n\t\t\tif (tmp_optarg == NULL ) break;\n\t\t\tendptr = NULL;\n\t\t\trasCmdLine->function = strtol(tmp_optarg, &endptr, 0);\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t// Socket number\n\t\t\tif (tmp_optarg == NULL ) break;\n\t\t\tendptr = NULL;\n\t\t\trasCmdLine->socket = strtol(tmp_optarg, &endptr, 0);\n\t\t\tbreak;\n\n\t\tcase 'P':\n\t\t\t// Print Errors\n\t\t\trasCmdLine->print_error = true;\n\t\t\tbreak;\n\n\t\tcase 'Q':\n\t\t\t// Set Cast error\n\t\t\trasCmdLine->catast_error = true;\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\t// Set Fatal error\n\t\t\trasCmdLine->fatal_error = true;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\t// Set page fault error\n\t\t\trasCmdLine->pagefault_error = true;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\t// Set Non Fatal error\n\t\t\trasCmdLine->nonfatal_error = true;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\t// Clear Injected Error\n\t\t\trasCmdLine->clear_injerror = true;\n\t\t\tbreak;\n\n\t\tcase 'E':\n\t\t\t// Set MW Address error\n\t\t\trasCmdLine->mwaddress_error = true;\n\t\t\tbreak;\n\n\t\tcase 'G':\n\t\t\t// Set MR Address error\n\t\t\trasCmdLine->mraddress_error = true;\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\t// Set MW Length error\n\t\t\trasCmdLine->mwlength_error = true;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\t// Set MR Length error\n\t\t\trasCmdLine->mrlength_error = true;\n\t\t\tbreak;\n\n\t\tcase ':': /* missing option argument */\n\t\t\tprintf(\"Missing option argument.\\n\");\n\t\t\treturn -1;\n\n\t\tcase '?':\n\t\tdefault: /* invalid option */\n\t\t\tprintf(\"Invalid cmdline options.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "idx": 1, "id": 14917, "msg": "Can you explain why is this necessary? Is `snprintf()` with four integer arguments unsafe?", "proj": "OPAE-opae-sdk", "lang": "c"}
{"patch": "@@ -219,7 +219,19 @@ def internal_keyDownEvent(vkCode,scanCode,extended,injected):\n \t\t\tfor k in range(256):\n \t\t\t\tkeyStates[k]=ctypes.windll.user32.GetKeyState(k)\n \t\t\tcharBuf=ctypes.create_unicode_buffer(5)\n+\t\t\t# First try getting the keyboard layout from the thread with the focus (input thread)\n \t\t\thkl=ctypes.windll.user32.GetKeyboardLayout(focus.windowThreadID)\n+\t\t\tif not hkl:\n+\t\t\t\tlog.debug(\"Failed to fetch keyboard layout from focus, trying layout from last detected change\")\n+\t\t\t\t# Some threads, such as for Windows consoles\n+\t\t\t\t# Do not allow getKeyboardLayout to work.\n+\t\t\t\t# Therefore, use the cached keyboard layout from the last inputLangChange detected by NVDA\n+\t\t\t\t# on the foreground object.\n+\t\t\t\thkl = getattr(api.getForegroundObject(), '_lastDetectedKeyboardLayoutChange', 0)\n+\t\t\t\tif not hkl:\n+\t\t\t\t\tlog.debug(\"No layout cached, falling back to layout of NVDA main thread\")\n+\t\t\t\t\t# As a last resort, use the keyboard layout of NVDA's main thread.\n+\t\t\t\t\thkl = ctypes.windll.user32.GetKeyboardLayout(core.mainThreadId)\n \t\t\t# In previous Windows builds, calling ToUnicodeEx would destroy keyboard buffer state and therefore cause the app to not produce the right WM_CHAR message.\n \t\t\t# However, ToUnicodeEx now can take a new flag of 0x4, which stops it from destroying keyboard state, thus allowing us to safely call it here.\n \t\t\tres=ctypes.windll.user32.ToUnicodeEx(vkCode,scanCode,keyStates,charBuf,len(charBuf),0x4,hkl)", "y": 1, "oldf": "# -*- coding: UTF-8 -*-\r\n#keyboardHandler.py\r\n#A part of NonVisual Desktop Access (NVDA)\r\n#This file is covered by the GNU General Public License.\r\n#See the file COPYING for more details.\r\n#Copyright (C) 2006-2017 NV Access Limited, Peter V\u00e1gner, Aleksey Sadovoy, Babbage B.V.\r\n\r\n\"\"\"Keyboard support\"\"\"\r\n\r\nimport ctypes\r\nimport sys\r\nimport time\r\nimport re\r\nimport wx\r\nimport winVersion\r\nimport winUser\r\nimport vkCodes\r\nimport eventHandler\r\nimport speech\r\nimport ui\r\nfrom keyLabels import localizedKeyLabels\r\nfrom logHandler import log\r\nimport queueHandler\r\nimport config\r\nimport api\r\nimport winInputHook\r\nimport inputCore\r\nimport tones\r\nimport core\r\nfrom contextlib import contextmanager\r\nimport threading\r\n\r\nignoreInjected=False\r\n\r\n# Fake vk codes.\r\n# These constants should be assigned to the name that NVDA will use for the key.\r\nVK_WIN = \"windows\"\r\nVK_NVDA = \"NVDA\"\r\n\r\n#: Keys which have been trapped by NVDA and should not be passed to the OS.\r\ntrappedKeys=set()\r\n#: Tracks the number of keys passed through by request of the user.\r\n#: If -1, pass through is disabled.\r\n#: If 0 or higher then key downs and key ups will be passed straight through.\r\npassKeyThroughCount=-1\r\n#: The last key down passed through by request of the user.\r\nlastPassThroughKeyDown = None\r\n#: The last NVDA modifier key that was pressed with no subsequent key presses.\r\nlastNVDAModifier = None\r\n#: When the last NVDA modifier key was released.\r\nlastNVDAModifierReleaseTime = None\r\n#: Indicates that the NVDA modifier's special functionality should be bypassed until a key is next released.\r\nbypassNVDAModifier = False\r\n#: The modifiers currently being pressed.\r\ncurrentModifiers = set()\r\n#: A counter which is incremented each time a key is pressed.\r\n#: Note that this may be removed in future, so reliance on it should generally be avoided.\r\n#: @type: int\r\nkeyCounter = 0\r\n#: The current sticky NVDa modifier key.\r\nstickyNVDAModifier = None\r\n#: Whether the sticky NVDA modifier is locked.\r\nstickyNVDAModifierLocked = False\r\n\r\n_ignoreInjectionLock = threading.Lock()\r\n@contextmanager\r\ndef ignoreInjection():\r\n\t\"\"\"Context manager that allows ignoring injected keys temporarily by using a with statement.\"\"\"\r\n\tglobal ignoreInjected\r\n\twith _ignoreInjectionLock:\r\n\t\tignoreInjected=True\r\n\t\tyield\r\n\t\tignoreInjected=False\r\n\r\ndef passNextKeyThrough():\r\n\tglobal passKeyThroughCount\r\n\tif passKeyThroughCount==-1:\r\n\t\tpassKeyThroughCount=0\r\n\r\ndef isNVDAModifierKey(vkCode,extended):\r\n\tif config.conf[\"keyboard\"][\"useNumpadInsertAsNVDAModifierKey\"] and vkCode==winUser.VK_INSERT and not extended:\r\n\t\treturn True\r\n\telif config.conf[\"keyboard\"][\"useExtendedInsertAsNVDAModifierKey\"] and vkCode==winUser.VK_INSERT and extended:\r\n\t\treturn True\r\n\telif config.conf[\"keyboard\"][\"useCapsLockAsNVDAModifierKey\"] and vkCode==winUser.VK_CAPITAL:\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False\r\n\r\nSUPPORTED_NVDA_MODIFIER_KEYS = (\"capslock\", \"numpadinsert\", \"insert\")\r\n\r\ndef getNVDAModifierKeys():\r\n\tkeys=[]\r\n\tif config.conf[\"keyboard\"][\"useExtendedInsertAsNVDAModifierKey\"]:\r\n\t\tkeys.append(vkCodes.byName[\"insert\"])\r\n\tif config.conf[\"keyboard\"][\"useNumpadInsertAsNVDAModifierKey\"]:\r\n\t\tkeys.append(vkCodes.byName[\"numpadinsert\"])\r\n\tif config.conf[\"keyboard\"][\"useCapsLockAsNVDAModifierKey\"]:\r\n\t\tkeys.append(vkCodes.byName[\"capslock\"])\r\n\treturn keys\r\n\r\ndef internal_keyDownEvent(vkCode,scanCode,extended,injected):\r\n\t\"\"\"Event called by winInputHook when it receives a keyDown.\r\n\t\"\"\"\r\n\tgestureExecuted=False\r\n\ttry:\r\n\t\tglobal lastNVDAModifier, lastNVDAModifierReleaseTime, bypassNVDAModifier, passKeyThroughCount, lastPassThroughKeyDown, currentModifiers, keyCounter, stickyNVDAModifier, stickyNVDAModifierLocked\r\n\t\t# Injected keys should be ignored in some cases.\r\n\t\tif injected and (ignoreInjected or not config.conf['keyboard']['handleInjectedKeys']):\r\n\t\t\treturn True\r\n\r\n\t\tkeyCode = (vkCode, extended)\r\n\r\n\t\tif passKeyThroughCount >= 0:\r\n\t\t\t# We're passing keys through.\r\n\t\t\tif lastPassThroughKeyDown != keyCode:\r\n\t\t\t\t# Increment the pass key through count.\r\n\t\t\t\t# We only do this if this isn't a repeat of the previous key down, as we don't receive key ups for repeated key downs.\r\n\t\t\t\tpassKeyThroughCount += 1\r\n\t\t\t\tlastPassThroughKeyDown = keyCode\r\n\t\t\treturn True\r\n\r\n\t\tkeyCounter += 1\r\n\t\tstickyKeysFlags = winUser.getSystemStickyKeys().dwFlags\r\n\t\tif stickyNVDAModifier and not stickyKeysFlags & winUser.SKF_STICKYKEYSON:\r\n\t\t\t# Sticky keys has been disabled,\r\n\t\t\t# so clear the sticky NVDA modifier.\r\n\t\t\tcurrentModifiers.discard(stickyNVDAModifier)\r\n\t\t\tstickyNVDAModifier = None\r\n\t\t\tstickyNVDAModifierLocked = False\r\n\t\tgesture = KeyboardInputGesture(currentModifiers, vkCode, scanCode, extended)\r\n\t\tif not (stickyKeysFlags & winUser.SKF_STICKYKEYSON) and (bypassNVDAModifier or (keyCode == lastNVDAModifier and lastNVDAModifierReleaseTime and time.time() - lastNVDAModifierReleaseTime < 0.5)):\r\n\t\t\t# The user wants the key to serve its normal function instead of acting as an NVDA modifier key.\r\n\t\t\t# There may be key repeats, so ensure we do this until they stop.\r\n\t\t\tbypassNVDAModifier = True\r\n\t\t\tgesture.isNVDAModifierKey = False\r\n\t\tlastNVDAModifierReleaseTime = None\r\n\t\tif gesture.isNVDAModifierKey:\r\n\t\t\tlastNVDAModifier = keyCode\r\n\t\t\tif stickyKeysFlags & winUser.SKF_STICKYKEYSON:\r\n\t\t\t\tif keyCode == stickyNVDAModifier:\r\n\t\t\t\t\tif stickyKeysFlags & winUser.SKF_TRISTATE and not stickyNVDAModifierLocked:\r\n\t\t\t\t\t\t# The NVDA modifier is being locked.\r\n\t\t\t\t\t\tstickyNVDAModifierLocked = True\r\n\t\t\t\t\t\tif stickyKeysFlags & winUser.SKF_AUDIBLEFEEDBACK:\r\n\t\t\t\t\t\t\ttones.beep(1984, 60)\r\n\t\t\t\t\t\treturn False\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\t# The NVDA modifier is being unlatched/unlocked.\r\n\t\t\t\t\t\tstickyNVDAModifier = None\r\n\t\t\t\t\t\tstickyNVDAModifierLocked = False\r\n\t\t\t\t\t\tif stickyKeysFlags & winUser.SKF_AUDIBLEFEEDBACK:\r\n\t\t\t\t\t\t\ttones.beep(496, 60)\r\n\t\t\t\t\t\treturn False\r\n\t\t\t\telse:\r\n\t\t\t\t\t# The NVDA modifier is being latched.\r\n\t\t\t\t\tif stickyNVDAModifier:\r\n\t\t\t\t\t\t# Clear the previous sticky NVDA modifier.\r\n\t\t\t\t\t\tcurrentModifiers.discard(stickyNVDAModifier)\r\n\t\t\t\t\t\tstickyNVDAModifierLocked = False\r\n\t\t\t\t\tstickyNVDAModifier = keyCode\r\n\t\t\t\t\tif stickyKeysFlags & winUser.SKF_AUDIBLEFEEDBACK:\r\n\t\t\t\t\t\ttones.beep(1984, 60)\r\n\t\telse:\r\n\t\t\t# Another key was pressed after the last NVDA modifier key, so it should not be passed through on the next press.\r\n\t\t\tlastNVDAModifier = None\r\n\t\tif gesture.isModifier:\r\n\t\t\tif gesture.speechEffectWhenExecuted in (gesture.SPEECHEFFECT_PAUSE, gesture.SPEECHEFFECT_RESUME) and keyCode in currentModifiers:\r\n\t\t\t\t# Ignore key repeats for the pause speech key to avoid speech stuttering as it continually pauses and resumes.\r\n\t\t\t\treturn True\r\n\t\t\tcurrentModifiers.add(keyCode)\r\n\t\telif stickyNVDAModifier and not stickyNVDAModifierLocked:\r\n\t\t\t# A non-modifier was pressed, so unlatch the NVDA modifier.\r\n\t\t\tcurrentModifiers.discard(stickyNVDAModifier)\r\n\t\t\tstickyNVDAModifier = None\r\n\r\n\t\ttry:\r\n\t\t\tinputCore.manager.executeGesture(gesture)\r\n\t\t\tgestureExecuted=True\r\n\t\t\ttrappedKeys.add(keyCode)\r\n\t\t\tif canModifiersPerformAction(gesture.generalizedModifiers):\r\n\t\t\t\t# #3472: These modifiers can perform an action if pressed alone\r\n\t\t\t\t# and we've just consumed the main key.\r\n\t\t\t\t# Send special reserved vkcode (0xff) to at least notify the app's key state that something happendd.\r\n\t\t\t\t# This allows alt and windows to be bound to scripts and\r\n\t\t\t\t# stops control+shift from switching keyboard layouts in cursorManager selection scripts.\r\n\t\t\t\tKeyboardInputGesture((),0xff,0,False).send()\r\n\t\t\treturn False\r\n\t\texcept inputCore.NoInputGestureAction:\r\n\t\t\tif gesture.isNVDAModifierKey:\r\n\t\t\t\t# Never pass the NVDA modifier key to the OS.\r\n\t\t\t\ttrappedKeys.add(keyCode)\r\n\t\t\t\treturn False\r\n\texcept:\r\n\t\tlog.error(\"internal_keyDownEvent\", exc_info=True)\r\n\tfinally:\r\n\t\t# #6017: handle typed characters in Win10 RS2 and above where we can't detect typed characters in-process \r\n\t\t# This code must be in the 'finally' block as code above returns in several places yet we still want to execute this particular code.\r\n\t\tfocus=api.getFocusObject()\r\n\t\tfrom NVDAObjects.behaviors import KeyboardHandlerBasedTypedCharSupport\r\n\t\tif (\r\n\t\t\t# This is only possible in Windows 10 1607 and above\r\n\t\t\twinVersion.isWin10(1607)\r\n\t\t\t# And we only want to do this if the gesture did not result in an executed action \r\n\t\t\tand not gestureExecuted \r\n\t\t\t# and not if this gesture is a modifier key\r\n\t\t\tand not isNVDAModifierKey(vkCode,extended) and not vkCode in KeyboardInputGesture.NORMAL_MODIFIER_KEYS\r\n\t\t\tand ( # Either of\r\n\t\t\t\t# We couldn't inject in-process, and its not a legacy console window without keyboard support.\r\n\t\t\t\t# console windows have their own specific typed character support.\r\n\t\t\t\t(not focus.appModule.helperLocalBindingHandle and focus.windowClassName!='ConsoleWindowClass')\r\n\t\t\t\t# or the focus is within a UWP app, where WM_CHAR never gets sent \r\n\t\t\t\tor focus.windowClassName.startswith('Windows.UI.Core')\r\n\t\t\t\t#Or this is a console with keyboard support, where WM_CHAR messages are doubled\r\n\t\t\t\tor isinstance(focus, KeyboardHandlerBasedTypedCharSupport)\r\n\t\t\t)\r\n\t\t):\r\n\t\t\tkeyStates=(ctypes.c_byte*256)()\r\n\t\t\tfor k in range(256):\r\n\t\t\t\tkeyStates[k]=ctypes.windll.user32.GetKeyState(k)\r\n\t\t\tcharBuf=ctypes.create_unicode_buffer(5)\r\n\t\t\thkl=ctypes.windll.user32.GetKeyboardLayout(focus.windowThreadID)\r\n\t\t\t# In previous Windows builds, calling ToUnicodeEx would destroy keyboard buffer state and therefore cause the app to not produce the right WM_CHAR message.\r\n\t\t\t# However, ToUnicodeEx now can take a new flag of 0x4, which stops it from destroying keyboard state, thus allowing us to safely call it here.\r\n\t\t\tres=ctypes.windll.user32.ToUnicodeEx(vkCode,scanCode,keyStates,charBuf,len(charBuf),0x4,hkl)\r\n\t\t\tif res>0:\r\n\t\t\t\tfor ch in charBuf[:res]: \r\n\t\t\t\t\teventHandler.queueEvent(\"typedCharacter\",focus,ch=ch)\r\n\treturn True\r\n\r\ndef internal_keyUpEvent(vkCode,scanCode,extended,injected):\r\n\t\"\"\"Event called by winInputHook when it receives a keyUp.\r\n\t\"\"\"\r\n\ttry:\r\n\t\tglobal lastNVDAModifier, lastNVDAModifierReleaseTime, bypassNVDAModifier, passKeyThroughCount, lastPassThroughKeyDown, currentModifiers\r\n\t\t# Injected keys should be ignored in some cases.\r\n\t\tif injected and (ignoreInjected or not config.conf['keyboard']['handleInjectedKeys']):\r\n\t\t\treturn True\r\n\r\n\t\tkeyCode = (vkCode, extended)\r\n\r\n\t\tif passKeyThroughCount >= 1:\r\n\t\t\tif lastPassThroughKeyDown == keyCode:\r\n\t\t\t\t# This key has been released.\r\n\t\t\t\tlastPassThroughKeyDown = None\r\n\t\t\tpassKeyThroughCount -= 1\r\n\t\t\tif passKeyThroughCount == 0:\r\n\t\t\t\tpassKeyThroughCount = -1\r\n\t\t\treturn True\r\n\r\n\t\tif lastNVDAModifier and keyCode == lastNVDAModifier:\r\n\t\t\t# The last pressed NVDA modifier key is being released and there were no key presses in between.\r\n\t\t\t# The user may want to press it again quickly to pass it through.\r\n\t\t\tlastNVDAModifierReleaseTime = time.time()\r\n\t\t# If we were bypassing the NVDA modifier, stop doing so now, as there will be no more repeats.\r\n\t\tbypassNVDAModifier = False\r\n\r\n\t\tif keyCode != stickyNVDAModifier:\r\n\t\t\tcurrentModifiers.discard(keyCode)\r\n\r\n\t\t# help inputCore  manage its sayAll state for keyboard modifiers -- inputCore itself has no concept of key releases\r\n\t\tif not currentModifiers:\r\n\t\t\tinputCore.manager.lastModifierWasInSayAll=False\r\n\r\n\r\n\t\tif keyCode in trappedKeys:\r\n\t\t\ttrappedKeys.remove(keyCode)\r\n\t\t\treturn False\r\n\texcept:\r\n\t\tlog.error(\"\", exc_info=True)\r\n\treturn True\r\n\r\n#Register internal key press event with  operating system\r\n\r\ndef initialize():\r\n\t\"\"\"Initialises keyboard support.\"\"\"\r\n\twinInputHook.initialize()\r\n\twinInputHook.setCallbacks(keyDown=internal_keyDownEvent,keyUp=internal_keyUpEvent)\r\n\r\ndef terminate():\r\n\twinInputHook.terminate()\r\n\r\ndef getInputHkl():\r\n\t\"\"\"Obtain the hkl currently being used for input.\r\n\tThis retrieves the hkl from the thread of the focused window.\r\n\t\"\"\"\r\n\tfocus = api.getFocusObject()\r\n\tif focus:\r\n\t\tthread = focus.windowThreadID\r\n\telse:\r\n\t\tthread = 0\r\n\treturn winUser.user32.GetKeyboardLayout(thread)\r\n\r\ndef canModifiersPerformAction(modifiers):\r\n\t\"\"\"Determine whether given generalized modifiers can perform an action if pressed alone.\r\n\tFor example, alt activates the menu bar if it isn't modifying another key.\r\n\t\"\"\"\r\n\tif inputCore.manager.isInputHelpActive:\r\n\t\treturn False\r\n\tcontrol = shift = other = False\r\n\tfor vk, ext in modifiers:\r\n\t\tif vk in (winUser.VK_MENU, VK_WIN):\r\n\t\t\t# Alt activates the menu bar.\r\n\t\t\t# Windows activates the Start Menu.\r\n\t\t\treturn True\r\n\t\telif vk == winUser.VK_CONTROL:\r\n\t\t\tcontrol = True\r\n\t\telif vk == winUser.VK_SHIFT:\r\n\t\t\tshift = True\r\n\t\telif (vk, ext) not in trappedKeys :\r\n\t\t\t# Trapped modifiers aren't relevant.\r\n\t\t\tother = True\r\n\tif control and shift and not other:\r\n\t\t# Shift+control switches keyboard layouts.\r\n\t\treturn True\r\n\treturn False\r\n\r\nclass KeyboardInputGesture(inputCore.InputGesture):\r\n\t\"\"\"A key pressed on the traditional system keyboard.\r\n\t\"\"\"\r\n\r\n\t#: All normal modifier keys, where modifier vk codes are mapped to a more general modifier vk code or C{None} if not applicable.\r\n\t#: @type: dict\r\n\tNORMAL_MODIFIER_KEYS = {\r\n\t\twinUser.VK_LCONTROL: winUser.VK_CONTROL,\r\n\t\twinUser.VK_RCONTROL: winUser.VK_CONTROL,\r\n\t\twinUser.VK_CONTROL: None,\r\n\t\twinUser.VK_LSHIFT: winUser.VK_SHIFT,\r\n\t\twinUser.VK_RSHIFT: winUser.VK_SHIFT,\r\n\t\twinUser.VK_SHIFT: None,\r\n\t\twinUser.VK_LMENU: winUser.VK_MENU,\r\n\t\twinUser.VK_RMENU: winUser.VK_MENU,\r\n\t\twinUser.VK_MENU: None,\r\n\t\twinUser.VK_LWIN: VK_WIN,\r\n\t\twinUser.VK_RWIN: VK_WIN,\r\n\t\tVK_WIN: None,\r\n\t}\r\n\r\n\t#: All possible toggle key vk codes.\r\n\t#: @type: frozenset\r\n\tTOGGLE_KEYS = frozenset((winUser.VK_CAPITAL, winUser.VK_NUMLOCK, winUser.VK_SCROLL))\r\n\r\n\t#: All possible keyboard layouts, where layout names are mapped to localised layout names.\r\n\t#: @type: dict\r\n\tLAYOUTS = {\r\n\t\t# Translators: One of the keyboard layouts for NVDA.\r\n\t\t\"desktop\": _(\"desktop\"),\r\n\t\t# Translators: One of the keyboard layouts for NVDA.\r\n\t\t\"laptop\": _(\"laptop\"),\r\n\t}\r\n\r\n\t@classmethod\r\n\tdef getVkName(cls, vkCode, isExtended):\r\n\t\tif isinstance(vkCode, str):\r\n\t\t\treturn vkCode\r\n\t\tname = vkCodes.byCode.get((vkCode, isExtended))\r\n\t\tif not name and isExtended is not None:\r\n\t\t\t# Whether the key is extended doesn't matter for many keys, so try None.\r\n\t\t\tname = vkCodes.byCode.get((vkCode, None))\r\n\t\treturn name if name else \"\"\r\n\r\n\tdef __init__(self, modifiers, vkCode, scanCode, isExtended):\r\n\t\t#: The keyboard layout in which this gesture was created.\r\n\t\t#: @type: str\r\n\t\tself.layout = config.conf[\"keyboard\"][\"keyboardLayout\"]\r\n\t\tself.modifiers = modifiers = set(modifiers)\r\n\t\t# Don't double up if this is a modifier key repeat.\r\n\t\tmodifiers.discard((vkCode, isExtended))\r\n\t\tif vkCode in (winUser.VK_DIVIDE, winUser.VK_MULTIPLY, winUser.VK_SUBTRACT, winUser.VK_ADD) and winUser.getKeyState(winUser.VK_NUMLOCK) & 1:\r\n\t\t\t# Some numpad keys have the same vkCode regardless of numlock.\r\n\t\t\t# For these keys, treat numlock as a modifier.\r\n\t\t\tmodifiers.add((winUser.VK_NUMLOCK, False))\r\n\t\tself.generalizedModifiers = set((self.NORMAL_MODIFIER_KEYS.get(mod) or mod, extended) for mod, extended in modifiers)\r\n\t\tself.vkCode = vkCode\r\n\t\tself.scanCode = scanCode\r\n\t\tself.isExtended = isExtended\r\n\t\tsuper(KeyboardInputGesture, self).__init__()\r\n\r\n\tdef _get_bypassInputHelp(self):\r\n\t\t# #4226: Numlock must always be handled normally otherwise the Keyboard controller and Windows can get out of synk wih each other in regard to this key state.\r\n\t\treturn self.vkCode==winUser.VK_NUMLOCK\r\n\r\n\tdef _get_isNVDAModifierKey(self):\r\n\t\treturn isNVDAModifierKey(self.vkCode, self.isExtended)\r\n\r\n\tdef _get_isModifier(self):\r\n\t\treturn self.vkCode in self.NORMAL_MODIFIER_KEYS or self.isNVDAModifierKey\r\n\r\n\tdef _get_mainKeyName(self):\r\n\t\tif self.isNVDAModifierKey:\r\n\t\t\treturn \"NVDA\"\r\n\r\n\t\tname = self.getVkName(self.vkCode, self.isExtended)\r\n\t\tif name:\r\n\t\t\treturn name\r\n\r\n\t\tif 32 < self.vkCode < 128:\r\n\t\t\treturn chr(self.vkCode).lower()\r\n\t\tif self.vkCode == vkCodes.VK_PACKET:\r\n\t\t\t# Unicode character from non-keyboard input.\r\n\t\t\treturn chr(self.scanCode)\r\n\t\tvkChar = winUser.user32.MapVirtualKeyExW(self.vkCode, winUser.MAPVK_VK_TO_CHAR, getInputHkl())\r\n\t\tif vkChar>0:\r\n\t\t\tif vkChar == 43: # \"+\"\r\n\t\t\t\t# A gesture identifier can't include \"+\" except as a separator.\r\n\t\t\t\treturn \"plus\"\r\n\t\t\treturn chr(vkChar).lower()\r\n\r\n\t\tif self.vkCode == 0xFF:\r\n\t\t\t# #3468: This key is unknown to Windows.\r\n\t\t\t# GetKeyNameText often returns something inappropriate in these cases\r\n\t\t\t# due to disregarding the extended flag.\r\n\t\t\treturn \"unknown_%02x\" % self.scanCode\r\n\t\treturn winUser.getKeyNameText(self.scanCode, self.isExtended)\r\n\r\n\tdef _get_modifierNames(self):\r\n\t\tmodTexts = []\r\n\t\tfor modVk, modExt in self.generalizedModifiers:\r\n\t\t\tif isNVDAModifierKey(modVk, modExt):\r\n\t\t\t\tmodTexts.append(\"NVDA\")\r\n\t\t\telse:\r\n\t\t\t\tmodTexts.append(self.getVkName(modVk, None))\r\n\t\treturn modTexts\r\n\r\n\tdef _get__keyNamesInDisplayOrder(self):\r\n\t\treturn tuple(self.modifierNames) + (self.mainKeyName,)\r\n\r\n\tdef _get_displayName(self):\r\n\t\treturn \"+\".join(\r\n\t\t\t# Translators: Reported for an unknown key press.\r\n\t\t\t# %s will be replaced with the key code.\r\n\t\t\t_(\"unknown %s\") % key[8:] if key.startswith(\"unknown_\")\r\n\t\t\telse localizedKeyLabels.get(key.lower(), key) for key in self._keyNamesInDisplayOrder)\r\n\r\n\tdef _get_identifiers(self):\r\n\t\tkeyName = \"+\".join(self._keyNamesInDisplayOrder)\r\n\t\treturn (\r\n\t\t\tu\"kb({layout}):{key}\".format(layout=self.layout, key=keyName),\r\n\t\t\tu\"kb:{key}\".format(key=keyName)\r\n\t\t)\r\n\r\n\tdef _get_shouldReportAsCommand(self):\r\n\t\tif self.isExtended and winUser.VK_VOLUME_MUTE <= self.vkCode <= winUser.VK_VOLUME_UP:\r\n\t\t\t# Don't report volume controlling keys.\r\n\t\t\treturn False\r\n\t\tif self.vkCode == 0xFF:\r\n\t\t\t# #3468: This key is unknown to Windows.\r\n\t\t\t# This could be for an event such as gyroscope movement,\r\n\t\t\t# so don't report it.\r\n\t\t\treturn False\r\n\t\tif self.vkCode in self.TOGGLE_KEYS:\r\n\t\t\t# #5490: Dont report for keys that toggle on off.\r\n\t\t\t# This is to avoid them from being reported twice: once by the 'speak command keys' feature,\r\n\t\t\t# and once to announce that the state has changed.\r\n\t\t\treturn False\r\n\t\treturn not self.isCharacter\r\n\r\n\tdef _get_isCharacter(self):\r\n\t\t# Aside from space, a key name of more than 1 character is a potential command and therefore is not a character.\r\n\t\tif self.vkCode != winUser.VK_SPACE and len(self.mainKeyName) > 1:\r\n\t\t\treturn False\r\n\t\t# If this key has modifiers other than shift, it is a command and not a character; e.g. shift+f is a character, but control+f is a command.\r\n\t\tmodifiers = self.generalizedModifiers\r\n\t\tif modifiers and (len(modifiers) > 1 or tuple(modifiers)[0][0] != winUser.VK_SHIFT):\r\n\t\t\treturn False\r\n\t\treturn True\r\n\r\n\tdef _get_speechEffectWhenExecuted(self):\r\n\t\tif inputCore.manager.isInputHelpActive:\r\n\t\t\treturn self.SPEECHEFFECT_CANCEL\r\n\t\tif self.isExtended and winUser.VK_VOLUME_MUTE <= self.vkCode <= winUser.VK_VOLUME_UP:\r\n\t\t\treturn None\r\n\t\tif self.vkCode == 0xFF:\r\n\t\t\t# #3468: This key is unknown to Windows.\r\n\t\t\t# This could be for an event such as gyroscope movement,\r\n\t\t\t# so don't interrupt speech.\r\n\t\t\treturn None\r\n\t\tif not config.conf['keyboard']['speechInterruptForCharacters'] and (not self.shouldReportAsCommand or self.vkCode in (winUser.VK_SHIFT, winUser.VK_LSHIFT, winUser.VK_RSHIFT)):\r\n\t\t\treturn None\r\n\t\tif self.vkCode==winUser.VK_RETURN and not config.conf['keyboard']['speechInterruptForEnter']:\r\n\t\t\treturn None\r\n\t\tif self.vkCode in (winUser.VK_SHIFT, winUser.VK_LSHIFT, winUser.VK_RSHIFT):\r\n\t\t\treturn self.SPEECHEFFECT_RESUME if speech.isPaused else self.SPEECHEFFECT_PAUSE\r\n\t\treturn self.SPEECHEFFECT_CANCEL\r\n\r\n\tdef reportExtra(self):\r\n\t\tif self.vkCode in self.TOGGLE_KEYS:\r\n\t\t\tcore.callLater(30, self._reportToggleKey)\r\n\r\n\tdef _reportToggleKey(self):\r\n\t\ttoggleState = winUser.getKeyState(self.vkCode) & 1\r\n\t\tkey = self.mainKeyName\r\n\t\tui.message(u\"{key} {state}\".format(\r\n\t\t\tkey=localizedKeyLabels.get(key.lower(), key),\r\n\t\t\tstate=_(\"on\") if toggleState else _(\"off\")))\r\n\r\n\tdef send(self):\r\n\t\tkeys = []\r\n\t\tfor vk, ext in self.generalizedModifiers:\r\n\t\t\tif vk == VK_WIN:\r\n\t\t\t\tif winUser.getKeyState(winUser.VK_LWIN) & 32768 or winUser.getKeyState(winUser.VK_RWIN) & 32768:\r\n\t\t\t\t\t# Already down.\r\n\t\t\t\t\tcontinue\r\n\t\t\t\tvk = winUser.VK_LWIN\r\n\t\t\telif winUser.getKeyState(vk) & 32768:\r\n\t\t\t\t# Already down.\r\n\t\t\t\tcontinue\r\n\t\t\tkeys.append((vk, 0, ext))\r\n\t\tkeys.append((self.vkCode, self.scanCode, self.isExtended))\r\n\r\n\t\twith ignoreInjection():\r\n\t\t\tif winUser.getKeyState(self.vkCode) & 32768:\r\n\t\t\t\t# This key is already down, so send a key up for it first.\r\n\t\t\t\twinUser.keybd_event(self.vkCode, self.scanCode, self.isExtended + 2, 0)\r\n\r\n\t\t\t# Send key down events for these keys.\r\n\t\t\tfor vk, scan, ext in keys:\r\n\t\t\t\twinUser.keybd_event(vk, scan, ext, 0)\r\n\t\t\t# Send key up events for the keys in reverse order.\r\n\t\t\tfor vk, scan, ext in reversed(keys):\r\n\t\t\t\twinUser.keybd_event(vk, scan, ext + 2, 0)\r\n\r\n\t\t\tif not queueHandler.isPendingItems(queueHandler.eventQueue):\r\n\t\t\t\t# We want to guarantee that by the time that \r\n\t\t\t\t# this function returns,the keyboard input generated\r\n\t\t\t\t# has been injected and NVDA has received and processed it.\r\n\t\t\t\ttime.sleep(0.01)\r\n\t\t\t\twx.Yield()\r\n\r\n\t@classmethod\r\n\tdef fromName(cls, name):\r\n\t\t\"\"\"Create an instance given a key name.\r\n\t\t@param name: The key name.\r\n\t\t@type name: str\r\n\t\t@return: A gesture for the specified key.\r\n\t\t@rtype: L{KeyboardInputGesture}\r\n\t\t\"\"\"\r\n\t\tkeyNames = name.split(\"+\")\r\n\t\tkeys = []\r\n\t\tfor keyName in keyNames:\r\n\t\t\tif keyName == \"plus\":\r\n\t\t\t\t# A key name can't include \"+\" except as a separator.\r\n\t\t\t\tkeyName = \"+\"\r\n\t\t\tif keyName == VK_WIN:\r\n\t\t\t\tvk = winUser.VK_LWIN\r\n\t\t\t\text = False\r\n\t\t\telif keyName.lower() == VK_NVDA.lower():\r\n\t\t\t\tvk, ext = getNVDAModifierKeys()[0]\r\n\t\t\telif len(keyName) == 1:\r\n\t\t\t\text = False\r\n\t\t\t\trequiredMods, vk = winUser.VkKeyScanEx(keyName, getInputHkl())\r\n\t\t\t\tif requiredMods & 1:\r\n\t\t\t\t\tkeys.append((winUser.VK_SHIFT, False))\r\n\t\t\t\tif requiredMods & 2:\r\n\t\t\t\t\tkeys.append((winUser.VK_CONTROL, False))\r\n\t\t\t\tif requiredMods & 4:\r\n\t\t\t\t\tkeys.append((winUser.VK_MENU, False))\r\n\t\t\t\t# Not sure whether we need to support the Hankaku modifier (& 8).\r\n\t\t\telse:\r\n\t\t\t\tvk, ext = vkCodes.byName[keyName.lower()]\r\n\t\t\t\tif ext is None:\r\n\t\t\t\t\text = False\r\n\t\t\tkeys.append((vk, ext))\r\n\r\n\t\tif not keys:\r\n\t\t\traise ValueError\r\n\r\n\t\treturn cls(keys[:-1], vk, 0, ext)\r\n\r\n\tRE_IDENTIFIER = re.compile(r\"^kb(?:\\((.+?)\\))?:(.*)$\")\r\n\t@classmethod\r\n\tdef getDisplayTextForIdentifier(cls, identifier):\r\n\t\tlayout, keys = cls.RE_IDENTIFIER.match(identifier).groups()\r\n\t\tdispSource = None\r\n\t\tif layout:\r\n\t\t\ttry:\r\n\t\t\t\t# Translators: Used when describing keys on the system keyboard with a particular layout.\r\n\t\t\t\t# %s is replaced with the layout name.\r\n\t\t\t\t# For example, in English, this might produce \"laptop keyboard\".\r\n\t\t\t\tdispSource = _(\"%s keyboard\") % cls.LAYOUTS[layout]\r\n\t\t\texcept KeyError:\r\n\t\t\t\tpass\r\n\t\tif not dispSource:\r\n\t\t\t# Translators: Used when describing keys on the system keyboard applying to all layouts.\r\n\t\t\tdispSource = _(\"keyboard, all layouts\")\r\n\r\n\t\tkeys = set(keys.split(\"+\"))\r\n\t\tnames = []\r\n\t\tmain = None\r\n\t\ttry:\r\n\t\t\t# If present, the NVDA key should appear first.\r\n\t\t\tkeys.remove(\"nvda\")\r\n\t\t\tnames.append(\"NVDA\")\r\n\t\texcept KeyError:\r\n\t\t\tpass\r\n\t\tfor key in keys:\r\n\t\t\ttry:\r\n\t\t\t\t# vkCodes.byName values are (vk, ext)\r\n\t\t\t\tvk = vkCodes.byName[key][0]\r\n\t\t\texcept KeyError:\r\n\t\t\t\t# This could be a fake vk.\r\n\t\t\t\tvk = key\r\n\t\t\tlabel = localizedKeyLabels.get(key, key)\r\n\t\t\tif vk in cls.NORMAL_MODIFIER_KEYS:\r\n\t\t\t\tnames.append(label)\r\n\t\t\telse:\r\n\t\t\t\t# The main key must be last, so handle that outside the loop.\r\n\t\t\t\tmain = label\r\n\t\tnames.append(main)\r\n\t\treturn dispSource, \"+\".join(names)\r\n\r\ninputCore.registerGestureSource(\"kb\", KeyboardInputGesture)\r\n\r\ndef injectRawKeyboardInput(isPress, code, isExtended):\r\n\t\"\"\"Inject raw input from a system keyboard that is not handled natively by Windows.\r\n\tFor example, this might be used for input from a QWERTY keyboard on a braille display.\r\n\tNVDA will treat the key as if it had been pressed on a normal system keyboard.\r\n\tIf it is not handled by NVDA, it will be sent to the operating system.\r\n\t@param isPress: Whether the key is being pressed.\r\n\t@type isPress: bool\r\n\t@param code: The scan code (PC set 1) of the key.\r\n\t@type code: int\r\n\t@param isExtended: Whether this is an extended key.\r\n\t@type isExtended: bool\r\n\t\"\"\"\r\n\tmapScan = code\r\n\tif isExtended:\r\n\t\t# Change what we pass to MapVirtualKeyEx, but don't change what NVDA gets.\r\n\t\tmapScan |= 0xE000\r\n\tvkCode = winUser.user32.MapVirtualKeyExW(mapScan, winUser.MAPVK_VSC_TO_VK_EX, getInputHkl())\r\n\tif isPress:\r\n\t\tshouldSend = internal_keyDownEvent(vkCode, code, isExtended, False)\r\n\telse:\r\n\t\tshouldSend = internal_keyUpEvent(vkCode, code, isExtended, False)\r\n\tif shouldSend:\r\n\t\tflags = 0\r\n\t\tif not isPress:\r\n\t\t\tflags |= 2\r\n\t\tif isExtended:\r\n\t\t\tflags |= 1\r\n\t\twith ignoreInjection():\r\n\t\t\twinUser.keybd_event(vkCode, code, flags, None)\r\n\t\t\twx.Yield()\r\n", "idx": 1, "id": 28140, "msg": "How likely would it be that the keyboard layout for the NVDA main thread differs from the keyboard layout of the currently focused app?", "proj": "nvaccess-nvda", "lang": "py"}
{"patch": "@@ -198,6 +198,10 @@ class Driver extends webdriver.WebDriver {\n    * @return {!Driver} A new driver instance.\n    */\n   static createSession(options, service = getDefaultService()) {\n+    if (!service) {\n+      service = getDefaultService();\n+    }\n+    \n     let client = service.start().then(url => new http.HttpClient(url));\n     let executor = new http.Executor(client);\n ", "y": 1, "oldf": "// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for\n * Microsoft's Edge web browser. Before using this module,\n * you must download and install the latest\n * [MicrosoftEdgeDriver](http://go.microsoft.com/fwlink/?LinkId=619687) server.\n * Ensure that the MicrosoftEdgeDriver is on your\n * [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29).\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link ./remote.DriverService remote.DriverService}\n *     that manages the [MicrosoftEdgeDriver] child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new\n *     MicrosoftEdgeDriver session, such as which\n *     {@linkplain Options#setProxy proxy} to use when starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session.\n *\n * __Customizing the MicrosoftEdgeDriver Server__ <a id=\"custom-server\"></a>\n *\n * By default, every MicrosoftEdge session will use a single driver service,\n * which is started the first time a {@link Driver} instance is created and\n * terminated when this process exits. The default service will inherit its\n * environment from the current process.\n * You may obtain a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     var edge = require('selenium-webdriver/edge');\n *\n *     var service = new edge.ServiceBuilder()\n *         .setPort(55555)\n *         .build();\n *\n *     var options = new edge.Options();\n *     // configure browser options ...\n *\n *     var driver = edge.Driver.createSession(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start MicrosoftEdge using the\n * {@link ./builder.Builder selenium-webdriver.Builder}.\n *\n * [MicrosoftEdgeDriver]: https://msdn.microsoft.com/en-us/library/mt188085(v=vs.85).aspx\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst util = require('util');\n\nconst http = require('./http');\nconst io = require('./io');\nconst portprober = require('./net/portprober');\nconst promise = require('./lib/promise');\nconst remote = require('./remote');\nconst Symbols = require('./lib/symbols');\nconst webdriver = require('./lib/webdriver');\nconst {Browser, Capabilities} = require('./lib/capabilities');\n\nconst EDGEDRIVER_EXE = 'MicrosoftWebDriver.exe';\n\n\n/**\n * _Synchronously_ attempts to locate the edge driver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return process.platform === 'win32'\n      ? io.findInPath(EDGEDRIVER_EXE, true) : null;\n}\n\n\n/**\n * Class for managing MicrosoftEdgeDriver specific options.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other = undefined) {\n    super(other);\n    this.setBrowserName(Browser.EDGE);\n  }\n}\n\n\n/**\n * Creates {@link remote.DriverService} instances that manage a\n * MicrosoftEdgeDriver server in a child process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *   the builder will attempt to locate the MicrosoftEdgeDriver on the current\n   *   PATH.\n   * @throws {Error} If provided executable does not exist, or the\n   *   MicrosoftEdgeDriver cannot be found on the PATH.\n   */\n  constructor(opt_exe) {\n    let exe = opt_exe || locateSynchronously();\n    if (!exe) {\n      throw Error(\n        'The ' + EDGEDRIVER_EXE + ' could not be found on the current PATH. ' +\n        'Please download the latest version of the MicrosoftEdgeDriver from ' +\n        'https://www.microsoft.com/en-us/download/details.aspx?id=48212 and ' +\n        'ensure it can be found on your PATH.');\n    }\n\n    super(exe);\n\n    // Binding to the loopback address will fail if not running with\n    // administrator privileges. Since we cannot test for that in script\n    // (or can we?), force the DriverService to use \"localhost\".\n    this.setHostname('localhost');\n  }\n\n  /**\n   * Enables verbose logging.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging() {\n    return this.addArguments('--verbose');\n  }\n}\n\n\n/** @type {remote.DriverService} */\nvar defaultService = null;\n\n\n/**\n * Sets the default service to use for new MicrosoftEdgeDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error(\n      'The previously configured EdgeDriver service is still running. ' +\n      'You must shut it down before you may adjust its configuration.');\n  }\n  defaultService = service;\n}\n\n\n/**\n * Returns the default MicrosoftEdgeDriver service. If such a service has\n * not been configured, one will be constructed using the default configuration\n * for an MicrosoftEdgeDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default MicrosoftEdgeDriver service.\n */\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n  return defaultService;\n}\n\n\n/**\n * Creates a new WebDriver client for Microsoft's Edge.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new browser session for Microsoft's Edge browser.\n   *\n   * @param {(Capabilities|Options)=} options The configuration options.\n   * @param {remote.DriverService=} service The session to use; will use\n   *     the {@linkplain #getDefaultService default service} by default.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(options, service = getDefaultService()) {\n    let client = service.start().then(url => new http.HttpClient(url));\n    let executor = new http.Executor(client);\n\n    options = options || new Options();\n    return /** @type {!Driver} */(super.createSession(\n        executor, options, () => service.kill()));\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n}\n\n\n// PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;\nexports.locateSynchronously = locateSynchronously;\n", "idx": 1, "id": 15395, "msg": "Would you mind removing the default parameter above? (I doubt I'll ever use defaults again since you still have to protect against callers explicitly passing `null` or `undefined`)", "proj": "SeleniumHQ-selenium", "lang": "rb"}
