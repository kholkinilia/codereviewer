{"patch": "@@ -1420,6 +1423,20 @@ class ClassFileToSourceStubConverter(val kaptContext: KaptContextForStubGenerati\n         lineMappings.registerSignature(this, node)\n         return this\n     }\n+\n+    private fun fieldType(field: FieldNode, origin: JvmDeclarationOrigin?): Type {\n+        val signType = Type.getType(field.desc)\n+        return when (val declaration = origin?.element) {\n+            is KtProperty -> {\n+                val delegateType = kaptContext.bindingContext[BindingContext.EXPRESSION_TYPE_INFO, declaration.delegateExpression]?.type", "msg": "After this commit `convertKotlinType()` will be always used for properties with delegates.\r\nUsing it only for anonymous-type delegates would be safer, I think."}
{"patch": "@@ -76,8 +76,10 @@ class DeclarationStubGenerator(\n         if (symbol is IrFieldSymbol && (symbol.descriptor as? WrappedPropertyDescriptor)?.isBound() == true) {\n             return generateStubBySymbol(symbol, symbol.descriptor)\n         }\n+        val signature = symbol.signature\n+            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")", "msg": "I mean \r\n`findDescriptorBySignature(symbol.signature\r\n            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")`"}
{"patch": "@@ -100,6 +100,9 @@ fun BaseKotlinLibrary.unresolvedDependencies(lenient: Boolean = false): List<Unr\n     manifestProperties.propertyList(KLIB_PROPERTY_DEPENDS, escapeInQuotes = true)\n         .map { UnresolvedLibrary(it, manifestProperties.getProperty(\"dependency_version_$it\"), lenient = lenient) }\n \n+val BaseKotlinLibrary.hasUnresolvedDependencies: Boolean", "msg": "I would just call it `hasDependencies`. \"Unresolved\" is a special additional property used to indicate that `fun BaseKotlinLibrary.unresolvedDependencies()` returns `UnresolvedLibrary`s that need further resolve."}
{"patch": "@@ -65,6 +66,9 @@ class RedundantCompanionReferenceInspection : AbstractKotlinInspection() {\n \n             val containingClass = objectDeclaration.containingClass() ?: return false\n             if (reference.containingClass() != containingClass && reference == parent.receiverExpression) return false\n+            val calleeText = ((selectorExpression as? KtCallExpression) ?: (grandParent as? KtQualifiedExpression)?.callExpression)", "msg": "First: this function is already too long, you can't add more logic into it. You should extract 3 lines of code you added into separate function + split code of existing `isRedundantCompanionReference` into subfunctions\r\n\r\nSecond: `values` and `valueOf` are hardcoded strings. There are already present in the project. At least you can find them in `RemoveRedundantQualifierNameInspection` and `UnusedSymbolInspection`. Please, extract those hardcoded strings into util class/file and reuse them"}
{"patch": "@@ -5,7 +5,7 @@ fun bar(z: String?) = z\n fun foo(y: String?) {\n     var x: String? = \"\"\n     if (x != null) {\n-        bar(y?.let { x = null; it }).<!INAPPLICABLE_CANDIDATE!>length<!>\n+        bar(y?.let { x = null; it }).<!UNSAFE_CALL!>length<!>\n         x.length // Smart cast is not possible", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44512\r\n\r\nAlso one below (`withChangesToNull`)"}
{"patch": "@@ -53,9 +73,10 @@ object FirSealedSupertypeChecker : FirClassChecker() {\n                 continue\n             }\n \n-            val classSymbol = context.session.symbolProvider.getClassLikeSymbolByFqName(classId) as? FirRegularClassSymbol ?: continue\n+            val fir = context.session.symbolProvider.getClassLikeSymbolByFqName(classId)", "msg": "Nit: this change made the line shorter, so line wrapping seems not necessary."}
{"patch": "@@ -132,7 +162,8 @@ class IrParcelSerializerFactory(private val symbols: AndroidSymbols) {\n             // special parceler for the element type.\n             \"kotlin.Array\", \"kotlin.ShortArray\", \"kotlin.IntArray\",\n             \"kotlin.BooleanArray\", \"kotlin.ByteArray\", \"kotlin.CharArray\",\n-            \"kotlin.FloatArray\", \"kotlin.DoubleArray\", \"kotlin.LongArray\" -> {\n+            \"kotlin.FloatArray\", \"kotlin.DoubleArray\", \"kotlin.LongArray\",", "msg": "Please revert this change to keep the style consistent."}
{"patch": "@@ -126,6 +128,37 @@ open class LazyClassMemberScope(\n                 }\n             }\n \n+    private val _classifierNames: Set<Name>?\n+            by lazy(LazyThreadSafetyMode.PUBLICATION) {\n+                mutableSetOf<Name>().run {\n+                    supertypes.flatMapToNullable(this) {\n+                        it.memberScope.getClassifierNames()\n+                    } ?: return@run null\n+\n+                    addAll(declarationProvider.getDeclarationNames())\n+                    addSyntheticClassifiers()\n+\n+                    this\n+                }\n+            }\n+\n+    private val _allKnownNames: Set<Name>", "msg": "This whole set should be nullable in case it's impossible to compute classifiers names"}
{"patch": "@@ -0,0 +1,216 @@\n+/*", "msg": "And this is, imho, unnecessary copy-paste too."}
{"patch": "@@ -234,7 +243,7 @@ abstract class IncrementalCompilerRunner<\n \n             args.reportOutputFiles = true\n             val outputItemsCollector = OutputItemsCollectorImpl()\n-            val temporaryMessageCollector = TemporaryMessageCollector(messageCollector)\n+            val temporaryMessageCollector = BufferingMessageCollector()", "msg": "nit: Rename to bufferingMessageCollector?"}
{"patch": "@@ -36,7 +37,7 @@ object RedundantModalityModifierChecker : FirMemberDeclarationChecker() {\n \n         if (modality != implicitModality) return\n \n-        val modalityModifierSource = declaration.source.getModifierList()?.modifiers?.modalitySource()\n+        val modalityModifierSource = declaration.source?.getChildren(modality.toToken(), depth = 2)\n         reporter.report(modalityModifierSource, REDUNDANT_MODALITY_MODIFIER)\n     }\n ", "msg": "`modalitySource` below is now unused, please remove it."}
{"patch": "@@ -68,5 +69,10 @@ object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVari\n \n     private fun KtBinaryExpression.isCommutative() = this.operationToken == KtTokens.PLUS || this.operationToken == KtTokens.MUL\n \n+    private fun KtBinaryExpression.isArithmetic() = this.operationToken == KtTokens.PLUS", "msg": "I'd change the name to `canBeAugmented` or something like."}
{"patch": "@@ -823,9 +823,9 @@ class ExpressionsConverter(\n         }\n         val getArgument = context.arraySetArgument.remove(arrayAccess)\n         return buildFunctionCall {\n-            source = arrayAccess.toFirSourceElement()\n+            source = (if (getArgument == null) arrayAccess else arrayAccess.getParent()!!).toFirSourceElement()", "msg": "Nit: You can introduce either `val isGet = getArgument == null` or `isSet` and use here and below for `name`."}
{"patch": "@@ -432,14 +431,20 @@ fun IrFunction.createDispatchReceiverParameter(origin: IrDeclarationOrigin? = nu\n \n val IrFunction.allParameters: List<IrValueParameter>\n     get() = if (this is IrConstructor) {\n-        listOf(\n-            this.constructedClass.thisReceiver\n-                ?: error(this.render())\n-        ) + explicitParameters\n+        ArrayList<IrValueParameter>(valueParameters.size + 3).also {", "msg": "```suggestion\r\n        ArrayList<IrValueParameter>(allParametersCount).also {\r\n```"}
{"patch": "@@ -147,7 +147,9 @@ object FirNotImplementedOverrideChecker : FirClassChecker() {\n             classScope.processFunctionsByName(name) {\n                 val declaration = it.fir\n                 if (declaration.matchesDataClassSyntheticMemberSignatures && declaration.modality != Modality.FINAL) {\n-                    contributedInSupertypes.putIfAbsent(declaration.name, declaration)\n+                    if (contributedInSupertypes.putIfAbsent(declaration.name, declaration) == null) {\n+                        return@processFunctionsByName", "msg": "Same problem as before"}
{"patch": "@@ -0,0 +1,33 @@\n+/*", "msg": "And this is, imho, unnecessary copy-paste too."}
{"patch": "@@ -20,7 +20,7 @@ fun test_2(n: Int) {\n \n fun Int.bar(): Int {}\n \n-fun Int.baz(): Int\n+fun Int.baz(): Int {}", "msg": "Otherwise it would be `NON_MEMBER_FUNCTION_NO_BODY`, but I don't think the purpose of this test is to check that."}
{"patch": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.uast.test.kotlin\n+\n+import org.jetbrains.uast.UFile\n+import org.jetbrains.uast.test.common.kotlin.FirUastIdentifiersTestBase\n+import java.io.File\n+\n+abstract class AbstractFE1UastIdentifiersTest : AbstractKotlinUastTest(), FirUastIdentifiersTestBase {\n+    override val isFirUastPlugin: Boolean = false\n+\n+    override fun check(filePath: String, file: UFile) {\n+        super<FirUastIdentifiersTestBase>.check(filePath, file)\n+    }\n+\n+    override var testDataDir = File(\"plugins/uast-kotlin-fir/testData\")\n+\n+    fun doTest(filePath: String) {\n+        testDataDir = File(filePath).parentFile\n+        val testName = filePath.substring(filePath.lastIndexOf('/') + 1).removeSuffix(\".kt\")", "msg": "Maybe  `val testName  = File(filePath).nameWithoutExtension`"}
{"patch": "@@ -0,0 +1,2 @@\n+class A(<!ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS!>abstract<!> val i: Int)\n+class B(abstract i: Int)", "msg": "Missing `WRONG_MODIFIER_TARGET`? cc @punzki "}
{"patch": "@@ -24,6 +24,6 @@ fun g(x: B<Int>) {\n \n     if (y is Nothing?) {\n         f(y)\n-        <!NONE_APPLICABLE!>g<!>(y)\n+        g(y)", "msg": "Well, at least, we are consistent now (see line 22 above)."}
{"patch": "@@ -1124,9 +1124,15 @@ fun main(args: Array<String>) {\n             testClass<AbstractHighLevelQuickFixTest> {\n                 val pattern = \"^([\\\\w\\\\-_]+)\\\\.kt$\"\n                 model(\"quickfix/abstract\", pattern = pattern, filenameStartsLowerCase = true)\n+                model(\"quickfix/expressions\", pattern = pattern, filenameStartsLowerCase = true)\n                 model(\"quickfix/lateinit\", pattern = pattern, filenameStartsLowerCase = true)\n                 model(\"quickfix/modifiers\", pattern = pattern, filenameStartsLowerCase = true, recursive = false)\n+                model(\"quickfix/nullables\", pattern = pattern, filenameStartsLowerCase = true)\n                 model(\"quickfix/override/typeMismatchOnOverride\", pattern = pattern, filenameStartsLowerCase = true, recursive = false)\n+                model(\"quickfix/replaceInfixOrOperatorCall\", pattern = pattern, filenameStartsLowerCase = true)", "msg": "None of tests from `replaceInfixOrOperatorCall`/`replaceWithDotCal` are passing, may be let\u2019s not generate them?\r\n\r\n"}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{\n+            it.isWhitespace()\n+        }\n+        assertFalse(containsWhiteSpace)", "msg": "In samples we use `assertPrints(value, stringRepresentation)` which is converted to \r\n```\r\nprintln(value) // stringRepresentation\r\n```\r\nin Kotlin website. E.g. the `splitToSequence` sample above is converted to this runnable code in docs website: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split-to-sequence.html"}
{"patch": "@@ -583,7 +586,7 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n                     .single { it is IrSimpleFunction && it.name.asString() == name } as IrFunction\n                 val branches = noinlineSubclasses\n                     .filter { info ->\n-                        info.bottom.declarations.any { it is IrSimpleFunction && it.name.asString() == name && !it.isFakeOverride }\n+                        info.bottom.isFunctionDeclared() || info.sealedParents.any { it.owner.isFunctionDeclared() }", "msg": "Maybe you could use `overriddenSymbols` to figure out if there is an implementation of a function from `Any` with the correct name?"}
{"patch": "@@ -38,6 +40,16 @@ internal class InlineClassAwareCaller<out M : Member?>(\n     override val parameterTypes: List<Type>\n         get() = caller.parameterTypes\n \n+    private val memberParameterTypes: List<Class<*>>\n+        get() = when (val m = member) {\n+            is Method -> m.parameterTypes.asList()\n+            is Constructor<*> -> m.parameterTypes.asList()\n+            is Field -> listOf(m.type)\n+            // TODO: Check if there are any cases other than the above three, especially if they result in null.\n+            // TODO: Check the Exceptions and error messages to be thrown.\n+            else -> throw IllegalArgumentException(\"temp err\")", "msg": "I have a question about the `member` property.\r\n\r\nLooking at the `Javadoc` of the `Member` interface, it appears that this interface is not inherited by any classes other than `Method`, `Constructor` and `Field`.\r\nhttps://docs.oracle.com/javase/jp/8/docs/api/java/lang/reflect/Member.html\r\nIn other words, this `else` clause is executed when the `member` property is `null`.\r\n\r\nNow, is there a situation where the `member` property is `null` in `InlineClassAwareCaller`?\r\nIf present, modify the processing in `else`, and if not, modify the error message, respectively."}
{"patch": "@@ -7,8 +7,8 @@ import checkSubtype\n fun main(args : Array<String>) {\n     val x = checkSubtype<Any>(args[0])\n     if(x is java.lang.CharSequence) {\n-        if (\"a\" == x) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // OK\n-        if (\"a\" == x || \"b\" == x) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // <\u2013 THEN ERROR\n-        if (\"a\" == x && \"a\" == x) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // <\u2013 ELSE ERROR\n+        if (<!EQUALITY_NOT_APPLICABLE!>\"a\" == x<!>) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // OK", "msg": "This is similar to https://github.com/JetBrains/kotlin/pull/4281#discussion_r607421688. BTW, I was surprised to learn `kotlin.String` is not a subtype of `java.lang.CharSequence`."}
{"patch": "@@ -78,8 +80,9 @@ class MaterialValue(codegen: ExpressionCodegen, type: Type, irType: IrType) : Pr\n \n // A value that can be branched on. JVM has certain branching instructions which can be used\n // to optimize these.\n-abstract class BooleanValue(codegen: ExpressionCodegen) :\n-    PromisedValue(codegen, Type.BOOLEAN_TYPE, codegen.context.irBuiltIns.booleanType) {\n+abstract class BooleanValue(codegen: ExpressionCodegen, type: Type, irType: IrType) : PromisedValue(codegen, type, irType) {", "msg": "Maybe rename to BranchedValue (similar to one in old backend)?"}
{"patch": "@@ -216,10 +213,21 @@ fun IrDeclaration.isInCurrentModule(): Boolean =\n // This is needed to pinpoint exceptional treatment of IEEE754 floating point comparisons, where proper IEEE\n // comparisons are used \"if values are statically known to be of primitive numeric types\", taken to mean as\n // \"not learned through smartcasting\".\n-fun IrExpression.isSmartcastFromHigherThanNullable(context: JvmBackendContext) =\n-    this is IrTypeOperatorCall &&\n-            operator == IrTypeOperator.IMPLICIT_CAST &&\n-            !this.argument.type.isSubtypeOf(type.makeNullable(), context.irBuiltIns)\n+fun IrExpression.isSmartcastFromHigherThanNullable(context: JvmBackendContext): Boolean {\n+    return when (this) {\n+        is IrTypeOperatorCall -> operator == IrTypeOperator.IMPLICIT_CAST && !argument.type.isSubtypeOf(", "msg": "Nit: I'd break this differently.\r\n```kotlin\r\nis IrTypeOperatorCall -> operator == IrTypeOperator.IMPLICIT_CAST &&\r\n    !argument.type.isSubtypeOf(type.makeNullable(), context.irBuiltIns)\r\n```"}
{"patch": "@@ -120,25 +120,28 @@ interface TypeDeclaration {\n     val location: Location\n }\n \n-sealed class StructMember(val name: String, val type: Type) {\n+sealed class StructMember(val name: String) {\n     abstract val offset: Long?\n }\n \n /**\n  * C struct field.\n  */\n-class Field(name: String, type: Type, override val offset: Long, val typeSize: Long, val typeAlign: Long)\n-    : StructMember(name, type)\n+class Field(name: String, val type: Type, override val offset: Long, val typeSize: Long, val typeAlign: Long)\n+    : StructMember(name)\n \n val Field.isAligned: Boolean\n     get() = offset % (typeAlign * 8) == 0L\n \n-class BitField(name: String, type: Type, override val offset: Long, val size: Int) : StructMember(name, type)\n+class BitField(name: String, val type: Type, override val offset: Long, val size: Int) : StructMember(name)\n \n-class IncompleteField(name: String, type: Type) : StructMember(name, type) {\n+class IncompleteField(name: String, val type: Type) : StructMember(name) {", "msg": "Is `type` here used?"}
{"patch": "@@ -20,6 +20,8 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             ErrorsNative.INCOMPATIBLE_THROWS_INHERITED, \"Member inherits different @Throws filters from {0}\",\n             Renderers.commaSeparated(Renderers.NAME)\n         )\n+        put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_VAR, \"@SharedImmutable isn't applicable to var\")\n+        put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, \"@SharedImmutable is applicable only to top level entities\")", "msg": "> entities\r\n\r\ndeclarations"}
{"patch": "@@ -239,6 +239,9 @@ fun FirTypeRef.withReplacedConeType(\n     }\n }\n \n+fun FirTypeRef.withNullability(nullability: ConeNullability): FirTypeRef =", "msg": "Replacing nullability of `FirTypeRef` doesn't makes any sense, because type ref has no nullability. I rewrote changes in `transformElvisExpression` so they looks more idiomatic"}
{"patch": "@@ -40,8 +40,7 @@ fun getPropertiesToUseInGeneratedMember(classOrObject: KtClassOrObject): List<Kt\n         classOrObject.declarations.asSequence().filterIsInstance<KtProperty>().filterTo(this) {\n             val descriptor = it.unsafeResolveToDescriptor()\n             when (descriptor) {\n-                is ValueParameterDescriptor -> true\n-                is PropertyDescriptor -> descriptor.getter?.isDefault ?: true\n+                is ValueParameterDescriptor, is PropertyDescriptor -> true", "msg": "This done intentionally. User custom getter may contain complex computations or side effects. It's not safe to suggest custom getters in toString/hashCode default generator.\r\n\r\nYou can suggest pull request where custom getters are suggested but are disabled by default in this dialog:\r\n![image](https://user-images.githubusercontent.com/20517828/82453716-8b01ce00-9ab9-11ea-965a-1ca70f0ff93e.png)\r\n "}
{"patch": "@@ -24,7 +24,7 @@ class ThrowableLowering(val context: JsIrBackendContext) : BodyLoweringPass {\n \n     private val throwableConstructors = context.throwableConstructors\n     private val newThrowableFunction = context.newThrowableSymbol\n-    private val extendThrowableFunction = context.extendThrowableSymbol\n+    private val extendThrowableFunction = with(context) { if (es6mode) setPropertiesToThrowableInstanceSymbol else extendThrowableSymbol }", "msg": "Let pass it to constructor"}
{"patch": "@@ -92,7 +96,7 @@ interface ScopeTowerLevel {\n class CandidateWithBoundDispatchReceiver(\n     val dispatchReceiver: ReceiverValueWithSmartCastInfo?,\n     val descriptor: CallableDescriptor,\n-    val diagnostics: List<ResolutionDiagnostic>\n+    val diagnostics: MutableList<ResolutionDiagnostic>", "msg": "Can I revert it to `List`?"}
{"patch": "@@ -14,6 +14,7 @@\n  * limitations under the License.\n  */\n \n+", "msg": "Revert changes to this file."}
{"patch": "@@ -305,7 +322,7 @@ class IrArrayParcelSerializer(\n class IrSparseArrayParcelSerializer(\n     private val sparseArrayClass: IrClass,\n     private val elementType: IrType,\n-    private val elementSerializer: IrParcelSerializer\n+    private val elementSerializer: IrParcelSerializer,", "msg": "Please revert this change."}
{"patch": "@@ -611,7 +611,7 @@ class KmValueParameter(\n      * @param visitor the visitor which will visit data in this value parameter\n      */\n     fun accept(visitor: KmValueParameterVisitor) {\n-        type?.let { visitor.visitType(it.flags)?.let(it::accept) }\n+        type.let { visitor.visitType(it.flags)?.let(it::accept) }", "msg": "I guess the `let` call can be inlined now for simplicity\r\n```suggestion\r\n        visitor.visitType(type.flags)?.let(type::accept)\r\n```"}
{"patch": "@@ -667,11 +669,13 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n             parameter<FirExpression>(\"lhs\")\n             parameter<String>(\"operator\")\n             parameter<FirExpression>(\"rhs\")\n+            parameter<FirExpression?>(\"receiverExpression\")\n         }\n         val UNSAFE_OPERATOR_CALL by error<KtExpression>(PositioningStrategy.REFERENCE_BY_QUALIFIED) {\n             parameter<FirExpression>(\"lhs\")\n             parameter<String>(\"operator\")\n             parameter<FirExpression>(\"rhs\")\n+            parameter<FirExpression?>(\"receiverExpression\")", "msg": "I suspect either `receiverExpression` or `lhs` isn't needed here"}
{"patch": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.utils;\n+\n+data class KotlinReplError(val loc: Location?, val message: String = \"\", val severity: Severity) {", "msg": "It seems that it could be substituted with ScriptDiagnostic. But the problem is that scripting-common is not accessible from compiler-cli. So it is one more reason to base completion on a new API and relocate it completely to a plugin similar to scripting plugin."}
{"patch": "@@ -19,22 +19,47 @@ package org.jetbrains.kotlin.cli.common.messages\n import java.io.Serializable\n \n data class CompilerMessageLocation private constructor(", "msg": "This is a common part used extensively outside of the scripting, so I suggest to make changes less intrusive, i.e. leave `line` and `column` intact, add `endLine` and `endColumn`, and put this change into a separate commit with an explanation \"why\" in the commit message."}
{"patch": "@@ -14,15 +14,15 @@ fun g(a: SomeClass?) {\n         a.hashCode()\n         a.foo\n         (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n-        (a as SomeSubClass).foo\n+        (a <!USELESS_CAST!>as SomeSubClass<!>).foo\n     }\n     val b = (a as? SomeSubClass)?.foo\n     if (b != null) {\n         // 'a' can be cast to SomeSubClass\n         a.hashCode()\n         a.foo\n         (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n-        (a as SomeSubClass).foo\n+        (a <!USELESS_CAST!>as SomeSubClass<!>).foo", "msg": "Note that this test is same as `basicOn` below, but without `SafeCastCheckBoundSmartCasts`, which disables collection of nullability info. As we all know(?), nullability is not available for `== null`, but available for `!= null` in FIR DFA. That's why, with or without that flag, we're seeing those variables as non-null `SomeSubClass`. That flag is on since 1.2, so seeing the same result with `basicOn` seems okay."}
{"patch": "@@ -1249,6 +1249,15 @@ object DIAGNOSTICS_LIST : DiagnosticList(\"FirErrors\") {\n         val VARIABLE_INITIALIZER_IS_REDUNDANT by warning<PsiElement>()\n         val VARIABLE_NEVER_READ by warning<KtNamedDeclaration>(PositioningStrategy.DECLARATION_NAME)\n         val USELESS_CALL_ON_NOT_NULL by warning<PsiElement>(PositioningStrategy.SELECTOR_BY_QUALIFIED)\n+        val VALUE_CANNOT_BE_PROMOTED by warning<KtElement>() {", "msg": "When possible, it's better to set more precise element than just `KtElement`"}
{"patch": "@@ -162,7 +164,16 @@ abstract class StructDef(val size: Long, val align: Int, val decl: StructDecl) {\n     abstract val members: List<StructMember>\n     abstract val kind: Kind\n \n-    val fields: List<Field> get() = members.filterIsInstance<Field>()\n+    val fields: List<Field> get() {\n+        val result = mutableListOf<Field>()\n+        members.forEach {\n+            when (it) {\n+                is Field -> result.add(it)\n+                is AnonymousInnerRecord -> result.addAll((it.type as RecordType).decl.def!!.fields)\n+            }\n+        }\n+    return result\n+    }", "msg": "Shouldn't we do the same for `bitFields` below?\nIf yes, then please add a test checking this."}
{"patch": "@@ -16,6 +16,7 @@ import org.jetbrains.kotlin.fir.declarations.FirMemberDeclaration\n import org.jetbrains.kotlin.fir.psi\n import org.jetbrains.kotlin.fir.toFirPsiSourceElement\n import org.jetbrains.kotlin.lexer.KtModifierKeywordToken\n+import org.jetbrains.kotlin.lexer.KtTokens", "msg": "Redundant import"}
{"patch": "@@ -111,10 +111,25 @@ class ForLoopsLowering(val context: CommonBackendContext) : BodyLoweringPass {\n     }\n }\n \n+/**\n+ * Abstract class for additional for-loop bodies transformations.\n+ */\n+abstract class ForLoopBodyTransformer : IrElementTransformerVoid() {\n+\n+    abstract fun transform(\n+        context: CommonBackendContext,\n+        irExpression: IrExpression,", "msg": "Minor: Could you rename this  to `loopBody`?"}
{"patch": "@@ -0,0 +1,52 @@\n+// WITH_REFLECT\n+// WITH_RUNTIME", "msg": "`WITH_RUNTIME` is not needed because it's implied by `WITH_REFLECT` (also in `delegateToGenericJavaProperty.kt` and `delegateToAnother.kt`)"}
{"patch": "@@ -515,14 +517,26 @@ class Kapt3GradleSubplugin @Inject internal constructor(private val registry: To\n \n     private fun maybeRegisterTransform(project: Project) {\n         if (!project.extensions.extraProperties.has(\"KaptStructureTransformAdded\")) {\n-            project.dependencies.registerTransform(StructureTransformAction::class.java) { transformSpec ->", "msg": "You can simplify this as:\r\n```\r\n   project.dependencies.registerTransform(if (...) StructureTransformAction::class.java else StructureTransformAction::class.java) { ... }\r\n```"}
{"patch": "@@ -82,6 +83,10 @@ internal class LambdaMetafactoryArgumentsBuilder(\n         if (context.irIntrinsics.getIntrinsic(implFun.symbol) != null)\n             return null\n \n+        // Don't generate reference to inlineOnly methods as those do not exist at runtime.\n+        if (implFun.hasAnnotation(INLINE_ONLY_ANNOTATION_FQ_NAME))", "msg": "This should probably be at least `implFun.isEffectivelyInlineOnly()`, because invokedynamic won't work if the function has reified type parameters.\r\n\r\n```\r\nimport java.util.function.Consumer\r\n\r\ninline fun <reified T> foo(x: T) =\r\n    println(\"${T::class.simpleName}($x)\")\r\n\r\nfun call1(c: Consumer<String>, s: String) {\r\n    c.accept(s)\r\n}\r\n\r\nfun main() {\r\n    call1(::foo, \"Hello World!\") // java.lang.UnsupportedOperationException: This function has a reified type parameter and thus can only be inlined at compilation time, not called directly.\r\n}\r\n```\r\n\r\nPlus, if the function is a property accessor, the property has the annotation, not the function (`isEffectivelyInlineOnly` handles that too).\r\n\r\nMaybe it's best not to use invokedynamic with inline functions at all so that they are indeed copied as before?"}
{"patch": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.gradle.plugin\n+\n+import org.gradle.tooling.events.FinishEvent\n+import org.gradle.tooling.events.OperationCompletionListener\n+\n+//Available since Gradle 6.1\n+class KotlinGradleBuildListener(", "msg": "This can be a `BuildService` and if you make it `AutoCloseable` you can implement clean-up logic in `close()` method."}
{"patch": "@@ -38,3 +40,39 @@ private fun FirLightSourceElement.getChild(types: Set<IElementType>, index: Int,\n     val visitor = LighterTreeElementFinderByType(treeStructure, types, index, depth)\n     return visitor.find(lighterASTNode)?.toFirLightSourceElement(treeStructure)\n }\n+", "msg": "Now this util file, `FirSourceChild`, should be renamed somehow. :) Say, `FirSourceUtils` ?"}
{"patch": "@@ -0,0 +1,32 @@\n+// TARGET_BACKEND: JVM_IR", "msg": "Please, add irText tests for a class with context receiver."}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{\n+            it.isWhitespace()\n+        }\n+        assertFalse(containsWhiteSpace)\n+\n+        val isLowerCase: (Char) -> Boolean = Char::isLowerCase\n+        val charSequence = \"Ariya\"\n+        assertFalse(charSequence.all(isLowerCase))\n+\n+        val containsAllCharsOf: String.(String) -> Boolean = { bigger ->", "msg": "Introducing a named function is more Kotlin-ish than creating a lambda just to assign it to a `val`:\r\n```\r\nfun String.containsAllCharsOf(other: String): Boolean {\r\n    return other.all { this.contains(it) }\r\n}\r\n```"}
{"patch": "@@ -52,17 +53,91 @@ class LocalPropertyCollector private constructor() : ControlFlowGraphVisitorVoid\n     }\n }\n \n+class PathAwarePropertyInitializationInfo(\n+    map: PersistentMap<String?, PropertyInitializationInfo> = persistentMapOf()\n+) : ControlFlowInfo<PathAwarePropertyInitializationInfo, String?, PropertyInitializationInfo>(map) {\n+    companion object {\n+        val INIT = PathAwarePropertyInitializationInfo(persistentMapOf(null to PropertyInitializationInfo.EMPTY))", "msg": "Please rename it to `EMPTY`"}
{"patch": "@@ -49,6 +49,9 @@ object BuiltinSpecialBridgesUtil {\n         signatureByDescriptor: (FunctionDescriptor) -> Signature,\n         state: GenerationState\n     ): Set<BridgeForBuiltinSpecial<Signature>> {\n+//        if (function.name.asString() == \"get\" && function.containingDeclaration.name.asString() == \"B\") {", "msg": "Minor: dropped."}
{"patch": "@@ -39,11 +38,7 @@ class JvmDefaultArgumentStubGenerator(override val context: JvmBackendContext) :\n         //\n         // This control flow limits us to an if-then (without an else), and this together with the\n         // restriction on loading the parameter in the default case means we cannot create any temporaries.\n-        +irIfThen(defaultFlag, irCall(this@JvmDefaultArgumentStubGenerator.context.ir.symbols.reassignParameterIntrinsic).apply {\n-            putTypeArgument(0, parameter.type)\n-            putValueArgument(0, irGet(parameter))\n-            putValueArgument(1, default)\n-        })\n+        +irIfThen(defaultFlag, irSet(parameter.symbol, default))", "msg": "Real change: remove the JVM-specific intrinsic and use the IR structure instead."}
{"patch": "@@ -511,4 +576,51 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n \n         valueClass.declarations += function\n     }\n+\n+    private fun buildSpecializedEqualsMethodForSealed(\n+        irClass: IrClass,\n+        inlineSubclasses: List<IrClassSymbol>,\n+        noinlineSubclasses: List<IrClassSymbol>\n+    ) {\n+        val boolAnd = context.ir.symbols.getBinaryOperator(\n+            OperatorNameConventions.AND, context.irBuiltIns.booleanType, context.irBuiltIns.booleanType\n+        )\n+        val equals = context.ir.symbols.getBinaryOperator(", "msg": "`context.irBuiltins.eqeqSymbol`"}
{"patch": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.backend.jvm\n+\n+import org.jetbrains.kotlin.ir.builders.*\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.symbols.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+\n+class AtomicfuIrBuilder internal constructor(", "msg": "Same here, would be nice to drop a comment on each transformation -- what is transformed and to what"}
{"patch": "@@ -31,14 +31,22 @@ object Aggregates : TemplateGroupBase() {\n         include(Maps, CharSequences, ArraysOfUnsigned)\n     } builder {\n         inline()\n-        specialFor(ArraysOfUnsigned) { inlineOnly() }\n+        specialFor(ArraysOfUnsigned) {\n+            inlineOnly()\n+            sample(\"samples.collections.Collections.Aggregates.all\")\n+        }\n+        specialFor(Maps) {\n+            sample(\"samples.collections.Collections.Aggregates.all\")\n+        }\n+        specialFor(CharSequences) {", "msg": "This should be enough:\r\n```\r\nsample(\"samples.collections.Collections.Aggregates.all\")\r\nspecialFor(CharSequences) {\r\n    sample(\"samples.text.Strings.all\")\r\n}\r\n```\r\n\r\nThe DSL means _\"samples.collections.Collections.Aggregates.all\" is the sample for all receivers, but for CharSequences there is a different sample_\r\n\r\nSo basically the second `sample(...)` overrides the previous."}
{"patch": "@@ -262,3 +267,26 @@ private class UpdateFunctionCallSites(\n         }\n     }\n }\n+\n+private class UpdateConstantFacadePropertyReferences(private val context: JvmBackendContext) : ClassLoweringPass {", "msg": "~~Do you need this as a ClassLoweringPass? You're creating it only to call lower(). It can just be a private method, or merge it with the anonymous IrElementTransformerVoid.~~ Never mind I thought you were passing in an IrClass, didn't notice it was an IrModuleFragment"}
{"patch": "@@ -6,14 +6,14 @@ package p\n private fun foo(a: Int) = run {\n     object {\n         inner class A\n-        fun foo() = A()\n+        <!EXPOSED_FUNCTION_RETURN_TYPE!>fun foo() = A()<!>", "msg": "Probably it's the same problem with local visibility. We should not have errors here."}
{"patch": "@@ -199,6 +199,8 @@ class FunctionInlining(\n             newStatements.addAll(evaluationStatements)\n             statements.mapTo(newStatements) { it.transform(transformer, data = null) as IrStatement }\n \n+            saveParameterToExpressionMapping(callee, copiedCallee)", "msg": "There should be variables for these parameters in most cases. I think they are not shown now, as they are temporary variables. What do you think about creating a separate origin for them? I'm not sure about the name and scope, but this should be an easier solution, at least for cases, where variables are not optimized-out. "}
{"patch": "@@ -72,7 +72,7 @@ class KotlinTestsRegistry(val project: Project, val allTestsTaskName: String = \"\n             aggregate.description = description\n             aggregate.group = JavaBasePlugin.VERIFICATION_GROUP\n \n-            aggregate.destinationDir = project.testReportsDir.resolve(reportName)\n+            aggregate.destinationDirectory.set(project.testReportsDir.resolve(reportName))", "msg": "`TestReport.destinationDirectory` input was added only in Gradle 7.4. Since KGP supports all Gradle versions from 6.8.3 I could not accept this change.\r\n\r\nI need to think how to fix it better."}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{", "msg": "Could we use `assertPrints(name.any { it.isWhitespace() }, false)` directly?"}
{"patch": "@@ -35,6 +39,10 @@ class SimplifiableCallChainInspection : AbstractCallChainChecker() {\n                         }\n                     ) return@check false\n                 }\n+                if (!conversion.enableSuspendFunctionCall && firstResolvedCall.call.callElement.anyDescendantOfType<KtCallExpression> {", "msg": "I would do something with the formatting here :)\r\nMaybe, extract the `firstResolvedCall.call.callElement.anyDescendantOfType()` call so the whole `if` condition fit into a single line?"}
{"patch": "@@ -18,7 +18,7 @@ fun kt6840_2(s: String?) {\n \n fun kt1635(s: String?) {\n     s?.hashCode()!!\n-    s.<!INAPPLICABLE_CANDIDATE!>hashCode<!>()\n+    s.<!UNSAFE_CALL!>hashCode<!>()", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44513"}
{"patch": "@@ -322,6 +329,22 @@ object FirConflictsChecker : FirBasicDeclarationChecker() {\n         }\n     }\n \n+    private fun checkBlock(body: FirBlock, inspector: DeclarationInspector) {\n+        for (it in body.statements) {\n+            when (it) {\n+                is FirVariable -> {\n+                    inspector.collect(it)\n+                }\n+\n+                is FirBlock -> {\n+                    checkBlock(it, inspector)", "msg": "Your test doesn't cover this case. Please extend the test sample."}
{"patch": "@@ -0,0 +1,14 @@\n+// WITH_STDLIB\n+// WITH_REFLECT\n+\n+operator fun Any?.getValue(x: Any?, y: Any?): String {\n+    return \"OK\"\n+}\n+const val a = 1", "msg": "Maybe also change the type to e.g. String in one of the tests, to check that not only integer types are supported. :)"}
{"patch": "@@ -138,6 +138,8 @@ object FirErrors {\n     val CATCH_PARAMETER_WITH_DEFAULT_VALUE by error0<FirSourceElement, PsiElement>()\n     val REIFIED_TYPE_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n     val TYPE_PARAMETER_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n+    val GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()\n+    val INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()", "msg": "Same for `PsiElement`. It's better to use `KtClassOrObject`: https://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/Errors.java#L179"}
{"patch": "@@ -68,6 +71,11 @@ class UselessCallOnCollectionInspection : AbstractUselessCallInspection() {\n             )\n             holder.registerProblem(descriptor)\n         } else {\n+            val fix = if (receiverType.constructor.declarationDescriptor?.fqNameSafe == KotlinBuiltIns.FQ_NAMES.list) {", "msg": "You need to check for both conditions. You should replace selector with `toList()` when `whole exp` == `List` && `receiver` != `List`. Now you only check for `receiver` != `List`. So your code doesn't work for `sequenceOf` (because whole expression has type Sequence, not List):\r\n```\r\nval arr: Sequence<Int> = sequenceOf(1, 2, 3).filterNotNull()\r\n```\r\nYes, we don't yet have \"Useless call\" check for sequences but your code will broke when we add it.\r\n\r\nSo I suggest to invert your if for improving readability and add full check."}
{"patch": "@@ -228,7 +228,16 @@ private val removeInlineFunctionsWithReifiedTypeParametersLoweringPhase = makeDe\n )\n \n private val throwableSuccessorsLoweringPhase = makeBodyLoweringPhase(\n-    ::ThrowableLowering,\n+    { context ->\n+        val extendThrowableSymbol = with(context) {", "msg": "`context.run { .. }`"}
{"patch": "@@ -571,51 +561,19 @@ open class FirDeclarationsResolveTransformer(transformer: FirAbstractBodyResolve\n                 transformer.firProviderInterceptor\n             )\n         }\n-        if (!implicitTypeOnly && anonymousObject.controlFlowGraphReference == null) {\n-            dataFlowAnalyzer.enterAnonymousObject(anonymousObject)\n-        } else {\n-            dataFlowAnalyzer.enterClass()\n-        }\n+        // TODO: why would there be a graph already?", "msg": "Most likely at this point this situation would never happen\n\nI'll add assertion and check if something fail"}
{"patch": "@@ -116,7 +112,14 @@ class SerializableIrGenerator(\n                 // for abstract classes fields MUST BE checked in child classes\n                 !serializableDescriptor.isAbstractSerializableClass() && !serializableDescriptor.isSealedSerializableClass()\n             ) {\n-                generateGoldenMaskCheck(seenVars, properties, getSerialDescriptorExpr())\n+                val getDescriptorExpr = if (serializableDescriptor.isStaticSerializable) {\n+                    getStaticSerialDescriptorExpr()\n+                } else {\n+                    // synthetic constructor creates only for internally serializable classes - so companion definitely exists", "msg": "```suggestion\r\n                    // synthetic constructor is created only for internally serializable classes - so companion definitely exists\r\n```"}
{"patch": "@@ -5,8 +5,9 @@\n \n package kotlin.test\n \n+@PublishedApi // called from inline assert functions\n internal fun messagePrefix(message: String?) = if (message == null) \"\" else \"$message. \"\n internal expect fun lookupAsserter(): Asserter\n \n @PublishedApi // required to get stable name as it's called from box tests\n-internal fun overrideAsserter(value: Asserter?): Asserter? = _asserter.also { _asserter = value }\n\\ No newline at end of file\n+internal fun overrideAsserter(value: Asserter?): Asserter? = _asserter.also { _asserter = value }", "msg": "\ud83d\ude2b will fix"}
{"patch": "@@ -93,3 +94,30 @@ internal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n     1 -> setOf(iterator().next())\n     else -> this\n }\n+\n+/**\n+ * Build a new read-only [Set] with the [elements][E] from the [builderAction].\n+ *\n+ * @sample samples.collections.Builders.Sets.buildSetSample\n+ */\n+@kotlin.internal.InlineOnly\n+@SinceKotlin(\"1.4\")\n+@Suppress(\"NEWER_VERSION_IN_SINCE_KOTLIN\", \"API_NOT_AVAILABLE\" /* See KT-30129 */) // TODO: remove this in 1.4", "msg": "You can use `@SinceKotlin(\"1.3\")` + `@ExperimentalStdlibApi`. This way new functions could be published in 1.3.x release"}
{"patch": "@@ -35,10 +35,14 @@ class KotlinCleanupInspectionTest() : KotlinLightCodeInsightFixtureTestCase() {\n         val profile = InspectionProjectProfileManager.getInstance(project).currentProfile\n         globalContext.codeCleanup(analysisScope, profile, \"Cleanup\", null, true)\n \n-        myFixture.checkResultByFile(result)\n+        myFixture.checkResultByFile(\"$dir/$result\")\n     }\n \n-    fun testCleanup() {\n-        doTest(\"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")\n+    fun testBasic() {", "msg": "You renamed `testCleanup` to `testBasic` but left `cleanup.kt` and `cleanup.kt.after` names. I guess they should be renamed to `basic.kt` and `basic.kt.after` as well"}
{"patch": "@@ -0,0 +1,34 @@\n+// !LANGUAGE: +RestrictionOfValReassignmentViaBackingField\n+\n+class Outer {\n+    val i: Int = 1\n+        get() {\n+            class Inner {\n+                var i: Int = 2\n+                    get() {\n+                        field++\n+                        return field\n+                    }\n+                val j: Int = 3\n+                    get() {\n+                        <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!> = 42\n+                        return field\n+                    }\n+\n+                fun innerMember() {\n+                    <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++\n+                }\n+            }\n+            return field\n+        }\n+\n+    val j: Int = 4\n+        get() {\n+            fun local() {\n+                <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++\n+                <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++", "msg": "FYI, this second report is the only thing that breaks `// FIR_IDENTICAL`"}
{"patch": "@@ -112,8 +116,8 @@ class InstantExecutionIT : BaseGradleIT() {\n      * found while caching the task graph.\n      */\n     private fun Project.instantExecutionReportFile() = projectDir\n-        .resolve(\".instant-execution-state\")\n-        .findFileByName(\"instant-execution-report.html\")\n+        .resolve(\"configuration-cache\")", "msg": "\u274c This path is still wrong. See my comments in the other PR at https://github.com/JetBrains/kotlin/pull/3521/files#r449659042\r\n\r\n\u2753 Is this function still used? With its current implementation it will always return `null` anyway"}
{"patch": "@@ -0,0 +1,69 @@\n+fun f() {\n+    call<>\n+    call<x>\n+    call<x.>", "msg": "Please, separate cases with error nodes (ones that are not assumed to be parsed) into a different file named `*_ERR.kt`\nDitto, for other tests inside `testData/psi`\n"}
{"patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.quickfix\n+\n+import com.intellij.codeInsight.intention.IntentionAction\n+import com.intellij.psi.PsiElement\n+import org.jetbrains.kotlin.idea.frontend.api.KtAnalysisSession\n+import kotlin.reflect.KClass\n+import kotlin.reflect.full.isSubclassOf\n+\n+// This is the same as QuickFixesPsiBasedFactory but KtAnalysisSession can be used in doCreateQuickFix().", "msg": "Can you turn this comment into a kdoc? Something like the following would make the referenced classes and methods clickable in the IDE.\n```\n/** This is the same as [QuickFixesPsiBasedFactory] but [KtAnalysisSession] can be used in [doCreateQuickFix]. */\n```"}
{"patch": "@@ -610,6 +610,22 @@ interface ClassicTypeSystemContext : TypeSystemInferenceExtensionContext, TypeSy\n         return IntegerLiteralTypeConstructor.findCommonSuperType(explicitSupertypes)\n     }\n \n+    override fun unionTypeAttributes(types: List<KotlinTypeMarker>): List<AnnotationMarker> {\n+        @Suppress(\"UNCHECKED_CAST\")\n+        types as List<KotlinType>", "msg": "It's more clean to write cast right inside recievier of `map` call. `(types as List<KotlinType>).map {...}...`"}
{"patch": "@@ -19,6 +21,35 @@ const val CLASS_STRUCTURE_ARTIFACT_TYPE = \"class-structure\"\n private const val MODULE_INFO = \"module-info.class\"\n \n abstract class StructureTransformAction : TransformAction<TransformParameters.None> {\n+    @get:InputArtifact\n+    abstract val inputArtifact: Provider<FileSystemLocation>\n+\n+    override fun transform(outputs: TransformOutputs) {\n+        try {\n+            val input = inputArtifact.get().asFile\n+\n+            val data = if (input.isDirectory) {\n+                visitDirectory(input)\n+            } else {\n+                visitJar(input)\n+            }\n+\n+            val dataFile = outputs.file(\"output.bin\")\n+            data.saveTo(dataFile)", "msg": "Extract this to a method to share between 2 transforms."}
{"patch": "@@ -67,7 +64,23 @@ internal class RangeToHandler(private val context: CommonBackendContext) :\n             if (preferJavaLikeCounterLoop || this.constLongValue == -1L) return null\n         }\n \n-        val irConst = this as? IrConst<*> ?: return null\n+        return when (this) {\n+            is IrConst<*> -> convertIrConst(this)\n+            is IrCall -> convertIrCall(this)\n+            else -> null\n+        }\n+    }\n+\n+    private fun convertIrCall(irCall: IrCall): IrExpression? {\n+        return if (irCall.origin == IrStatementOrigin.MINUS && (irCall.getValueArgument(0) as? IrConst<*>)?.value == 1)", "msg": "That might be a bit too optimistic because of possible underflow.\r\nPlease, add the following test:\r\n```\r\nfun box(): String {\r\n    val M1 = Int.MAX_VALUE - 2\r\n    val M2 = Int.MIN_VALUE\r\n    var t = 0\r\n    for (x in M1..M2-1) {\r\n        ++t\r\n        if (t > 3) return \"Failed: too many iterations\"\r\n    }\r\n    if (t != 3) return \"Failed: t=$t\"\r\n    return \"OK\"\r\n}\r\n```\r\nWe are not going to do proper value range analysis here. However, there are some relatively frequent practical cases when we know for sure that `expr - 1` will never underflow. In particular KT-22334 listed one such example (`array.size - 1`; can never underflow because `array.size` is always non-negative). Same is true about `collection.size` and `charSequence.size`."}
{"patch": "@@ -0,0 +1,152 @@\n+/*", "msg": "Another unnecessary copy-paste."}
{"patch": "@@ -339,6 +343,10 @@ class FirDefaultErrorMessages : DefaultErrorMessages.Extension {\n             map.put(ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_EQUALS, \"Replace '==' with 'Arrays.equals'\")\n             map.put(EMPTY_RANGE, \"Range is empty\")\n             map.put(REDUNDANT_SETTER_PARAMETER_TYPE, \"Redundant setter parameter type\")\n+            map.put(UNUSED_VARIABLE, \"Unused variable\")\n+            map.put(ASSIGNED_VALUE_IS_NEVER_READ, \"Assigned value is never read\")\n+            map.put(VARIABLE_INITIALIZER_IS_REDUNDANT, \"Initialized is redundant\")", "msg": "Initializer is redundant (typo)"}
{"patch": "@@ -0,0 +1,40 @@\n+// CORRECT_ERROR_TYPES\n+// STRICT\n+\n+//FILE: test/ClassRefAnnotation.java\n+\n+package test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.annotation.ElementType;\n+\n+@Target({ ElementType.TYPE, ElementType.METHOD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ClassRefAnnotation {\n+    Class<?>[] value();\n+}\n+\n+//FILE: a.kt", "msg": "I would also add tests with the `correctErrorTypes` option being enabled."}
{"patch": "@@ -125,15 +127,6 @@ object RedundantVisibilityModifierChecker : FirBasicDeclarationChecker() {\n     private val CheckerContext.containingPropertyVisibility\n         get() = (this.containingDeclarations.last() as? FirProperty)?.visibility\n \n-    private val FirSourceElement?.modifierSource: FirSourceElement?\n-        get() = when (this) {\n-            null -> null\n-            is FirPsiSourceElement<*> -> (psi as? KtModifierListOwner)?.modifierList?.visibilityModifier()?.toFirPsiSourceElement()\n-            is FirLightSourceElement -> {\n-                val modifier = this.getModifierList()?.modifiers?.firstOrNull { it.isVisibilityModifier }\n-                modifier?.source\n-            }\n-        }\n \n     private val FirModifier<*>.isVisibilityModifier", "msg": "`isVisiblityModifier` is also unused now"}
{"patch": "@@ -262,13 +318,17 @@ internal abstract class HeaderInfoBuilder(context: CommonBackendContext, private\n     private val symbols = context.ir.symbols\n \n     // TODO: Include unsigned types\n-    private val progressionElementTypes = listOf(\n-        context.irBuiltIns.byteType,\n-        context.irBuiltIns.shortType,\n-        context.irBuiltIns.intType,\n-        context.irBuiltIns.longType,\n-        context.irBuiltIns.charType\n-    )\n+    private val progressionElementTypes = listOfNotNull(", "msg": "I suppose the TODO above is fixed"}
{"patch": "@@ -37,6 +37,20 @@ class FirSpecificTypeResolverTransformer(\n         }\n     }\n \n+    @set:PrivateForInline\n+    var isOperandOfIsOperator: Boolean = false\n+\n+    @OptIn(PrivateForInline::class)\n+    inline fun <R> withisOperandOfIsOperator(block: () -> R): R {", "msg": "Nit: Capitalize \"I\" in first \"is\""}
{"patch": "@@ -63,7 +63,7 @@ fun case3() {\n  */\n fun case4(marker : Marker?) {\n     marker?.<!DEBUG_INFO_CALL(\"fqName: libPackage.Marker.foo; typeCall: function\")!>foo(y=1)<!>\n-    marker?.<!DEBUG_INFO_CALL(\"fqName: libPackage.Marker.invoke; typeCall: variable&invoke\")!>foo(x=1)<!><!INAPPLICABLE_CANDIDATE!>><!><!SYNTAX!><!>\n+    marker?.<!DEBUG_INFO_CALL(\"fqName: libPackage.Marker.invoke; typeCall: variable&invoke\")!>foo(x=1)<!><!UNSAFE_CALL!>><!><!SYNTAX!><!>", "msg": "This one and one more below are rather resolution errors. It should be `tests.foo`, instead of these `invoke`.\r\n\r\nThe original issue was: https://youtrack.jetbrains.com/issue/KT-37391"}
{"patch": "@@ -11,7 +11,7 @@ import java.lang.StringBuilder\n object CodeMetaInfoParser {\n     private val openingRegex = \"\"\"<!([^>][^\"]*?((\".*?\")(, \".*?\")*?)?[^\"]*?)!>\"\"\".toRegex()\n     private val closingRegex = \"<!>\".toRegex()\n-    private val commentRegex = \"\"\"(//[^\\r\\n]*)|(/\\*(.*?)\\*/)\"\"\".toRegex(RegexOption.DOT_MATCHES_ALL)\n+    private val commentRegex = \"\"\"/\\*(.*?)\\*/\"\"\".toRegex(RegexOption.DOT_MATCHES_ALL)", "msg": "Please squash this commit with first one before pushing"}
{"patch": "@@ -92,7 +92,7 @@ abstract class DataClassMembersGenerator(\n             // data classes and corresponding properties can be non-final.\n             // We should use getters for such properties (see KT-41284).\n             val backingField = property.backingField\n-            return if (!forbidDirectFieldAccess && property.modality == Modality.FINAL && backingField != null) {\n+            return if (!forbidDirectFieldAccess && irClass.isFinalClass && backingField != null) {", "msg": "Could you please comment this change? It influences not only K2 but also K1, so it's not so clear for me."}
{"patch": "@@ -89,11 +90,9 @@ abstract class AbstractKotlinNativeTargetPreset<T : KotlinNativeTarget>(\n         createTargetConfigurator().configureTarget(result)\n \n         SingleActionPerProject.run(project, \"setUpKotlinNativePlatformDependencies\") {\n-            project.gradle.addListener(object : BuildAdapter() {\n-                override fun projectsEvaluated(gradle: Gradle) {\n-                    project.setUpKotlinNativePlatformDependencies()\n-                }\n-            })\n+            project.gradle.projectsEvaluated {", "msg": "\ud83d\udc4d "}
{"patch": "@@ -62,8 +67,9 @@ internal class AnnotationEntryReplacementPerformer(\n         assert(range.first == range.last)\n         assert(range.first is KtAnnotationEntry)\n         val annotationEntry = range.first as KtAnnotationEntry\n-        val text = annotationEntry.valueArguments.single().getArgumentExpression()!!.text\n-        return annotationEntry.replaced(psiFactory.createAnnotationEntry(\"@$text\"))\n+        val text = \"@${useSiteTargetText}${annotationEntry.valueArguments.single().getArgumentExpression()!!.text}\"\n+        val newAnnotationEntry = if (isFileUseSiteTarget) psiFactory.createFileAnnotation(text) else psiFactory.createAnnotationEntry(text)\n+        return annotationEntry.replaced(newAnnotationEntry)", "msg": "```suggestion\r\n        val text = annotationEntry.valueArguments.single().getArgumentExpression()!!.text\r\n        val newAnnotationEntry = if (isFileUseSiteTarget)\r\n            psiFactory.createFileAnnotation(text)\r\n        else\r\n            psiFactory.createAnnotationEntry(\"@$useSiteTargetText$text\")\r\n        return annotationEntry.replaced(newAnnotationEntry)\r\n```"}
{"patch": "@@ -199,8 +200,22 @@ val IrClass.primaryConstructor: IrConstructor?\n val IrDeclarationContainer.properties: Sequence<IrProperty>\n     get() = declarations.asSequence().filterIsInstance<IrProperty>()\n \n+fun IrFunction.addExplicitParametersTo(parametersList: MutableList<IrValueParameter>) {\n+    parametersList.addIfNotNull(dispatchReceiverParameter)\n+    parametersList.addIfNotNull(extensionReceiverParameter)\n+    parametersList.addAll(valueParameters)\n+}\n+\n+internal fun Boolean.toInt(): Int = if (this) 1 else 0\n+\n+val IrFunction.explicitParametersNumber: Int\n+    get() = (dispatchReceiverParameter != null).toInt() + (extensionReceiverParameter != null).toInt() +\n+            valueParameters.size\n+\n val IrFunction.explicitParameters: List<IrValueParameter>\n-    get() = (listOfNotNull(dispatchReceiverParameter, extensionReceiverParameter) + valueParameters)\n+    get() = ArrayList<IrValueParameter>(valueParameters.size + 2).also {", "msg": "(Not sure if it makes sense but) now it is easy to use exact size here. Same for `allParameters`."}
{"patch": "@@ -153,6 +153,20 @@ abstract class BaseGradleIT {\n             return wrapper\n         }\n \n+        fun mightUpdateSettingsScript(wrapperVersion: String, settingsScript: File) {\n+            // enableFeaturePreview(\"GRADLE_METADATA\") is no longer needed when building with Gradle 5.4 or above\n+            if (GradleVersion.version(wrapperVersion) > GradleVersion.version(\"5.3\")) {", "msg": "Change to \"version>= 5.4\"."}
{"patch": "@@ -39,12 +38,12 @@ class SamConversionToAnonymousObjectIntention : SelfTargetingRangeIntention<KtCa\n         val callee = element.calleeExpression ?: return null\n         val lambda = getLambdaExpression(element) ?: return null\n         val functionLiteral = lambda.functionLiteral\n-        val descriptor = (functionLiteral.descriptor as? FunctionDescriptor) ?: return null\n         val bindingContext = functionLiteral.analyze()\n         val sam = element.getSingleAbstractMethod(bindingContext) ?: return null\n \n         val samValueParameters = sam.valueParameters\n         val samValueParameterSize = samValueParameters.size\n+        val descriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, functionLiteral] as? FunctionDescriptor ?: return null", "msg": "You are reusing `bindingContext` here, but in the `applyTo` you are still using `descriptor` extension. What is the reason for that"}
{"patch": "@@ -153,6 +153,26 @@ private class NoExplicitReceiverScopeTowerProcessor<C : Candidate>(\n             ExplicitReceiverKind.NO_EXPLICIT_RECEIVER,\n             data.implicitReceiver\n         )\n+        is TowerData.BothTowerLevelAndContextReceiversGroup -> {\n+            val groupsOfDuplicateCandidates = data.contextReceiversGroup.flatMap { receiver ->", "msg": "Please, add `BothTowerLevelAndContextReceiversGroup` case to the when at `recordLookups` below, too"}
{"patch": "@@ -465,12 +491,12 @@ internal class ObjCExportNamerImpl(\n             parameters.forEachIndexed { index, (bridge, it) ->\n                 val name = when (bridge) {\n                     is MethodBridgeValueParameter.Mapped -> when {\n-                        it is ReceiverParameterDescriptor -> \"\"\n+                        it is ReceiverParameterDescriptor -> it.getObjCName().asIdentifier(false) { \"\" }\n                         method is PropertySetterDescriptor -> when (parameters.size) {", "msg": "(Possible future improvement:)\r\nIn certain cases Kotlin property accessors are translated to methods. In this case, `@ObjCName` can be applied to the setter parameter but likely has no effect."}
{"patch": "@@ -267,8 +260,11 @@ internal class NativeIndexImpl(val library: NativeLibrary, val verbose: Boolean\n                     }\n                     fieldCursor.type.kind == CXType_Record -> {\n                         // TODO: clang_Cursor_getOffsetOfField is OK for anonymous, but only for the 1st level of such nesting\n+                        val declCursor = clang_getTypeDeclaration(fieldCursor.type)\n                         AnonymousInnerRecord(\n-                                convertCursorType(fieldCursor) as RecordType,\n+                                RecordType(createStructDecl(declCursor).also {", "msg": "This looks better, but still `StructDecl` (and `RecordType`) seems kinda useless here, and it should be pretty easy to get rid of.\r\n\r\n`findNamedParent` still looks redundant: why do we need to _find_ parent, if we already _know_ it? I mean, for the root struct it is the struct itself, and for nested anonymous structs we know the exact parent here.\r\nAlternatively, we could also make parents unnecessary, if we stopped using the root struct as the base for field offsets (which also makes some sense). But I believe this might depend on the way other issues are handled."}
{"patch": "@@ -270,20 +275,33 @@ class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransformer) :\n             return when {\n                 operatorCallReference == null || (!lhsIsVar && !assignIsError) -> resolvedAssignCall.compose()\n                 assignCallReference == null -> {\n-                    val assignment =\n-                        buildVariableAssignment {\n+                    if (leftArgument is FirFunctionCall && leftArgument.calleeReference.source?.psi is KtArrayAccessExpression) {\n+                        val setCall = buildFunctionCall {", "msg": "I'm not quite sure here, but may be in this case we should create function call from the beginning (I mean, in raw FIR)?"}
{"patch": "@@ -33,3 +30,7 @@ fun KotlinGradleModule.createExternalJvmVariant(\n @ExternalVariantApi\n val KotlinGradleVariantInternal.compilationData\n     get() = this.compilationData\n+\n+@ExternalVariantApi\n+val KotlinGradleFragment.external: KotlinMutableExternalModelContainer", "msg": "IMHO an API where there is just a registry of `AdditionalDataProvider<T, Key<T>>` may express the intention in a nicer way. Then, the registry is realized during model building and adding new providers will fail (as a safety check)."}
{"patch": "@@ -106,6 +106,18 @@ object FirMemberPropertyChecker : FirRegularClassChecker() {\n                 }\n             }\n         }\n+", "msg": "I'd integrate this in `FirInlineClassDeclarationChecker`."}
{"patch": "@@ -456,7 +457,12 @@ fun FirPropertyBuilder.generateAccessorsByDelegate(\n fun FirTypeRef.convertToArrayType(): FirUserTypeRef = buildUserTypeRef {\n     source = this@convertToArrayType.source\n     isMarkedNullable = false\n-    qualifier += FirQualifierPartImpl(StandardClassIds.Array.shortClassName).apply {\n+    val elementType = this@convertToArrayType as? FirUserTypeRef\n+    val arrayQualifier =\n+        if (elementType != null && elementType.qualifier.size == 1)", "msg": "I would say that this change might be not enough.\r\nFor example, it's not gonna work in case it has a form of `vararg x: kotlin.Int` or `vararg x: MyTypeAliasToInt`.\r\nMaybe it's worth trying to move this logic to `org.jetbrains.kotlin.fir.resolve.transformers.FirTypeResolveTransformer#transformValueParameter` when the type is already resolved properly and we can just use it without guessing\r\n\r\nBTW, something similar is already happening there at `result.transformVarargTypeToArrayType()`.\r\nLooks like we have similar logic in two different places and I would say it's worth investigating which one should work for all cases."}
{"patch": "@@ -19,13 +19,18 @@ public actual inline fun <R> synchronized(lock: Any, block: () -> R): R {\n         callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n     }\n \n+    // Force the lock object into a local and use that local for monitor enter/exit.\n+    // This ensures that the JVM can prove that locking is balanced which is a\n+    // prerequisite for using fast locking implementations. See KT-48367 for details.\n+    val lockLocal = lock", "msg": "Super minor, but do we usually name something like `localLock`? :)"}
{"patch": "@@ -548,6 +548,7 @@ object Filtering : TemplateGroupBase() {\n         specialFor(ArraysOfUnsigned) { inlineOnly() }\n \n         doc { \"Returns a ${f.mapResult} containing only ${f.element.pluralize()} matching the given [predicate].\" }\n+        sample(\"samples.collections.Collections.Filtering.filter\")", "msg": "Have you run stdlib code generation after that? It should affect array `filter` extension too. "}
{"patch": "@@ -1,4 +1,3 @@\n-// IGNORE_BACKEND_FIR: JVM_IR", "msg": "This is probably not related to this PR, looks like someone forgot to update the expected data for this test."}
{"patch": "@@ -0,0 +1,86 @@\n+// TARGET_BACKEND: JVM_IR\n+\n+// WITH_STDLIB\n+\n+import kotlinx.serialization.*\n+import kotlinx.serialization.descriptors.*\n+import kotlinx.serialization.encoding.*\n+import kotlinx.serialization.json.*\n+import kotlin.reflect.KProperty\n+import kotlin.properties.*\n+\n+@Serializable\n+data class SimpleDTO(\n+    val realProp: Int,\n+) {\n+    @Transient\n+    private val additionalProperties: Map<String, Int> = mapOf(\"delegatedProp\" to 123)\n+    @Transient", "msg": "I think `@Transient` shouldn't be here, as delegated property is transient automatically? At least it works without it."}
{"patch": "@@ -0,0 +1,7 @@\n+class Foo {", "msg": "Move this file to [compiler/testData/diagnostics/tests/redeclarations](https://github.com/JetBrains/kotlin/tree/4737bb07dfa131d4167ae9fe0966c48ce11268c0/compiler/testData/diagnostics/tests/redeclarations). Rename it to `RedeclaratedVals.kt` (don't use `k2` prefix/suffix for test data since it's used in both frontends)."}
{"patch": "@@ -38,7 +38,11 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@ThreadLocal is applicable only to property with backing field, to property with delegation or to objects\"\n         )\n         put(ErrorsNative.INAPPLICABLE_THREAD_LOCAL_TOP_LEVEL, \"@ThreadLocal is applicable only to top level declarations\")\n-        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING);\n+        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING)\n+        put(ErrorsNative.INAPPLICABLE_OBJC_NAME, \"@ObjCName is not applicable on overrides\")\n+        put(ErrorsNative.INVALID_OBJC_NAME, \"@ObjCName should have a name and/or swiftName\")\n+        put(ErrorsNative.INVALID_CHARACTERS_OBJC_NAME, \"@ObjCName contains illegal characters: \\\"{0}\\\"\", CommonRenderers.STRING)\n+        put(ErrorsNative.INCOMPATIBLE_OBJC_NAME_OVERRIDE, \"Member inherits inconsistent @ObjCName\")", "msg": "This error message should also mention the types incompatible `@ObjCName` were inherited from."}
{"patch": "@@ -70,6 +76,17 @@ class KotlinCleanupInspection : LocalInspectionTool(), CleanupLocalInspectionToo\n         return problemDescriptors.toTypedArray()\n     }\n \n+    private fun KtFile.hasSuppressDeprecationAnnotation(): Boolean {\n+        val suppressAnnotationEntry = annotationEntries.firstOrNull {\n+            it.shortName?.asString() == \"Suppress\"\n+                    && it.resolveToCall()?.resultingDescriptor?.containingDeclaration?.fqNameSafe == KotlinBuiltIns.FQ_NAMES.suppress\n+        } ?: return false\n+        return suppressAnnotationEntry.valueArguments.any {\n+            val text = (it.getArgumentExpression() as? KtStringTemplateExpression)?.entries?.firstOrNull()?.text ?: return@any false", "msg": "> firstOrNull()\r\n\r\n\"singeOrNull\" seems safer option for me"}
{"patch": "@@ -134,7 +143,7 @@ class Strings {\n     fun associateByWithValueTransform() {\n         val string = \"bonne journ\u00e9e\"\n         // associate each character by the code of its upper case equivalent and transform the character to upper case\n-        val result = string.associateBy({ char -> char.toUpperCase().toInt() }, { char -> char.toUpperCase() })\n+        val result = string.associateBy({ char -> char.uppercaseChar().toInt() }, { char -> char.uppercaseChar() })", "msg": "revert"}
{"patch": "@@ -0,0 +1,7 @@\n+// COMPILER_ARGUMENTS: -XXLanguage:+MixedNamedArgumentsInTheirOwnPosition\n+\n+fun foo(name1: Int, name2: Int, name3: Int) {}\n+\n+fun usage() {", "msg": "It seems like there are missing test when `MixedNamedArgumentsInTheirOwnPosition` is enabled, but the arguments are not in their own positions, and the intention should be disabled\r\n\r\nWith your code, this case will look like `foo(1, <caret>name3 = 3, name2 = 2)`\r\n"}
{"patch": "@@ -8,11 +8,65 @@ package kotlin.text\n // actually \\s is enough to match all whitespace, but \\xA0 added because of different regexp behavior of Rhino used in Selenium tests\n public actual fun Char.isWhitespace(): Boolean = toString().matches(\"[\\\\s\\\\xA0]\")\n \n+/**\n+ * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n+ *\n+ * This function performs one-to-one character mapping using case mapping information from the UnicodeData.txt file,\n+ * to support one-to-many character mapping use the [lowercase] function.\n+ * If this character has no mapping equivalent, the character itself is returned.\n+ *\n+ * @sample samples.text.Chars.lowercase\n+ */\n+@SinceKotlin(\"1.4\")\n+@ExperimentalStdlibApi\n+@kotlin.internal.InlineOnly\n+public actual inline fun Char.lowercaseChar(): Char = js(\"String.fromCharCode\")(toInt()).toLowerCase().charCodeAt(0).unsafeCast<Int>().toChar()", "msg": "The only case (`'\u0130'`) where `lowercase.length > 1` the first char (`'i'`) of the `lowercase` is the correct 1-to-1 mapping equivalent."}
{"patch": "@@ -948,7 +951,7 @@ abstract class AbstractAndroidProjectHandler(private val kotlinConfigurationTool\n \n     private val BaseVariant.javaTaskProvider: TaskProvider<out AbstractCompile>\n         get() = getJavaTaskProvider()\n-            // for older versions, get the task instance and wrap it into a TaskProvider\n+        // for older versions, get the task instance and wrap it into a TaskProvider\n             ?: getJavaTask(this).let { it.project.tasks.withType(AbstractCompile::class.java).named(it.name) }", "msg": "if we use gradle 5.1 apis, this can be shortened to `named(Class, String)`. Or we need to keep using this \"old\" api because this case is a backward compatibility case ?"}
{"patch": "@@ -351,6 +351,7 @@ open class DeepCopyIrTreeWithSymbols(\n             declaration.varargElementType?.remapType(),\n             declaration.isCrossinline,\n             declaration.isNoinline,\n+            declaration.isHidden,", "msg": "This was the bug. declaration.isAssignable was passed in the isHidden position."}
{"patch": "@@ -19,82 +19,102 @@ interface NpmDependencyExtension {\n     operator fun invoke(directory: File): NpmDependency\n }\n \n-fun Project.addNpmDependencyExtension() {\n-    val dependencies = this.dependencies as ExtensionAware\n-\n-    val npmDependencyExtension: NpmDependencyExtension = object : NpmDependencyExtension, Closure<NpmDependency>(dependencies) {\n-        override operator fun invoke(name: String, version: String): NpmDependency =\n-            NpmDependency(\n-                project = this@addNpmDependencyExtension,\n-                name = name,\n-                version = version\n-            )\n+private abstract class AbstractNpmDependencyExtension(\n+    dependencies: ExtensionAware,", "msg": "Seems that `dependencies` is not needed in constructor, it can been calculated from `project`"}
{"patch": "@@ -247,7 +264,7 @@ class IrCustomParcelSerializer(private val parcelerObject: IrClass) : IrParcelSe\n class IrArrayParcelSerializer(\n     private val arrayType: IrType,\n     private val elementType: IrType,\n-    private val elementSerializer: IrParcelSerializer\n+    private val elementSerializer: IrParcelSerializer,", "msg": "Please revert this change."}
{"patch": "@@ -434,6 +434,35 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com\n     return -(low + 1)  // key not found\n }\n \n+/**\n+ * If this list starts with the given [prefix], returns a view of the portion of this list without [prefix].\n+ * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n+ *\n+ * Structural changes in the base list make the behavior of the view undefined.\n+ */\n+public fun <T> List<T>.removePrefix(prefix: List<T>): List<T> {\n+    return if (this.startWith(prefix)) {\n+        this.subList(prefix.size, this.size)\n+    } else {\n+        this\n+    }\n+}\n+\n+/**\n+ * Returns `true` if this list starts with the specified prefix.\n+ *\n+ * For empty [prefix] returns true\n+ */\n+public fun <T> List<T>.startWith(prefix: List<T>): Boolean {", "msg": "Shouldn't this be \"startsWith\", to be consistent with the current implementation for String?"}
{"patch": "@@ -305,7 +305,6 @@ class FirMemberDeserializer(private val c: FirDeserializationContext) {\n                 isOverride = false\n                 isConst = Flags.IS_CONST.get(flags)\n                 isLateInit = Flags.IS_LATEINIT.get(flags)\n-                isInline = Flags.IS_INLINE.get(flags)", "msg": "Why inline flag shouldn't be loaded?"}
{"patch": "@@ -162,7 +164,16 @@ abstract class StructDef(val size: Long, val align: Int, val decl: StructDecl) {\n     abstract val members: List<StructMember>\n     abstract val kind: Kind\n \n-    val fields: List<Field> get() = members.filterIsInstance<Field>()\n+    val fields: List<Field> get() {\n+        val result = mutableListOf<Field>()\n+        members.forEach {\n+            when (it) {\n+                is Field -> result.add(it)\n+                is AnonymousInnerRecord -> result.addAll((it.type as RecordType).decl.def!!.fields)\n+            }\n+        }\n+    return result", "msg": "Wrong indent?"}
{"patch": "@@ -29,13 +29,13 @@ internal open class JDK8PlatformImplementations : JDK7PlatformImplementations()\n     override fun getMatchResultNamedGroup(matchResult: MatchResult, name: String): MatchGroup? {\n         val matcher = matchResult as? Matcher ?: throw UnsupportedOperationException(\"Retrieving groups by name is not supported on this platform.\")\n \n-        val range = matcher.start(name)..matcher.end(name) - 1\n-        return if (range.start >= 0)\n+        val range = matcher.start(name) until matcher.end(name)\n+        return if (range.first >= 0) {\n             MatchGroup(matcher.group(name), range)\n-        else\n+        } else\n             null\n     }", "msg": "This change should be in a separate commit, or even better, in a separate PR."}
{"patch": "@@ -143,6 +143,7 @@ internal fun IrFunction.shouldContainSuspendMarkers(): Boolean = !isInvokeSuspen\n         // These are tail-call bridges and do not require any bytecode modifications.\n         origin != IrDeclarationOrigin.FUNCTION_FOR_DEFAULT_PARAMETER &&\n         origin != JvmLoweredDeclarationOrigin.JVM_OVERLOADS_WRAPPER &&\n+        origin != JvmLoweredDeclarationOrigin.JVM_STATIC_WRAPPER &&", "msg": "Something tells me it might be a good time to introduce a `Set` of origins here"}
{"patch": "@@ -111,10 +111,46 @@ class ForLoopsLowering(val context: CommonBackendContext) : BodyLoweringPass {\n     }\n }\n \n+/**\n+ * Abstract class for additional for-loop bodies transformations.\n+ */\n+abstract class ForLoopBodyTransformer : IrElementTransformerVoid() {\n+    protected lateinit var mainLoopVariable: IrVariable\n+    protected lateinit var loopHeader: ForLoopHeader\n+    protected lateinit var loopVariableComponents: Map<Int, IrVariable>\n+    protected lateinit var context: CommonBackendContext\n+\n+    open fun initialize(\n+        context: CommonBackendContext,\n+        loopVariable: IrVariable,\n+        forLoopHeader: ForLoopHeader,\n+        loopComponents: Map<Int, IrVariable>\n+    ) {\n+        this.context = context", "msg": "Maybe you could move this initialization over to `transform` and change this function to `abstract fun analyze(forLoopHeader: ForLoopHeader)`. That way subclasses don't need to remember to call `super.initialize(...)` and also you only need the `ForLoopHeader` for now in `KonanBCEForLoopBodyTransformer`."}
{"patch": "@@ -141,4 +176,22 @@ object FirExposedVisibilityChecker : FirDeclarationChecker<FirMemberDeclaration>\n             identifier?.toFirLightSourceElement(this.tree.getStartOffset(identifier), this.tree.getEndOffset(identifier), this.tree)\n         }\n     }\n+\n+    private fun FirRegularClass.getSupertypeSources(): List<FirSourceElement>? {\n+        when (val source = this.source) {", "msg": "All this code is too nightmarish to leave it. I took source just from `superTypeRef`. It contradicts with old front-end at some point, e.g. reports on `Base` instead of `Base()`, but at this point it looks even more correct."}
{"patch": "@@ -267,10 +267,12 @@ public abstract class Random {\n      *\n      * @sample samples.random.Randoms.defaultRandom\n      */\n-    companion object Default : Random() {\n-\n+    companion object Default : Random(), Serializable {\n+        private const val serialVersionUID = 6449517406788167720L", "msg": "I still don't get what bad can happen if we set `serialVersionUID = 1L` in all such classes?"}
{"patch": "@@ -221,7 +221,7 @@ class JvmSymbols(\n                 addValueParameter(\"completion\", continuationType.makeNullable())\n             }\n             klass.addFunction(\"invokeSuspend\", irBuiltIns.anyNType, Modality.ABSTRACT).apply {\n-                addValueParameter(\"result\", resultClassStub.typeWith(irBuiltIns.anyNType))\n+                addValueParameter(\"\\$result\", resultClassStub.typeWith(irBuiltIns.anyNType))", "msg": "I somehow missed it. Thanks!\r\nMinor: there is `SUSPEND_CALL_RESULT_NAME`, which, in fact, I should've used."}
{"patch": "@@ -1,5 +1,5 @@\n class My {\n-    var x: String = \"\"\n+    var x: <!WRONG_SETTER_PARAMETER_TYPE!>String<!> = \"\"", "msg": "This report seems not right either: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/varargs/varargInSetter.kt#L2"}
{"patch": "@@ -485,18 +618,45 @@ interface IrBuilderExtension {\n         return defaultsMap + extractDefaultValuesFromConstructor(irClass.getSuperClassNotAny())\n     }\n \n-    fun buildInitializersRemapping(irClass: IrClass): (IrField) -> IrExpression? {\n+    /*\n+    Creates an initializer adapter function that can replaces IR expressions of getting constructor parameter value by some other expression.", "msg": "```suggestion\r\n    Creates an initializer adapter function that can replace IR expressions of getting constructor parameter value by some other expression.\r\n```"}
{"patch": "@@ -26,7 +26,7 @@ fun testSpilling(x: Any?) {\n         myAssert(x is String)\n         x.length\n     }\n-    x.<!UNRESOLVED_REFERENCE!>length<!>\n+    x<!UNSAFE_CALL!>.<!>length", "msg": "This one seems interesting. From the path that passed through `if`, `x is String`. From the synthetic `else`, `x == null` (or `x is Nothing?`). After type `or`ing, now `x is String?`. :\\\r\n\r\nI updated `isAcceptableForSmartcast` accordingly, but seems not good enough. I expect type `or` also needs to drop `Nothing?` at every step?"}
{"patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.descriptors.impl\n+\n+import org.jetbrains.kotlin.descriptors.ModuleCapability\n+import org.jetbrains.kotlin.descriptors.PackageViewDescriptor\n+import org.jetbrains.kotlin.name.FqName\n+import org.jetbrains.kotlin.storage.StorageManager\n+\n+interface PackageViewDescriptorAccessor {", "msg": "The name like `PackageViewDescriptor` seems to be more clear to me, but I don't insist here"}
{"patch": "@@ -751,6 +752,11 @@ class ClassFileToSourceStubConverter(val kaptContext: KaptContextForStubGenerati\n         val value = field.value\n \n         val origin = kaptContext.origins[field]\n+        val isConstantValue = when (val declaration = origin?.element) {\n+            is KtProperty -> declaration.hasModifier(KtTokens.CONST_KEYWORD)", "msg": "This is effectively a breaking change, so I'm wondering if we should treat:\r\n- `const`\r\n- any kind of primitive + String values for a `val`\r\nas constants and inline them?\r\n\r\nThis ensures existing users do not break."}
{"patch": "@@ -30,5 +30,11 @@ enum class DiagnosticKind {\n     UnknownCallableKind,\n     IllegalProjectionUsage,\n     MissingStdlibClass,\n-    Other\n+    Other,", "msg": "Minor: I'd leave Other at the end"}
{"patch": "@@ -76,6 +77,10 @@ class NewCallableReferenceResolvedCall<D : CallableDescriptor>(\n         extensionReceiver = extensionReceiver?.replaceType(newType)\n     }\n \n+    override fun updateContextReceiverTypes(newTypes: List<KotlinType>) {\n+        return", "msg": "Put `TODO: Update context receivers`"}
{"patch": "@@ -0,0 +1,32 @@\n+value class BackingFields(val x: Int) {\n+    <!PROPERTY_WITH_BACKING_FIELD_INSIDE_INLINE_CLASS!>val y<!> = 0\n+    var z: String\n+        get() = \"\"\n+        set(value) {}\n+}\n+\n+class Val {\n+    operator fun getValue(thisRef: Any?, kProp: Any?) = 1\n+}\n+inline class DelegatedProp(val x: Int) {\n+    val testVal by <!DELEGATED_PROPERTY_INSIDE_INLINE_CLASS!>Val()<!>\n+}\n+\n+inline class ReversedMembers(val x: Int) {\n+    <!RESERVED_MEMBER_INSIDE_INLINE_CLASS{LT}!>fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS{PSI}!>box<!>() {}<!>", "msg": "DECLARATION_NAME light tree positioning strategy works erroneously here. I will fix this problem myself."}
{"patch": "@@ -7,5 +7,5 @@ abstract class A(val s: String) {\n fun foo(o: String?): Int {\n     val a = object : A(o!!){}\n     a.bar()\n-    return o.<!INAPPLICABLE_CANDIDATE!>length<!>\n+    return o.<!UNSAFE_CALL!>length<!>", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44515"}
{"patch": "@@ -305,51 +309,33 @@ class MethodInliner(\n                     inlineOnlySmapSkipper?.markCallSiteLineNumber(remappingMethodAdapter)\n                 } else if (isAnonymousConstructorCall(owner, name)) { //TODO add method\n                     //TODO add proper message\n-                    assert(transformationInfo is AnonymousObjectTransformationInfo) {\n+                    var info = transformationInfo as? AnonymousObjectTransformationInfo ?: throw AssertionError(\n                         \"<init> call doesn't correspond to object transformation info for '$owner.$name': $transformationInfo\"\n+                    )\n+                    val ownerIsParentClass = inlineCallSiteInfo.ownerClassName == info.oldClassName", "msg": "maybe smth like `isRecreatesItself`?"}
{"patch": "@@ -21,11 +21,11 @@ fun test() {\n     val platformJ = J.staticJ\n \n     platformNN[0]\n-    <!INAPPLICABLE_CANDIDATE!>platformN[0]<!>\n+    <!UNSAFE_CALL!>platformN[0]<!>\n     platformJ[0]\n \n     platformNN[0] = 1\n-    <!INAPPLICABLE_CANDIDATE!>platformN[0]  = 1<!>\n+    <!UNSAFE_CALL!>platformN[0]  = 1<!>", "msg": "For the record. In addition to `.`, this is another place where the diagnostic positioning matters: it should be array access."}
{"patch": "@@ -0,0 +1,7 @@\n+fun foo(a: suspend () -> Unit) {}", "msg": "By default this conversion will lead to red code, because currently it is disabled\r\n\r\nPlease enable it with this\r\n\r\n```suggestion\r\n// COMPILER_ARGUMENTS: -XXLanguage:+SuspendConversion\r\nfun foo(a: suspend () -> Unit) {}\r\n```"}
{"patch": "@@ -0,0 +1,50 @@\n+// SKIP_TXT\n+\n+import kotlin.contracts.*\n+\n+class C(val x: Int)\n+\n+@OptIn(ExperimentalContracts::class)\n+fun isNotNullAlsoCall(a: String?, b: () -> Unit): Boolean {\n+    contract {\n+        returns(true) implies (a != null)\n+        callsInPlace(b, InvocationKind.EXACTLY_ONCE)\n+    }\n+    b()\n+    return a != null\n+}\n+\n+fun binaryBooleanExpression() {\n+    var x: String? = \"\"\n+    if (x is String || (x is String).also { x = null }) {\n+        x<!UNSAFE_CALL!>.<!>length // bad (x#0 is String, x#1 is Nothing?, this is either)\n+    }\n+}\n+\n+fun unoverriddenEquals(a: Any?) {\n+    val c = C(1)\n+    var b: Any?\n+    b = c\n+    if (b == c.also { b = a }) {\n+        a.x // bad (b#0 is C, b#1 = a)", "msg": "I've created [KT-55096](https://youtrack.jetbrains.com/issue/KT-55096) to track this problem"}
{"patch": "@@ -22,16 +22,19 @@ import org.jetbrains.kotlin.fir.types.coneType\n import org.jetbrains.kotlin.lexer.KtTokens\n import org.jetbrains.kotlin.psi.KtBinaryExpression\n import org.jetbrains.kotlin.psi.KtNameReferenceExpression\n+import org.jetbrains.kotlin.psi.KtOperationReferenceExpression\n \n object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVariableAssignment>() {", "msg": "Also it's better to inherit from `FirVariableAssignmentChecker` alias"}
{"patch": "@@ -139,7 +139,7 @@ abstract class KotlinLibrarySearchPathResolver<L : KotlinLibrary>(\n             val matching = fileSequence\n                 .filterOutPre_1_4_libraries()\n                 .flatMap { libraryComponentBuilder(it, isDefaultLink).asSequence() }\n-                .map { it.takeIf { libraryMatch(it, unresolved) } }\n+                //.map { it.takeIf { libraryMatch(it, unresolved) } }", "msg": "I need atomicfu klib as the compile dependency for the plugin tests. This dependency is provided in the [atomicfuClasspath](https://github.com/JetBrains/kotlin/blob/19610be7c35dcf39b3db4a076bad6891c30fc043/plugins/atomicfu/atomicfu-compiler/build.gradle.kts#L48) - the atomicfu-js version `0.14.3-1.4-M1`, that is built with `1.4-M1`. The problem here is that kotlin abi version  of this dependency is 1.4.0 while the CURRENT KotlinAbiVersion is 1.4.1, so here I get mismatch and the dependency is not used.\r\n\r\nHow is the abi version provided for the library?"}
{"patch": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis\n+\n+import com.intellij.psi.tree.IElementType\n+import com.intellij.psi.tree.TokenSet\n+import org.jetbrains.kotlin.fir.*\n+\n+fun FirSourceElement.getChildren(type: IElementType, index: Int = 0, depth: Int = -1): FirSourceElement? {", "msg": "As I can see, all these functions return a child, not a set of children. Please rename them accordingly."}
{"patch": "@@ -25,6 +25,9 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@SharedImmutable is applicable only to val with backing field or to property with delegation\"\n         )\n         put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, \"@SharedImmutable is applicable only to top level declarations\")\n+        put(ErrorsNative.VARIABLE_IN_TOP_LEVEL_SINGLETON_WITHOUT_THREAD_LOCAL, \"Variable in top level singleton without @ThreadLocal\")", "msg": "\"Top level\" is redundant here (e.g. `companion object`)."}
{"patch": "@@ -11,13 +11,13 @@ interface Order {\n fun foo(o: Any) {\n     val order = o as? Order\n     if (order?.expired ?: false) {\n-        order.<!INAPPLICABLE_CANDIDATE!>doSomething<!>()\n+        order.<!UNSAFE_CALL!>doSomething<!>()", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44511"}
{"patch": "@@ -158,7 +158,7 @@ class Case11 {\n         if (y == case_12)\n             throw Exception()\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>y<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>y<!>.<!INAPPLICABLE_CANDIDATE!>length<!>\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>y<!>.<!UNSAFE_CALL!>length<!>", "msg": "For the record, this is also `SMARTCAST_IMPOSSIBLE`."}
{"patch": "@@ -667,11 +669,13 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n             parameter<FirExpression>(\"lhs\")\n             parameter<String>(\"operator\")\n             parameter<FirExpression>(\"rhs\")\n+            parameter<FirExpression?>(\"receiverExpression\")", "msg": "I suspect either `receiverExpression` or `lhs` isn't needed here"}
{"patch": "@@ -8,5 +8,5 @@ fun Array<String>.length() : Int {\n }\n \n fun test(array : Array<String?>?) {\n-    array?.sure<Array<String?>>().<!INAPPLICABLE_CANDIDATE!>length<!>()\n+    array?.sure<Array<String?>>().<!UNSAFE_CALL!>length<!>()", "msg": "To be honest, no idea yet.\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/regressions/kt557.kt#L11\r\n\r\nAt DOT operator, the receiver has `TYPE_MISMATCH`, and the call is reported as `UNRESOLVED_REFERENCE_WRONG_RECEIVER` (well, because type mismatches, hm). We don't have a type checker that reports `TYPE_MISMATCH`, don't we?"}
{"patch": "@@ -111,6 +111,11 @@ class Fir2IrConversionScope {\n     fun dispatchReceiverParameter(irClass: IrClass): IrValueParameter? {\n         for (function in functionStack.asReversed()) {\n             if (function.parentClassOrNull == irClass) {\n+                // An inner class's constructor needs an instance of the outer class as a dispatch receiver.\n+                // However, if we are converting `this` receiver inside that constructor, now we should point to the inner class instance.\n+                if (function is IrConstructor && irClass.isInner) {\n+                    irClass.thisReceiver?.let { return it }", "msg": "I realized `irClass.thisReceiver` is returned as a default-ish dispatch receiver at the end, so we may just skip here if `function is IrConstructor` in general. But, it's better to return early I think."}
{"patch": "@@ -4,7 +4,7 @@\n operator fun String.invoke(i: Int) {}\n \n fun foo(s: String?) {\n-    <!INAPPLICABLE_CANDIDATE!>s<!>(1)\n+    <!UNSAFE_CALL!>s<!>(1)\n \n-    <!INAPPLICABLE_CANDIDATE!>(s ?: null)(1)<!>\n+    <!UNSAFE_CALL!>(s ?: null)(1)<!>", "msg": "OI/NI behave differently: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/resolve/invoke/errors/unsafeCallWithInvoke.kt#L9\r\n\r\nAssuming NI is default in FIR, I think we should report `UNSAFE_IMPLICIT_INVOKE_CALL` here?"}
{"patch": "@@ -53,6 +65,7 @@ object JvmBackendFacade {\n         val stubGenerator = DeclarationStubGenerator(\n             psi2irContext.moduleDescriptor, psi2irContext.symbolTable, psi2irContext.irBuiltIns.languageVersionSettings, extensions\n         )\n+        stubGenerator.setIrProviders(irProviders)\n         val deserializer = JvmIrLinker(", "msg": "Move to line 47?"}
{"patch": "@@ -8,7 +8,14 @@ package org.jetbrains.kotlin.fir.expressions\n import org.jetbrains.kotlin.diagnostics.WhenMissingCase\n \n sealed class ExhaustivenessStatus {\n-    object Exhaustive : ExhaustivenessStatus()\n+    object ProperlyExhaustive : ExhaustivenessStatus()", "msg": "Maybe add a comment for this one too, something like,\r\n```\r\n/**\r\n * This value is used if the subject has type other than `Nothing`, in which case it's literally exhaustive\r\n * only if type's possible cases are properly covered.\r\n */\r\n```"}
{"patch": "@@ -8,7 +8,7 @@ fun <R> List<R>.a() {}\n \n fun test1(i: Int?) {\n     1.<!INAPPLICABLE_CANDIDATE!>a<!>()", "msg": "Just for the record, many errors in this file should be rather `UNRESOLVED_REFERENCE_WRONG_RECEIVER`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/extensions/throwOutCandidatesByReceiver.kt#L10"}
{"patch": "@@ -36,7 +36,8 @@ val NULLABLE_ANNOTATIONS = listOf(\n     FqName(\"edu.umd.cs.findbugs.annotations.CheckForNull\"),\n     FqName(\"edu.umd.cs.findbugs.annotations.Nullable\"),\n     FqName(\"edu.umd.cs.findbugs.annotations.PossiblyNull\"),\n-    FqName(\"io.reactivex.annotations.Nullable\")\n+    FqName(\"io.reactivex.annotations.Nullable\"),\n+    FqName(\"io.reactivex.rxjava3.annotations.Nullable\")", "msg": "I'm not sure if it's possible to use trailing commas here? As in I'm not sure what kotlin language level the compiler code targets"}
{"patch": "@@ -0,0 +1,32 @@\n+fun castInTry(s: Any) {\n+    try {\n+        s as String // Potential cast exception\n+    } catch (e: Exception) {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    } finally {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    }\n+    s.<!UNRESOLVED_REFERENCE!>length<!>", "msg": "Should be smartcast"}