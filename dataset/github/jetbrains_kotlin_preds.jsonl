{"pred": "<msg>This is not correct. The `targetCallable` is a `FunctionImportedFromObject` or a `Callable`.", "target": "Should we use `ImportedFromObjectCallableDescriptor<*>` instead?", "id": 0}
{"pred": "<msg>I think we can remove this import.", "target": "Minor: unused import. I'll remove it before pushing.", "id": 1}
{"pred": "<msg>I think this is a bug.", "target": "I somehow missed it. Thanks!\r\nMinor: there is `SUSPEND_CALL_RESULT_NAME`, which, in fact, I should've used.", "id": 2}
{"pred": "<msg>This is the same as `this.functionStack.lastOrNull()?.dispatchReceiverParameter`", "target": "I will change it to `thisReceiverExpression.convertWithOffsets` usage", "id": 3}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "correct one is: \r\n```\r\n   val b = number.toByte()\r\n   val d = number.toDouble()\r\n   val f = number.toFloat()\r\n   val i = number.toInt()\r\n   val l = number.toLong()\r\n   val s = number.toShort()\r\n```", "id": 4}
{"pred": "", "target": "This test should not have passed. It is checking that no delegate field is created for interface delegation. It is doing so based on the name of the field, and therefore it now correctly fails because we do not have that optimization.", "id": 5}
{"pred": "", "target": "There are also test `namedArgumentsBefore.kt` which might fail now, because by default `MixedNamedArgumentsInTheirOwnPosition` will be enabled in kotlin 1.4\r\n\r\nCan you please explicitly specify there that `MixedNamedArgumentsInTheirOwnPosition` is disabled in this test (by adding `// COMPILER_ARGUMENTS: -XXLanguage:-MixedNamedArgumentsInTheirOwnPosition`), and add additional test with `MixedNamedArgumentsInTheirOwnPosition` enabled (in which the intention should now work for this case)?", "id": 6}
{"pred": "<msg>I think this is not needed.", "target": "It seems like there are missing test when `MixedNamedArgumentsInTheirOwnPosition` is enabled, but the arguments are not in their own positions, and the intention should be disabled\r\n\r\nWith your code, this case will look like `foo(1, <caret>name3 = 3, name2 = 2)`\r\n", "id": 7}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to make it work.", "target": "When `MixedNamedArgumentsInTheirOwnPosition` is enabled, you cannot skip this check. Actually you have to check that all of the previous arguments are not named, or are named but in their own positions\r\n\r\nYou can take a look at `NamedArgumentCompletion::isOnlyNamedArgumentExpected` to see how this check looks exactly\r\n\r\nTo check that your implementation is correct, try this test: \r\n\r\n```kt\r\n// COMPILER_ARGUMENTS: -XXLanguage:+MixedNamedArgumentsInTheirOwnPosition\r\n// IS_APPLICABLE: false\r\n\r\nfun foo(name1: Int, name2: Int, name3: Int) {}\r\n\r\nfun usage() {\r\n    foo(name2 = 2, name1 = 1, <caret>name3 = 3)\r\n}\r\n```\r\n\r\nThe intention should not be applicable, because first two arguments are not in their own positions, therefore you cannot remove name from the third argument", "id": 8}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "You are using your own `resolveToArgumentMatch` function here\r\n\r\nPlease, replace it with `org.jetbrains.kotlin.resolve.calls.callUtil.getParameterForArgument`, it is designed specifically for this case", "id": 9}
{"pred": "<msg>I think we can remove this annotation now.", "target": "You can use `@SinceKotlin(\"1.3\")` + `@ExperimentalStdlibApi`. This way new functions could be published in 1.3.x release", "id": 10}
{"pred": "<msg>I think we should just remove this annotation.", "target": "For JS_IR we copy JS sources during build, so this suppress should not be needed.", "id": 11}
{"pred": "<msg>This is the only change in this file.", "target": "I would prefer to keep original separation: visitWhileLoop/visitDoWhileLoop", "id": 12}
{"pred": "<msg>I think we should use the `KtPsiFactory` here instead of `Editor`", "target": "Better add \"lambda\" (e.g,  \"Convert to multi-line lambda\") to the end of the title as it's not quite obvious for the user what should that intension do in case when many intentions are suggested to the user", "id": 13}
{"pred": "<msg>I think we should also check for `resultingDescriptor.isNull` here.", "target": "But the called function may have an arbitrary name, see https://youtrack.jetbrains.com/issue/KT-33741#focus=streamItem-27-3697460.0-0", "id": 14}
{"pred": "<msg>I think this is a bit confusing. I think it should be `KotlinCompilerPluginSupport` or `KotlinCompilerPluginSupport`", "target": "A convention is to distinguish methods returning tasks providers (from methods returning tasks) by suffix them:\r\n`getPluginKotlinTaskProviders` here.", "id": 15}
{"pred": "<msg>This is a bit confusing. It seems like the `getJavaTask` method is returning the task provider, but the `getJavaTask` method is returning the task. I think the name should be changed to `getJavaTaskProvider` or something like that.", "target": "`javaTaskProvider`", "id": 16}
{"pred": "<msg>I think this is a bit of a hack. I think we should just make `getJavaTaskProvider` return a `TaskProvider<out AbstractCompile>` and then we can just use `getJavaTask(this).let`", "target": "you can use `named\u200b(String name, Class<S> type)`", "id": 17}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use `.findByName` here.", "target": "I am not sure to understand why we need the collection here (`withType`). Just for the type ? \r\nWe might want to use named(String, Class) but need to handle the failing cases.", "id": 18}
{"pred": "<msg>I think we can remove this line.", "target": "we can use `named(String, Class)` ", "id": 19}
{"pred": "<msg>This is not needed.", "target": "This will cause the tasks to be realized. You can use named, and also precise the type if the lowest gradle version is bumped to 5.1.", "id": 20}
{"pred": "<msg>This is a bit weird. Why not just `project.registerTask(taskName)`?", "target": "I am wondering here when the `onlyIf` statement is gonna be evaluated as calling `get()` will realize the task.\r\nTBH, it would be nice to have someone from Gradle having a look at it.", "id": 21}
{"pred": "<msg>This is a bit weird. I would expect `findByName` to return the task, not the task itself.", "target": "Can we change all the variable/property names that refer to providers to use the suffix `Provider` (e.g. `jarTaskProvider`). It will help maintenance and the API will be more clear.", "id": 22}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have the `?:` on the next line, so that it's clearer what the `?:` is doing.", "target": "if we use gradle 5.1 apis, this can be shortened to `named(Class, String)`. Or we need to keep using this \"old\" api because this case is a backward compatibility case ?", "id": 23}
{"pred": "<msg>This is a bit weird. I think we should just use `locateTask` here.", "target": "sometimes we use `named`, sometimes we use `locateTask!!`. It would be better to stick to one method.", "id": 24}
{"pred": "<msg>This is a bit weird. I think we should just use `locateTask` here.", "target": "Please rename to `compileJavaTaskProvider`", "id": 25}
{"pred": "<e0>}", "target": "`testTaskProvider`", "id": 26}
{"pred": "<msg>This is a breaking change. I think we should keep the old type and add a new type.", "target": "`cleanAllTest(s)TaskProvider`, I am not sure about the `s`.", "id": 27}
{"pred": "<msg>I think we should add a note here that this is deprecated and will be removed in a future release.", "target": "Use the equivalent provider method to benefit from gradle task configuration avoidance.", "id": 28}
{"pred": "<msg>This is the only place where we need to check if the `target` is a `KtCallExpression`.", "target": "This is a very hacky way to solve the problem. The root of problem here is the fact that the considered call expression is not a valid candidate (see check at line 88), so I believe this place should be fixed instead.", "id": 29}
{"pred": "<msg>This is a bit of a weird name. I would expect it to be called `UpdateConstantFacadePropertyReferences` or something like that.", "target": "~~Do you need this as a ClassLoweringPass? You're creating it only to call lower(). It can just be a private method, or merge it with the anonymous IrElementTransformerVoid.~~ Never mind I thought you were passing in an IrClass, didn't notice it was an IrModuleFragment", "id": 30}
{"pred": "<e0>@SuppressWarnings(\"serial\")", "target": "This is a common part used extensively outside of the scripting, so I suggest to make changes less intrusive, i.e. leave `line` and `column` intact, add `endLine` and `endColumn`, and put this change into a separate commit with an explanation \"why\" in the commit message.", "id": 31}
{"pred": "<msg>This was a bug", "target": "Functional changes get lost in the formatting ones. If you really want to submit formatting changes of that magnitude (I'm not against it in general), I would suggest to make it with a separate commit.\r\nOn the other hand, small formatting changes in comparison with the functional ones, in most cases look fine for me.", "id": 32}
{"pred": "<msg>I think we should add a `message` parameter to this class.", "target": "It seems that it could be substituted with ScriptDiagnostic. But the problem is that scripting-common is not accessible from compiler-cli. So it is one more reason to base completion on a new API and relocate it completely to a plugin similar to scripting plugin.", "id": 33}
{"pred": "<msg>I think we should add a `@SuppressWarnings(\"unchecked\")` to the `platformStringIsNull` and `nullableStringIsNull` methods.", "target": "Minor: not clear if it's really \"SHOULD\". Language design formalities are not settled in this case.\r\nI'd change this comment to something like \r\n```\r\n// Null check behavior in string concatenation might change depending on language design decision for KT-36625.\r\n```", "id": 34}
{"pred": "<msg>I think we should use `platformStringIsNull` and `notNullStringIsNull` instead of `platformStringIsNotNull` and `nullableStringIsNotNull`", "target": "Minor: I usually give the \"main\" file in the multi-file test the same name as the test file (`stringFromJavaPlus.kt` in this case). Enables navigation from stack trace in IDEA.", "id": 35}
{"pred": "<msg>This is a bit confusing. Why do we need to check for `typeArgumentList`?", "target": "What if not the first but the second or third argument is spread? ", "id": 36}
{"pred": "<msg>I think this should be `DiagnosticFactory0`", "target": "Not \"incompatible\". More like \"inapplicable\".", "id": 37}
{"pred": "<msg>I think we should use `@SharedImmutable` here.", "target": "I guess `@SharedImmutable` on computed properties should be an error too.", "id": 38}
{"pred": "<msg>I think we should add a new error for this.", "target": "> entities\r\n\r\ndeclarations", "id": 39}
{"pred": "<msg>I think this is a typo.", "target": "No tests for `@ThreadLocal` singletons.\r\nAlso no tests for plain top-level properties.", "id": 40}
{"pred": "<msg>This should be `if (milestone > 0)`", "target": "`M0` seems to be a valid version. May be use -1 to indicate that the milestone version is empty?", "id": 41}
{"pred": "<msg>This is a bit confusing. I think we should just return `elementHasFunctionDescriptor` here.", "target": "It would be better to use `any { it is FunctionDescriptor }` rather `find { it is FunctionDescriptor } != null`", "id": 42}
{"pred": "<msg>This is a bit confusing. I think we should just return `elementHasFunctionDescriptor` and `qualifierHasClassDescriptor` here.", "target": "same as line above", "id": 43}
{"pred": "<msg>I think this should be `ANNOTATIONS_IN_PROGRESS`", "target": "Annotations are modifiers, so changes to this file aren't needed.", "id": 44}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a method that takes a `boolean` and returns a boolean indicating whether the method should be called.", "target": "Given the comment above, annotations should be generated here by `renderer` and added to the `modifier` function call as prefix.\r\n```kotlin\r\nval annotations = config.descriptor.annotations.joinToString(separator = \"\\n\", postfix = \"\\n\") {\r\n    renderer.renderAnnotation(it)\r\n}\r\n```", "id": 45}
{"pred": "<msg>This is not a good way to check if a parameter is used in a class initializer. It should be a method of the class initializer.", "target": "Please reuse the function `hasUsages`. \r\n```suggestion\r\n        val classInitializer = containingClass.body?.declarations?.firstIsInstanceOrNull<KtClassInitializer>() ?: return false\r\n        return hasUsages(classInitializer)\r\n```", "id": 46}
{"pred": "<msg>I think we should add this to the error message as well.", "target": "1. Kinda unclear. The message should list exact requirements for `@SharedImmutable`.\r\n2. \"current\" doesn't fit here. Maybe \"this\"?", "id": 47}
{"pred": "<msg>This is not a sample.", "target": "Two notes:\r\n- better to use `%` infix operator instead of its named form `rem`\r\n- short lambdas usually do not introduce name for its parameter and use default `it` instead.\r\n\r\nIt may be beneficial, however, to show both variants, so we can do the following: \r\n- use `it` in `filter` lambda\r\n- write another expression with `filterNot` that uses explicit parameter name\r\n- now this sample can be used for `filterNot` as well :)", "id": 48}
{"pred": "<msg>This sample is not needed.", "target": "Have you run stdlib code generation after that? It should affect array `filter` extension too. ", "id": 49}
{"pred": "<msg>I think we should not use the `LookupTracker` here. It's not a component.", "target": "(minor) unused?", "id": 50}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "Please use the full JVM signature (after the subsequent `.map { it.owner.toSignature() }` call) to filter out these members, instead of only name", "id": 51}
{"pred": "<msg>This is a bit confusing. It seems like the `fun` function is only used for the `KtSecondaryConstructor` case, but the `KtSecondaryConstructor` case is only used for the `KtSecondaryConstructor` case. I think it would be better to just inline the `fun` function here.", "target": "It seems the result value of this expression is not used.", "id": 52}
{"pred": "<msg>I think we can simplify this to `valueArguments.first().getArgumentExpression()?.getType(it.analyze(BodyResolveMode.PARTIAL))?.isChar() == true`", "target": "I would split this line to several, as it's hard to read.", "id": 53}
{"pred": "<msg>This is the only place where we need to check if the call is suspended.", "target": "I would do something with the formatting here :)\r\nMaybe, extract the `firstResolvedCall.call.callElement.anyDescendantOfType()` call so the whole `if` condition fit into a single line?", "id": 54}
{"pred": "<msg>I think we should add this to the `@SharedImmutable` error message as well.", "target": "\"Top level\" is redundant here (e.g. `companion object`).", "id": 55}
{"pred": "<msg>I think we should add the same error message for `@SharedImmutable` and `@ThreadLocal`", "target": "Enum classes follow the same rules as `object` without `@ThreadLocal`, so I guess messages should probably be very similar in this part.", "id": 56}
{"pred": "<msg>I think this is not needed.", "target": "Not sure if this works, but I guess it should be `== true` here?", "id": 57}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a problem.", "target": "Could you please name this variable something more specific and reflecting its purpose?\r\n\r\nFor example, `specialCaseStubSignaturesForOldBackend`.\r\n\r\nAnd also please mention the issue [KT-36724](https://youtrack.jetbrains.com/issue/KT-36724) in the comment. We'd like to fix this issue in the old backend at some point.", "id": 58}
{"pred": "<msg>This is a breaking change. We need to add a new property to the `IrProvider` interface.", "target": "I'd suggest to add an ability to provide only one `IrProvider` and pass `CompositeIrProvider` (unexisting yet).", "id": 59}
{"pred": "<msg>This is a bit weird. Why not just pass the `IrProviders` object to the `DeclarationStubGenerator` constructor?", "target": "Move to line 47?", "id": 60}
{"pred": "<msg>This is a bit weird. Why not just pass the `IrProviders` object to the `DeclarationStubGenerator` constructor?", "target": "Do we need to recreate the `IrProvider` setup here? Why not reuse the one you built earlier?", "id": 61}
{"pred": "<msg>I think this is a bug. The assignment is not used.", "target": "Please avoid checking something in FIR using psi reference. FIR should have enough information itself (if it's not true for the particular case, we should add necessary information). Moreover, when we build FIR using lighter AST mode we do not have this psi reference at all. ", "id": 62}
{"pred": "<msg>I think this is not the right place to check this. It should be in the `if` block below.", "target": "I'm not quite sure here, but may be in this case we should create function call from the beginning (I mean, in raw FIR)?", "id": 63}
{"pred": "", "target": "Seem like another copy-pasted file. Hopefully will go as well, when the compiler will be moved to the appropriate module.", "id": 64}
{"pred": "", "target": "Another unnecessary copy-paste.", "id": 65}
{"pred": "", "target": "And this is, imho, unnecessary copy-paste too.", "id": 66}
{"pred": "", "target": "And this is, imho, unnecessary copy-paste too.", "id": 67}
{"pred": "<msg>I think we can remove this line.", "target": "Please test also \r\n     return \"O\".myLet(fun (it: String) : String {return it +  \"K\"})", "id": 68}
{"pred": "<e0>is", "target": "Hm, github doesn't allow me to leave comments outside of changes. :\\\r\n\r\nAnyhow, I saw that applying the same idea to `IrCallImpl` case above, in particular, `dispatchReceiver` for call expression without selector could also unmute 17 cases, but broke many others. :p It may require more careful accessibility check I guess. I'll dig into that as well, if this approach looks good.", "id": 69}
{"pred": "<msg>This is a bit confusing. I think we should just use the `explicitReceiver` field to find the dispatch receiver.", "target": "IMHO this logic looks a bit hacky. I will think about alternative variants and write you.", "id": 70}
{"pred": "<msg>I think this should be `ANONYMOUS_CLASS_ID`", "target": "I guess this default case could be potentially `CallableId(context.currentClassId, name)` so that we can propagate the correct `ClassId`, but broke a couple cases. :\\ In particular, some lookup, which returns class-like symbol, expects the lookup target should never be a local. It has been local, but this may disclose a hidden issue.", "id": 71}
{"pred": "<msg>This is a bit confusing. It seems like the function literal is the first argument to analyze, but the function literal is the second.", "target": "You are reusing `bindingContext` here, but in the `applyTo` you are still using `descriptor` extension. What is the reason for that", "id": 72}
{"pred": "<msg>This is a bit of a misnomer. I think it should be `flattenSequenceOfLists`", "target": "It might be quite confusing that the sample for flattening a sequence of _lists_ is too similar to the one for sequence of _sequences_.\r\nCould you instantiate the inner list without using sequences? ", "id": 73}
{"pred": "<msg>This is the only change in this file.", "target": "There are 10+ cases that failed with visibility conversion error: package-private (which should be normalized in general) doesn't have a counter part. By comparing `psi2ir` path, I noticed that all those cases have private constructor with default values, which is lowered by adding a synthetic constructor with package-private visibility.\r\n\r\nThe difference is, during serialization, `LazyClassDescriptor#getConstructors` returns constructors that literally appear in the PSI, which means we need to filter out synthetic ones here.", "id": 74}
{"pred": "<msg>I think this is not needed.", "target": "This is the only one regression, though. After having a correct metadata, proper serialization started, and found that, when serializing the extension receiver of `tableView` below, type parameter `T` for `Table<T>` didn't have a counter part, type argument in the converted IrType. This means that type arguments for generic types are missing in general. I left a TODO/comment about this on our doc.", "id": 75}
{"pred": "<msg>This is a bit confusing. It seems like the annotation entry should be created with the correct text, not with the useSiteTargetText.", "target": "```suggestion\r\n        val text = annotationEntry.valueArguments.single().getArgumentExpression()!!.text\r\n        val newAnnotationEntry = if (isFileUseSiteTarget)\r\n            psiFactory.createFileAnnotation(text)\r\n        else\r\n            psiFactory.createAnnotationEntry(\"@$useSiteTargetText$text\")\r\n        return annotationEntry.replaced(newAnnotationEntry)\r\n```", "id": 76}
{"pred": "<msg>This is a bit weird. I think it should be `! EXPOSED_FUNCTION_RETURN_TYPE!`", "target": "Probably it's the same problem with local visibility. We should not have errors here.", "id": 77}
{"pred": "<msg>This is a bit of a nit, but I think it would be better to have a single line for the `isSmartcastFromHigherThanNullable` function.", "target": "Nit: I'd break this differently.\r\n```kotlin\r\nis IrTypeOperatorCall -> operator == IrTypeOperator.IMPLICIT_CAST &&\r\n    !argument.type.isSubtypeOf(type.makeNullable(), context.irBuiltIns)\r\n```", "id": 78}
{"pred": "<msg>I think we should throw an error if `transformationInfo` is not an instance of `AnonymousObjectTransformationInfo`.", "target": "maybe smth like `isRecreatesItself`?", "id": 79}
{"pred": "<msg>I think this should be `getClassOrNull`", "target": "I'd rewrite `getClass` above now with something like\r\n```\r\ngetClassOrNull(name, *packageNameSegments) ?: error(\"Class $name is not found in ${packageNameSegments.toList()}\")\r\n```", "id": 80}
{"pred": "<msg>This is a bit weird. Why not just use `listOf`?", "target": "I suppose the TODO above is fixed", "id": 81}
{"pred": "<msg>This is a bit confusing. Why not just have a single method that returns the type parameter?", "target": "This is strange place, as well as the next one. Normally we should not create type parameter when we don't know its index. This will anyway work incorrectly if a corresponding declaration has more than one type parameter.", "id": 82}
{"pred": "<msg>This is not the right place to put this code. It should be in the `if (context.es6mode)` block.", "target": "`IrElementTransformer`?", "id": 83}
{"pred": "<msg>This is a bit confusing. I think we should just use `with` here.", "target": "Let pass it to constructor", "id": 84}
{"pred": "<msg>This is a bit of a misnomer. It's not actually generating the function, it's generating the function's body.", "target": "Seems like both functions could be merged", "id": 85}
{"pred": "<msg>This is not a good way to do this. You should be able to do this in the constructor.", "target": "All this code is too nightmarish to leave it. I took source just from `superTypeRef`. It contradicts with old front-end at some point, e.g. reports on `Base` instead of `Base()`, but at this point it looks even more correct.", "id": 86}
{"pred": "<msg>I think we should use `val` here.", "target": "`isSpecial` can be used here, I guess", "id": 87}
{"pred": "<msg>I think we should use `ImmutableList.copyOf` here.", "target": "This looks like a regular `==` for lists\r\n\r\nAlso, it seems strange that when any package is not equals, `equals` returns `true`", "id": 88}
{"pred": "<msg>I think we should use `ImmutableList.of()` here.", "target": "I do not see any usage of `equals` on this class; do we actually need it? Same goes to the `hashCode`", "id": 89}
{"pred": "<msg>I think we should use `val` here.", "target": "This function can be private", "id": 90}
{"pred": "<msg>I think we should rename this method to `isModified`", "target": "You can convert this to property to avoid code change here", "id": 91}
{"pred": "<msg>I think this is not needed.", "target": "I would rewrite it like this: \r\n\r\n```kt\r\n    private val comparator = compareBy<ImportPath>(\r\n        { import -> bestMatchIndex(import) },\r\n        { import -> import.toString() }\r\n    )\r\n\r\n    override fun compare(import1: ImportPath, import2: ImportPath): Int = \r\n        comparator.compare(import1, import2)\r\n```\r\n\r\nIMO it is clearer and leaves less room for error", "id": 92}
{"pred": "<msg>I think we should use `/` instead of `/` for paths that contain `/`", "target": "This is not actually needed ", "id": 93}
{"pred": "<msg>This is the only change that I'm not sure about. The rest is just cleanup.", "target": "This code worth some explanation. ", "id": 94}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "Unclear ", "id": 95}
{"pred": "<msg>This is not needed.", "target": "I would suggest to introduce an additional intrinsic and track it separately ", "id": 96}
{"pred": "<msg>This is a bit weird. Why not just `with(context)`?", "target": "`context.run { .. }`", "id": 97}
{"pred": "<msg>I think this is not needed.", "target": "x2", "id": 98}
{"pred": "<msg>I think we should add a `version` argument to the `npm` function as well.", "target": "Is peer dependencies support directory notation?\r\nSeems that only\r\n`fun peerNpm(name: String, version: String = \"*\"): Dependency`\r\nehough", "id": 99}
{"pred": "<msg>I think this should be `NpmDependency.Scope.DEV`", "target": "This check is duplicated with `npm` function\r\nCan be extracted to separate function `directoryNpmDependency` which do this check and return `NpmDependency` with appropriate scope", "id": 100}
{"pred": "<msg>This is a public API change.", "target": "Seems that `dependencies` is not needed in constructor, it can been calculated from `project`", "id": 101}
{"pred": "<msg>I think this should be `npm(org: String? = null, packageName: String, version: String = \"*\"): Dependency`", "target": "Minor: if you want, you can cover `optionalDependencies`\r\nIts semantic is similar with normal dependencies \r\nAnd JFYI, I started to solve this issue right before you send PR :) \r\nNow I paused it, but you can take a look, can be a bit useful\r\nhttps://github.com/JetBrains/kotlin/tree/rr/gradle/ilgonmic/npm-scopes", "id": 102}
{"pred": "<msg>I think this is not needed.", "target": "The change here is that instead of `Number.intValue`, `Number.byteValue` is used when known to be a byte. Additionally, the IR backend actually generates 3 `areEqual` calls, but the asm optimization method visitor then ends up unboxing and using `Number.byteValue` on the arguments.", "id": 103}
{"pred": "<msg>This is a bit weird, why do we need this?", "target": "`lateinit` should be better here", "id": 104}
{"pred": "<msg>I think this is fine, but I'm not sure if we should be doing this. I think we should be doing this in the `registerIrClass` method, and then calling `registerIrClass` in the `processClassHeader` method.", "target": "I think this logic should be in `addDeclarationsToExternalClass` and not here. `createIrClass` should just create a class.", "id": 105}
{"pred": "<msg>I think this is a bit confusing. I think we should just have a `toIrType` method on `FirJavaTypeRef` and then call that method here.", "target": "Yet it's Ok but I should investigate this place. As I understand we should not have `FirJavaTypeRef` at this point, and if we do, it points to some FIR resolve error.", "id": 106}
{"pred": "<msg>This is a bug fix.", "target": "I think this code is not needed at all. I'll investigate why `FirJavaTypeRef` remains in resolved FIR.", "id": 107}
{"pred": "<e0>// We can't return null here because the resultSymbol is null.", "target": "I found that the original `calleeReference.resolvedSymbol` (after resolution) is of `FirIntegerOperator` from `FirJAvaModuleBasedSession`, while this, kind of reloaded, result symbol is `FirSimpleFunctionImpl` from `FirLibrarySession`. I'm not sure 1) why the latter was not found as a resolution candidate; and 2) why the former was not reloaded again from the member scope lookup.", "id": 108}
{"pred": "<msg>This is not correct. The qualifier is not part of the array.", "target": "I would say that this change might be not enough.\r\nFor example, it's not gonna work in case it has a form of `vararg x: kotlin.Int` or `vararg x: MyTypeAliasToInt`.\r\nMaybe it's worth trying to move this logic to `org.jetbrains.kotlin.fir.resolve.transformers.FirTypeResolveTransformer#transformValueParameter` when the type is already resolved properly and we can just use it without guessing\r\n\r\nBTW, something similar is already happening there at `result.transformVarargTypeToArrayType()`.\r\nLooks like we have similar logic in two different places and I would say it's worth investigating which one should work for all cases.", "id": 109}
{"pred": "<msg>I think we should keep the old SMAP and remap the line numbers to save time.", "target": "lambdas -> inline lambdas", "id": 110}
{"pred": "<msg>This is not a valid test. You need to use `assertThrows` instead.", "target": "There are several problems with this example:\r\n- it doesn't seem to be referenced in code\r\n- `component1` and `equals` are functions to satisfy operator conventions (destructuring and ==), they are rarely called directly in real code. So if you want to compare map entry key with \"bar\", it would be more idiomatic to write `it.key == \"bar\"`\r\n- for `if (predicate(it)) it else null` we have `takeIf` and `takeUnless` functions: \r\n`it.takeUnless { it.key == \"bar\" }`\r\n- the example overall looks like a contrived way to filter map based on keys, so `Map.filterKeys` would probably do fine in this case. On the other hand, the advantage of `mapNotNull` is that is can additionally transform an element, for example, with it we can filter by keys, but return the corresponding values:\r\n`map1.mapNotNull { entry -> entry.takeUnless { it.key == \"bar\" }?.value }` \r\nor using the entry destructuring \r\n`map1.mapNotNull { (key, value) -> value.takeUnless { key == \"bar\" } }`", "id": 111}
{"pred": "<msg>This is not a good example. You should use `list.find(it -> it == 1)` instead.", "target": "`find` returns the found element and not its index in the list. Please, ensure that samples really pass by running `:kotlin-stdlib:samples:check` gradle task. \r\n\r\nHere, having the first and the last elements indistinguishable, it's hard to tell which one is actually returned.\r\n\r\nSo, I propose to use slightly less trivial predicate, that could return the same result for different elements, for example `it % 2 == 0` that checks number parity.\r\n```\r\nval numbers = listOf(1, 2, 3, 4, 5, 6, 7)\r\nval firstOdd = numbers.find { it % 2 != 0 }\r\nval lastEven = numbers.findLast { it % 2 == 0 }\r\n...\r\n```", "id": 112}
{"pred": "<msg>This is not a good test. It should be a simple comparison.", "target": "This is not a typical usage of `compareTo`, here `equals` or `==` can be used instead of it.", "id": 113}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use a lambda here instead of a sample.", "target": "The sample should be referenced in the docs of the function, otherwise it won't get to the site.", "id": 114}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a separate method for this.", "target": "You may use expectedType.lowerBoundIfFlexible()", "id": 115}
{"pred": "<msg>I think this should be `ReplaceUselessCallWithToListFix`", "target": "I'd generalize this quick fix and call it `ReplaceSelectorOfQualifiedExpressionFix` and put it to `org.jetbrains.kotlin.idea.quickfix` package. Then first line of class would look like:\r\n```\r\nclass ReplaceSelectorOfQualifiedExpressionFix(val newSelector: String) : LocalQuickFix\r\n```\r\nI think you get the idea", "id": 116}
{"pred": "<msg>I think we should also check for `KotlinBuiltIns.isArray(receiverType)`.", "target": "That's wrong logic. You should use `ReplaceUselessCallWithToListFix` in case when type of whole expression is `List` and when receiver type isn't `List` at the same time. E.g. consider such example:\r\n```\r\nval arr: List<Int> = setOf(1, 2, 3).filterNotNull()\r\n```\r\nYour quick fix will remove `filterNotNull` but it's expected to be replaced with `toList` just like with `arrayOf`", "id": 117}
{"pred": "<msg>I think this is not needed.", "target": "You need to check for both conditions. You should replace selector with `toList()` when `whole exp` == `List` && `receiver` != `List`. Now you only check for `receiver` != `List`. So your code doesn't work for `sequenceOf` (because whole expression has type Sequence, not List):\r\n```\r\nval arr: Sequence<Int> = sequenceOf(1, 2, 3).filterNotNull()\r\n```\r\nYes, we don't yet have \"Useless call\" check for sequences but your code will broke when we add it.\r\n\r\nSo I suggest to invert your if for improving readability and add full check.", "id": 118}
{"pred": "<msg>This is a breaking change. We should keep the old name.", "target": "Maybe rename it to `classCodegen` then?", "id": 119}
{"pred": "<msg>This is a bit confusing. The `is` is not a predicate, but a boolean.", "target": "This done intentionally. User custom getter may contain complex computations or side effects. It's not safe to suggest custom getters in toString/hashCode default generator.\r\n\r\nYou can suggest pull request where custom getters are suggested but are disabled by default in this dialog:\r\n![image](https://user-images.githubusercontent.com/20517828/82453716-8b01ce00-9ab9-11ea-965a-1ca70f0ff93e.png)\r\n ", "id": 120}
{"pred": "<msg>This is a bug fix.", "target": "BTW, `getLineNumber` JavaDoc is incorrect. It accepts ints from range [0, textLength]. I fixed JavaDoc in community: https://github.com/JetBrains/intellij-community/commit/9e4198f84cdbd3f67f6a8fb94bb3f46a4e9dbb45", "id": 121}
{"pred": "<msg>This is a bit confusing. Why not just return `when {areConstComparisons(calls)}`?", "target": "It would help to describe what the expected IR looks like for the call.", "id": 122}
{"pred": "<msg>This is a bit confusing. It seems like the `parent` is the value argument of the lambda, but the `parentValueArgument` is the value of the argument of the parent function.", "target": "There's an existing `unwrapIfLabeled()` utility function for this:\r\nhttps://github.com/JetBrains/kotlin/blob/master/idea/src/org/jetbrains/kotlin/idea/intentions/loopToCallChain/commonUtils.kt#L151", "id": 123}
{"pred": "<msg>This is the only change that I'm not sure about. The rest is just cleanup.", "target": "The intentions will look much cleaner if you'll reverse the flag meaning, i.e. name it `skipResolveExtensions` and rewrite the code accordingly.", "id": 124}
{"pred": "<msg>I think this should be `\\d+`", "target": "Actually it can be even better: \"\"\"BUNCH (\\d\\d\\d)\"\"\". But for some reason I left older behavior", "id": 125}
{"pred": "<msg>I think we should add a `locationId` property to the `Range` class.", "target": "I would add this to the same change, you know how difficult it is to change the API with a data class", "id": 126}
{"pred": "<msg>I think this is a bit confusing. It seems like it should be checking if the name is in the synthetic object name, not if it is a synthetic function name.", "target": "Also, I'm concerned we don't handle usual nested classifiers' names here", "id": 127}
{"pred": "<msg>This is a bit of a misnomer. It's not a single line element.", "target": "Same as above", "id": 128}
{"pred": "", "target": "I do not like `...Ext` naming - remind me of bad MS APIs habits. I'd rather use `@JvmName` to resolve java ambiguity`.", "id": 129}
{"pred": "", "target": "`Extended` part of the name sounds weird to me. It seems that there is no good reason to have a separate \"extended\" variant, and you can simply add this functionality to the `ScriptDiagnosticsMessageCollector`.", "id": 130}
{"pred": "", "target": "And here too, it seems that we don't need non-extended variant in scripting, so you can just update the `withMessageCollector` function instead.", "id": 131}
{"pred": "<msg>I think this should be `SortedMap<K, V>`.", "target": "Needs to be annotated with `@SinceKotlin(\"1.4\")`", "id": 132}
{"pred": "<msg>This is not needed anymore", "target": "I need atomicfu klib as the compile dependency for the plugin tests. This dependency is provided in the [atomicfuClasspath](https://github.com/JetBrains/kotlin/blob/19610be7c35dcf39b3db4a076bad6891c30fc043/plugins/atomicfu/atomicfu-compiler/build.gradle.kts#L48) - the atomicfu-js version `0.14.3-1.4-M1`, that is built with `1.4-M1`. The problem here is that kotlin abi version  of this dependency is 1.4.0 while the CURRENT KotlinAbiVersion is 1.4.1, so here I get mismatch and the dependency is not used.\r\n\r\nHow is the abi version provided for the library?", "id": 133}
{"pred": "<msg>This is not a good test. It should be a simple test that compares the two maps.", "target": "`values` collection should contain integers", "id": 134}
{"pred": "", "target": "It seems that here we have wrong test data with redundant tab's.\r\nThis test is not green.\r\nMaybe it is machine specific behavior that align test results in different ways from yours:\r\n```\r\ncom.intellij.rt.execution.junit.FileComparisonFailure: Actual data differs from file content: \r\nMultiLineInitializer.kt.after expected:<... foo = foo(\r\n        [    \"1111111111\",\r\n            \"2222222222\",\r\n            \"3333333333\",\r\n            \"4444444444\",\r\n    ]        \"5555555555\"...> but was:<... foo = foo(\r\n        [\"1111111111\",\r\n        \"2222222222\",\r\n        \"3333333333\",\r\n        \"4444444444\",\r\n]        \"5555555555\"...>\r\n```", "id": 135}
{"pred": "<msg>This is not needed anymore.", "target": "@mglukhikh It looks like FE 1.0 actually has a field in property descriptor and initializes it during field value resolution if the property has a constant. I think I found a counter part in `fir`, but I'm not sure we want to add `compileTimeInitializer` (of `ConstantValue` type perhaps) to `FirProperty` or just determining whether it has constant or not during serialization like this. ", "id": 136}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a problem.", "target": "This whole set should be nullable in case it's impossible to compute classifiers names", "id": 137}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a method that returns a set of known names.", "target": "You may just use `getClassifierNames()`", "id": 138}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a method that returns a set of names, and then call that method here.", "target": "And here `addSyntheticClassifiers()` is not necessary: `getClassifierNames()` is either possible to compute or all other parts are meaningless", "id": 139}
{"pred": "<msg>I think this is not needed.", "target": "BTW, as far as I can see `getFunctionNames` already contains data-class-related `componentN` functions", "id": 140}
{"pred": "", "target": "These two options look as quite scary implementation details, so I'd move it to some other place. Or maybe redesigned the way how we control it in general. Let's discuss it offline.", "id": 141}
{"pred": "", "target": "This is very nasty function, I recommend to get rid of it", "id": 142}
{"pred": "<msg>I think this is a good candidate for a `Set<FirDeclaration>` type.", "target": "I don't like name, `put` is associated with adding something into container. Consider something like `deprioritizeSynthetics` or `sortedBySynthetic`", "id": 143}
{"pred": "<msg>I think this should be `getSyntheticNestedClassNames`", "target": "imo, `getPossibleSyntheticNestedClassNames` is a slightly better name for this method", "id": 144}
{"pred": "<msg>This is a bit confusing. Why do we need to check for the selector expression?", "target": "This doesn't work for code:\r\n```kotlin\r\nsealed class Foo {\r\n    object BAR : Foo()\r\n\r\n    companion object {\r\n        val BAR: Foo by lazy { Foo.BAR }\r\n    }\r\n}\r\n```", "id": 145}
{"pred": "<msg>This is a bit confusing. I think we should just have a single `if` statement for both.", "target": "This is not the correct check, since this feature (passing reference to non-suspend method as suspend function parameter) can be enabled and disabled independently from the language version. You probably should rewrite the code like this:\r\n\r\n```suggestion\r\n        if (!lambdaParameterIsSuspend && calleeFunctionIsSuspend) return false\r\n        if (!languageVersionSettings.supportsFeature(LanguageFeature.SuspendConversion)) {\r\n            if (lambdaParameterIsSuspend && !calleeFunctionIsSuspend) return false\r\n        }\r\n```", "id": 146}
{"pred": "<msg>This is not needed.", "target": "This too should be replaced with the `LanguageFeature.FunctionReferenceWithDefaultValueAsOtherType` flag check. I would advise to extract the flag check to some variable and reuse it twice", "id": 147}
{"pred": "", "target": "By default this conversion will lead to red code, because currently it is disabled\r\n\r\nPlease enable it with this\r\n\r\n```suggestion\r\n// COMPILER_ARGUMENTS: -XXLanguage:+SuspendConversion\r\nfun foo(a: suspend () -> Unit) {}\r\n```", "id": 148}
{"pred": "<msg>This is not correct. You should not be modifying the argument's valueArguments.", "target": "This check doesn't work for:\r\n```kotlin\r\nfun foo(vararg args: Int) = println(1)\r\nfun foo() = println(2)\r\nfun test() {\r\n    foo(*intArrayOf())\r\n} \r\n```\r\nI think you should compare result descriptor with previous value.", "id": 149}
{"pred": "<msg>This is not needed anymore.", "target": "These generate line numbers for the closing brace of `when`, `try`, `if`. However, this does not ensure that there is an instruction for that line number. Therefore, these line numbers will be there in the line number table, but will often not have instructions and can therefore not be observed. With the old backend, these are also emitted and typically cannot be observed. I opted for removing them entirely as I do not find it useful to be able to step and set breakpoints on the closing brace. The alternative is to go the other way and always emit a `nop` so that you will always get a step here (and the posibility of setting a breakpoint).", "id": 150}
{"pred": "<msg>This is a bit weird. Why not just `get()`?", "target": "\ud83d\udc84 Don't `.get()` the provider for uniformity with the other fields in this class", "id": 151}
{"pred": "<msg>This is a bit confusing. I would expect a boolean value to be passed in, and a boolean value to be passed in as a boolean.", "target": ":o: This could be modelled as a `Provider` to account for later changes to that property:\r\n\r\n```kotlin\r\nproject.providers.gradleProperty(\"kapt.verbose\").map { it.toBoolean() }.orElse(false)\r\n```", "id": 152}
{"pred": "<msg>This is a breaking change. We should keep the `get` method and add a new method to the `Provider` interface.", "target": "\u2753 I'm not sure where this `val` is wired, but the above code is losing task dependency and reference to `jar.archiveFileName` and could cause ordering problems.\r\n\r\nAnother way to write this would be:\r\n\r\n```kotlin\r\nproject.tasks.named(\"artifactsTaskName\", Jar::class).flatMap { jar ->\r\n    project.layout.buildDirectory.file(\"$KOTLIN_BUILD_DIR_NAME/${sanitizeFileName(jar.archiveFileName.get())}-classes.txt\")\r\n}\r\n```\r\nThis would return a `Provider<RegularFile>`. If you need it to be a `Provider<File>` just chain with `.map { it.asFile }`\r\n\r\nAgain, I'm not sure where this gets used and if my comment is relevant.", "id": 153}
{"pred": "<msg>I think we can remove this class.", "target": "I recommend using latest AGP 4.2 alphas, as those has more configuration caching issues fixed.", "id": 154}
{"pred": "<msg>I think we should add a `finish` event to the `finish` event.", "target": "This can be a `BuildService` and if you make it `AutoCloseable` you can implement clean-up logic in `close()` method.", "id": 155}
{"pred": "<msg>This is a bit weird.", "target": "It looks like configuration cached runs still rely on this method being invoked (please correct me if I'm wrong). If you'd like to be notified when build finished, build services provide you with such lifecycle (see my comment on `KotlinGradleBuildListener`).", "id": 156}
{"pred": "<msg>This is a bit weird. I would expect this to be a transient field.", "target": "Project is not serializable either, so probably needs `@Transient` as well.", "id": 157}
{"pred": "<msg>I think this should be `project.buildDir.resolve(\"kotlinSourceSetMetadata/${kotlinSourceSet.name}\")`", "target": "Use `ProjectLayout` methods to compute this. E.g. this will not detect changes if buildDir changes.", "id": 158}
{"pred": "<msg>I think we should add a log here.", "target": "You can't use `gradle.addListener(BuildListener)` but in that case you only need to react to `projectsEvaluated` and that can be done using `gradle.projectsEvaluated(action)`.", "id": 159}
{"pred": "<msg>I think we should remove this file.", "target": "wrong commit", "id": 160}
{"pred": "<msg>I think we should remove this file.", "target": "wrong commit", "id": 161}
{"pred": "<msg>I think we should remove this file.", "target": "The approach here looks strange to me, especially in the lack of the usages to chack the intentions. Let's discuss it online.", "id": 162}
{"pred": "", "target": "I'm not sure why this test was passing. The generated IR is not correct, e.g., the fake override for `IntervalTreeMap.get` takes an argument of type `Any?` instead of `String`.", "id": 163}
{"pred": "<msg>I think this is a good change, but I think it would be better to just remove the `require` and just do `require(elements.add(element) || element is IrConst<*>)`", "target": "I've tracked down where this was added, and it's for checking if there is a duplicate array access (represented as `IrGetVariable`). I strongly believe having same const should not matter. Actually, \"constant canonicalization\" (so that the local function can avoid loading the same constants again) is well-known optimization.", "id": 164}
{"pred": "<msg>I think this is not needed.", "target": ":x: that check is using reflection on internal API and exceptions for control flow and doesn't cache the result. This could have a bad effect on performance.", "id": 165}
{"pred": "<msg>I think we should keep this note.", "target": "Well, actually annotations should be on \"both\" places. :)\r\n\r\nAn example IR dump for the unmuted test (with old FE):\r\n```\r\n  CLASS ENUM_CLASS name:E modality:OPEN visibility:public superTypes:[kotlin.Enum<<root>.E>]\r\n    $this: VALUE_PARAMETER INSTANCE_RECEIVER name:<this> type:<root>.E\r\n    CONSTRUCTOR visibility:private <> () returnType:<root>.E [primary]\r\n      BLOCK_BODY\r\n        ENUM_CONSTRUCTOR_CALL 'public constructor <init> (name: kotlin.String, ordinal: kotlin.Int) [primary] declared in kotlin.Enum'\r\n          <E>: <root>.E\r\n        INSTANCE_INITIALIZER_CALL classDescriptor='CLASS ENUM_CLASS name:E modality:OPEN visibility:public superTypes:[kotlin.Enum<<root>.E>]'\r\n    ENUM_ENTRY name:E1\r\n      annotations:\r\n        First\r\n      init: EXPRESSION_BODY\r\n        ENUM_CONSTRUCTOR_CALL 'private constructor <init> () [primary] declared in <root>.E.E1'\r\n      class: CLASS ENUM_ENTRY name:E1 modality:FINAL visibility:private superTypes:[<root>.E]\r\n        annotations:\r\n          First\r\n        $this: VALUE_PARAMETER INSTANCE_RECEIVER name:<this> type:<root>.E.E1\r\n        CONSTRUCTOR visibility:private <> () returnType:<root>.E.E1 [primary]\r\n        \r\n    ENUM_ENTRY name:E2\r\n      annotations:\r\n        Second(value = 'OK')\r\n      init: EXPRESSION_BODY\r\n        ENUM_CONSTRUCTOR_CALL 'private constructor <init> () [primary] declared in <root>.E'\r\n\r\n    ...\r\n```", "id": 166}
{"pred": "<msg>I think this should be `assertContains(\"Reusing configuration cache.\")`", "target": ":o: Asserting that the configuration cache is reused again wouldn't harm\r\n```suggestion\r\n            assertTasksUpToDate(executedTask)\r\n            assertContains(\"Reusing configuration cache.\")\r\n```", "id": 167}
{"pred": "<msg>I think this should be `.resolve(\"configuration-cache\")`", "target": "\u274c This path is still wrong. See my comments in the other PR at https://github.com/JetBrains/kotlin/pull/3521/files#r449659042\r\n\r\n\u2753 Is this function still used? With its current implementation it will always return `null` anyway", "id": 168}
{"pred": "<msg>I think this is a good change. I think it's better to keep the original class and add a new one for the new one.", "target": "\ud83d\udc84 This comment isn't necessary I think. See comments in the previous PR at https://github.com/JetBrains/kotlin/pull/3521/files#r450239208", "id": 169}
{"pred": "<msg>This is a bit confusing. I would expect a boolean value to be passed in, and a boolean value to be passed in as a boolean.", "target": ":o: This could be modelled as a `Provider` to account for later changes to that property:\r\n\r\n```kotlin\r\nproject.providers.gradleProperty(\"kapt.verbose\").map { it.toBoolean() }.orElse(false)\r\n```", "id": 170}
{"pred": "<msg>This is a bit weird. I would expect this to be a transient field.", "target": ":x: Project is not serializable either, so probably needs `@Transient` as well.\r\n\r\n", "id": 171}
{"pred": "<msg>This is not needed.", "target": "\u274c This registration isn't valid and won't do anything. I would simply remove it for now.\r\n\r\nSee https://github.com/JetBrains/kotlin/pull/3521/files#r452728632", "id": 172}
{"pred": "<msg>This is a bit weird. Why not just `project.provider.get()`?", "target": "\u2753 I'm not sure where this `val` is wired, but the above code is losing task dependency and reference to `jar.archiveFileName` and could cause ordering problems.\r\n\r\nAnother way to write this would be:\r\n\r\n```kotlin\r\nprivate val layout = project.layout\r\n\r\ninternal val defaultArtifactClassesListFile: Provider<RegularFile> =\r\n    project.tasks.named(\"artifactsTaskName\", Jar::class).flatMap { jar ->\r\n        layout.buildDirectory.file(\"$KOTLIN_BUILD_DIR_NAME/${sanitizeFileName(jar.archiveFileName.get())}-classes.txt\")\r\n    }\r\n```\r\nThis would return a `Provider<RegularFile>`. If you need it to be a `Provider<File>` just chain with `.map { it.asFile }`\r\n\r\nAgain, I'm not sure where this gets used and if my comment is relevant.", "id": 173}
{"pred": "<msg>This is the only place where we use `project.gradle.projectsEvaluated`", "target": "\ud83d\udc4d ", "id": 174}
{"pred": "<msg>I think this is not needed.", "target": "\u2757  that check is using reflection on internal API and exceptions for control flow and doesn't cache the result. This could have a bad effect on performance.", "id": 175}
{"pred": "<msg>Remove this code", "target": "Please check here the case like\r\n```\r\nobject SomeObj\r\nfun foo() {\r\n    val x: Any /* NOT redundant */ = SomeObj \r\n}\r\n```", "id": 176}
{"pred": "<msg>I think this should be `type.isSame(StandardClassIds.Boolean)`", "target": "Please take into account (here and below) that redundant type should not be annoteted. Example:\r\n\r\n```\r\n@Target(AnnotationTarget.TYPE)\r\nannotation class A\r\n\r\nfun foo() {\r\n    val x: @A Int /* NOT redundant */ = 1\r\n}\r\n\r\n```\r\n", "id": 177}
{"pred": "<msg>I think this is a bit redundant. The interface is not a public interface.", "target": "Please don't report `REDUNDANT_MODALITY_MODIFIER` for `final` in `interface`, because this is an error.", "id": 178}
{"pred": "<msg>I think this is not needed.", "target": "Please leave here a comment that `REDUNDANT_MODALITY_MODIFIER` is questionable here (in FE 1.0, compiler reports a warning here, and inspection doesn't report anything).", "id": 179}
{"pred": "<msg>Please avoid wildcard imports.", "target": "Unused import", "id": 180}
{"pred": "<msg>I think this import is unused.", "target": "Redundant import", "id": 181}
{"pred": "<msg>This is a bit confusing. I think it should be `isLocalMember` or `isLocalMemberDeclaration`.", "target": "Please rename it to `containingPropertyVisibility` or something like. Current name is very unclear.", "id": 182}
{"pred": "<msg>I think we should add a `@Suppress` annotation here.", "target": "Why do we have `REDUNDANT_EXPLICIT_TYPE` here?", "id": 183}
{"pred": "<msg>I think we need to add this to the `FirSourceElement` enum.", "target": "Yes, but probably not in this commit", "id": 184}
{"pred": "<msg>I think we should add a new file `checkers.java` to the `checkers` package.", "target": "This file should be deleted", "id": 185}
{"pred": "<msg>This is the only place where I'm not sure we should be using `IrFunctionReferenceImpl`", "target": "@mglukhikh I think both resolution and conversion should refer to feature flags, but didn't so far. Any recommended place to add it? E.g., `FirSession` or some other context?", "id": 186}
{"pred": "<msg>This is a breaking change.", "target": "Note that test changes under `...Disabled*` are regression, since they should not be converted. Once we add feature flag look-up, these can be reverted.", "id": 187}
{"pred": "<e0>}", "target": "Because the you create directory for `testKt33594` test then please create directory for this `testCleanup` test", "id": 188}
{"pred": "<msg>This test is not needed.", "target": "Bad test name", "id": 189}
{"pred": "<msg>I think this test is not needed.", "target": "Just in case you will miss it: directory also should be renamed along with test name", "id": 190}
{"pred": "<msg>This is a bit of a hack. I think we should just remove the whole thing.", "target": "This `if` check should logically belong to `DeprecatedSymbolUsageFix.isImportToBeRemoved`", "id": 191}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to make it work.", "target": "> firstOrNull()\r\n\r\n\"singeOrNull\" seems safer option for me", "id": 192}
{"pred": "<msg>This is not correct. The callee text should be the text of the callee, not the callee's text.", "target": "First: this function is already too long, you can't add more logic into it. You should extract 3 lines of code you added into separate function + split code of existing `isRedundantCompanionReference` into subfunctions\r\n\r\nSecond: `values` and `valueOf` are hardcoded strings. There are already present in the project. At least you can find them in `RemoveRedundantQualifierNameInspection` and `UnusedSymbolInspection`. Please, extract those hardcoded strings into util class/file and reuse them", "id": 193}
{"pred": "<msg>This is not needed.", "target": "Please do not edit side files without a reason, especially when you are not the person who mostly works with this side file.", "id": 194}
{"pred": "<msg>I think we can remove this line.", "target": "This change is already in master and should not be in this commit", "id": 195}
{"pred": "<msg>This is a test that should be removed.", "target": "You renamed `testCleanup` to `testBasic` but left `cleanup.kt` and `cleanup.kt.after` names. I guess they should be renamed to `basic.kt` and `basic.kt.after` as well", "id": 196}
{"pred": "<msg>This is a test that should be in the `testBasic` function.", "target": "Same here. `foo.kt` and `foo.kt.after` better to rename to something meaningful", "id": 197}
{"pred": "<msg>I think this is not needed.", "target": "You forgot about `%`", "id": 198}
{"pred": "", "target": "I'd change the name to `canBeAugmented` or something like.", "id": 199}
{"pred": "<msg>This should be `projectConfiguration.getBoolean(CommonConfigurationKeys.USE_FIR_EXTENDED_CHECKERS, false)`", "target": "It's better to calculate it under the following `if`", "id": 200}
{"pred": "", "target": "@demiurg906 Hope you aware about this problem", "id": 201}
{"pred": "", "target": "Same thing above.", "id": 202}
{"pred": "<msg>I think we can remove this check now.", "target": "You should name value parameters of overriden function same as they named in original function (or you can get errors with function calls with named arguments)\r\n\r\nIt's better to rename `functionCall` in `FirExpressionChecker` to `expression`", "id": 203}
{"pred": "<msg>I think we can remove this class.", "target": "Also it's better to inherit from `FirVariableAssignmentChecker` alias", "id": 204}
{"pred": "<msg>This is the only place where we need to return true.", "target": "Just return `isRightMatch`", "id": 205}
{"pred": "<msg>I think this class is not needed.", "target": "Please rename the containing file to class name", "id": 206}
{"pred": "<msg>I think we should use `ASSIGNED_VALUE_IS_NEVER_READ` and `ASSIGNED_VALUE_IS_NEVER_READ` instead of `ASSIGNED_VALUE_IS_NEVER_READ` and `ASSIGNED_VALUE_IS_NEVER_READ`", "target": "Variable is never read?", "id": 207}
{"pred": "<msg>I think we should use `VARIABLE_INITIALIZER_IS_NEVER_READ` instead of `VARIABLE_INITIALIZER_IS_REDUNDANT`.", "target": "Initializer is redundant (typo)", "id": 208}
{"pred": "<e0>import org.jetbrains.kotlin.fir.FirSession;", "target": "General note: please change `[FIR] ControlFlowAnalyserCheckers support` to some more specific message. The most valuable point here is context which was added to CFA checkers (IMHO).", "id": 209}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a big deal.", "target": "`modalitySource` below is now unused, please remove it.", "id": 210}
{"pred": "<msg>This is not used anywhere.", "target": "`isVisiblityModifier` is also unused now", "id": 211}
{"pred": "<msg>I think we should use `TokenSet` here.", "target": "As I can see, all these functions return a child, not a set of children. Please rename them accordingly.", "id": 212}
{"pred": "<e0><!--", "target": "General note: this is not a refactoring of tests, but minor test data changes.", "id": 213}
{"pred": "<msg>This is not needed.", "target": "Actual change: when remapping parameter symbols, we now need to look at SetValue as well as GetValue.", "id": 214}
{"pred": "<msg>I think this is a bug. `variable` is `IrVariable` and `variable.initializer` is `null`.", "target": "Actual change: adapt code to have same behavior as before.", "id": 215}
{"pred": "<msg>I think we should also set the value of parameters for the default value.", "target": "Real change: be careful with the bytecode patterns for default arguments. This is a little too indirect for my taste. If we start setting parameters for some other reason the store will not have line numbers.", "id": 216}
{"pred": "", "target": "Real change: when remapping parameter symbols we now need to look at SetValue as well as GetValue.", "id": 217}
{"pred": "<msg>I think this is the only place where we need to do this. I think we can just remove the `irIfThen` and the `irSet` calls.", "target": "Real change: remove the JVM-specific intrinsic and use the IR structure instead.", "id": 218}
{"pred": "<msg>This is not a valid syntax.", "target": "I think this is incorrect behavior. Inspection should be available in cases:\r\n* this is one-line property\r\n* this is property with one-line initializer and action == INLINE", "id": 219}
{"pred": "<msg>Why is this needed?", "target": "nit: Rename to bufferingMessageCollector?", "id": 220}
{"pred": "<msg>I think we should use `Path.getExtension` here.", "target": "`File.path` - looks like an incorrect reference.\r\nIn general, we need to revise docs of these functions and use \"file\" only there where it refers to a physical file.", "id": 221}
{"pred": "<msg>This is a bit weird. Why is it necessary?", "target": "Because of this addition, now I feel like they diverge...", "id": 222}
{"pred": "<msg>This is the only place where we need to set the metadata.", "target": "Not 100% sure about this one, though it looks like it only affects imported Java fields and delegated \"synthetic\" fields, whatever that means, so it should not have any effect on emitted metadata.\r\n\r\nThat said, the fact that FIR fields, unlike descriptor fields, are not properties is slightly concerning, because e.g. they currently cannot be referenced. The IR simply doesn't allow it - it *requires* a property symbol for an `IrPropertyReferenceImpl`. FIR-imported Java fields can't have one.", "id": 223}
{"pred": "<msg>I think we should use `PathsKt` instead of `PathsKt` here.", "target": "Let's change all `@SinceKotlin(1.3)` to `@SinceKotlin(1.4)`", "id": 224}
{"pred": "<msg>I think this is not needed.", "target": "This is used to replace the set argument in the call's argument list (see changes in `FirCallCompletionResultsWriterTransformer.kt`). Otherwise `remapArgumentsWithVararg` in `BodyResolveUtils.kt` simply loses the argument (it remaps based on the call argument list). I'm open to other suggestions on how to solve this.", "id": 225}
{"pred": "<msg>This is a bit confusing. It looks like `mapClassSignature` is only used in one place, but it's only used in one place.", "target": "```suggestion\r\n    val superClassType = irClass.superTypes.find { it.getClass()?.isJvmInterface == false }\r\n```", "id": 226}
{"pred": "<msg>I think we should keep the old constructor and add a new one with the new parameter.", "target": "Maybe rename to BranchedValue (similar to one in old backend)?", "id": 227}
{"pred": "<msg>I think this should be `oldToNewArgumentMap`", "target": "Same for nullability and name", "id": 228}
{"pred": "<msg>This is a bit confusing. I think it would be better to say `++a[b, c]` and `a[b, c] += 1`.", "target": "Very important change, thanks for it", "id": 229}
{"pred": "<msg>This is a breaking change. We need to make sure that we don't break existing code.", "target": "Please avoid making return type `MutableList`.\r\nConsider declaring `IrFunction.addExplicitParametersTo(MutableList)` and using it here and in `allParameters` instead.", "id": 230}
{"pred": "<msg>I think this should be `mutableList<IrValueParameter>`", "target": "`parametersList.addIfNotNull(dispatchReceiverParameter)`?\r\nSame below.", "id": 231}
{"pred": "<msg>This is not needed.", "target": "Isn't `private` enough here?", "id": 232}
{"pred": "<msg>I think this should be `Int = if (this) 1 else 0`", "target": "Maybe `explicitParametersCount`? Same for `allParametersNumber`.", "id": 233}
{"pred": "<msg>I think this should be `List<IrValueParameter>`.", "target": "(Not sure if it makes sense but) now it is easy to use exact size here. Same for `allParameters`.", "id": 234}
{"pred": "<msg>I think this is a bug. `this.render()` is called on the constructor.", "target": "```suggestion\r\n        ArrayList<IrValueParameter>(allParametersCount).also {\r\n```", "id": 235}
{"pred": "<msg>I think we should also test the case where the sequence is empty.", "target": "\ud83d\ude01", "id": 236}
{"pred": "<msg>I think this is a bug.", "target": "`bool` has been read above, so I'm pretty much sure the intention was `b`, not `bool`.", "id": 237}
{"pred": "<msg>I think this is a bug.", "target": "Aha, very clear evidence here. According to the comment, the repeating diagnostic error is not reported. So, this one is `VAL_REASSIGNMENT`, but old FE somehow collects and reports an error per error kind maybe.", "id": 238}
{"pred": "<msg>I think this is a bit confusing. I think we should rename this to `dispatchReceiver` and the `this` receiver to `thisReceiver`", "target": "I realized `irClass.thisReceiver` is returned as a default-ish dispatch receiver at the end, so we may just skip here if `function is IrConstructor` in general. But, it's better to return early I think.", "id": 239}
{"pred": "<msg>I think this is a bit confusing. It seems like we're checking if the declaration is an anonymous object, but we're checking if it's an enum. I think we should just check if the declaration is an enum.", "target": "This check looks like ad-hock hack", "id": 240}
{"pred": "<msg>This is the only place where we need to transform childrenVoid.", "target": "`!any` -> `none`", "id": 241}
{"pred": "<msg>This is not correct. The `packageFqName` is the fully qualified name of the class.", "target": "Maybe use explicit return type? Otherwise one needs to check the implementation to see if it's FqName or String", "id": 242}
{"pred": "<msg>This is the only place where we use `fqNameWhenAvailable` to check if the call is a return if suspended call.", "target": "Looks like the simple name check can come first now, since it's cheaper", "id": 243}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a good idea to have a try/catch in a function that throws an exception.", "target": "Should be smartcast", "id": 244}
{"pred": "<msg>I think this is not needed.", "target": "Should be smartcast", "id": 245}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a good idea to have a try/finally in a function.", "target": "Should be smartcast", "id": 246}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have a `PathAwarePropertyInitializationInfo` type that can be used in the `ControlFlowInfo` constructor.", "target": "Please rename it to `EMPTY`", "id": 247}
{"pred": "<msg>This is the only place where we use `fqNameWhenAvailable` to check if the returnIfSuspendedCall is being called.", "target": "Sorry, I didn't notice the first time that there's already `returnIfSuspended` in `Symbols`. Maybe do something like this instead then: `context.ir.symbols.returnIfSuspended.signature == symbol.signature`?", "id": 248}
{"pred": "<msg>I think we can remove this class.", "target": "Please add `@Suppress(\"ObjectPropertyName\")`", "id": 249}
{"pred": "<msg>I think this should be `nextBoolean`", "target": "Samples are meant to clarify function behavior and provide usage examples for documentation readers. This sample do not seem to comply the criteria.\r\n\r\nConsider writing more or less realistic use cases. For example:\r\n```\r\nval isAliceFirst = Random.nextBoolean()\r\nif (isAliceFirst) {\r\n    println(\"Alice goes first.\")\r\n} else {\r\n    println(\"Bob goes first.\")\r\n}\r\n```", "id": 250}
{"pred": "", "target": "I'll take a look at this regression. This fails at line 36, which seems correct to me in the sense that a function that said `@NotNull` actually returns `null`. But I guess this is related to this change: https://github.com/JetBrains/kotlin/commit/ee020ef2903ca25154973ff7d9f93a1213068bf2\r\n\r\nThat is, if the expected type has `@EnhancedNullability` (in this case, I guess so), according to that change, we shouldn't add implicit cast, and that's why it worked so far (since we've never added implicit `NOT_NULL` cast). However, since the expected type is involved in, I wonder it would be way deeper in the resolution, and instead of `fir2ir`, we may need implicit cast during the resolution?", "id": 251}
{"pred": "<msg>I think this is the right place to put this. I think we should move this to `CallableDescriptor.java`", "target": "According to the comment below about `JVM_IR` behavior, I guess this is also related to expected type checking. One thing I'm confused is, as mentioned in TODO below, \"there should be an assertion,\" but it will be a breaking change?", "id": 252}
{"pred": "<msg>I think this is a bug. `isPublicApi` is always `true` if `signature` is `PublicSignature`.", "target": "```suggestion\r\n    return signature == classifier.signature\r\n```", "id": 253}
{"pred": "<msg>I think we should also check that `symbol.descriptor` is not null.", "target": "Here and below, please extract `symbol.signature` to a variable. Also, replace `assert`s  with `require` here, to make use of smart casts to avoid extra `!!`", "id": 254}
{"pred": "<msg>This is a bug fix.", "target": "The call to `isPublicApi` above is no longer needed here and in `getPrimitiveArrayType`", "id": 255}
{"pred": "<msg>This is a bit confusing. It seems like the `!` is not needed.", "target": "Could you please fix the usage of `symbol.signature!!` with `signature`", "id": 256}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a method that returns the descriptor if it is a WrappedDeclarationDescriptor<*>, and if it is a WrappedPropertyDescriptor, then find the descriptor by signature.", "target": "It would good if you put `symbol.signature` into a separate variable and use it without null-assertion", "id": 257}
{"pred": "<msg>This error message is not clear to me.", "target": "```suggestion\r\n            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")\r\n```", "id": 258}
{"pred": "<msg>This is not a public API.", "target": "I mean \r\n`findDescriptorBySignature(symbol.signature\r\n            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")`", "id": 259}
{"pred": "<msg>I think we should add this to the list of allowed originals.", "target": "Something tells me it might be a good time to introduce a `Set` of origins here", "id": 260}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "It's better to use `descType.descriptor` here instead of hardcoded string", "id": 261}
{"pred": "<msg>I think this should be `true` by default.", "target": "Am I right that this is just a stub for future runtime version loading?", "id": 262}
{"pred": "<msg>I think we can remove this.", "target": "Better move it to file with calling conventions then (you're likely going to reuse them in ir plugin)", "id": 263}
{"pred": "<msg>I think this should be `INAPPLICABLE_CANDIDATE`", "target": "Ah, but this and below ones look like good refinements, i.e., can be part of 4th commit.", "id": 264}
{"pred": "<msg>This is the only place where we register the transform.", "target": "You can simplify this as:\r\n```\r\n   project.dependencies.registerTransform(if (...) StructureTransformAction::class.java else StructureTransformAction::class.java) { ... }\r\n```", "id": 265}
{"pred": "<msg>This is a bit confusing. What is the purpose of this?", "target": "Extract this to a method to share between 2 transforms.", "id": 266}
{"pred": "<msg>I think we should add a `@FunctionalInterface` annotation to this class.", "target": "Maintaining this may be painful, I'd rather use Gradle `ProjectBuilder` to create `Project` instance and then to create providers. WDYT?", "id": 267}
{"pred": "<msg>nit: remove this empty line", "target": "Some common things could be extracted from this class and BasicBoxTest, like createPsiFile and TestFileFactoryImpl", "id": 268}
{"pred": "<msg>I think we can remove this line.", "target": "This val can also be a member of `SerializableCodegenImpl`, no need to be top-level for it", "id": 269}
{"pred": "<msg>This should be `PluginUtilsFile`", "target": "Sorry for late notice, but that just came into my mind: by calling this file 'utils', we risk ending up with long file with a lot of unrelated stuff. I'd suggest avoid such technique and name files using logical groups, e.g. 'PluginExceptions'", "id": 270}
{"pred": "<msg>This is not a valid test. You need to use `assertEquals` instead.", "target": "- Use `assertPrints(actualValue, expectedString)` instead of `assertEquals`\r\n- The trailing lambda should be formatted as `str0.last { it.isLetter() }`", "id": 271}
{"pred": "<msg>This is a bit of a misnomer. It should be `str0.last( {it.isLetter()} )`", "target": "Please place the entire `assertFailsWith` call on the single line, otherwise it won't be correctly formatted after a conversion to a runnable sample.", "id": 272}
{"pred": "<msg>This is not needed.", "target": "Better to revert unrelated changes", "id": 273}
{"pred": "<msg>I think this should be `this.merge(other, transform)`", "target": "The name has to be discussed. Currently, when you use JDK8 or higher, there's already [MutableMap.merge](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-) function available coming from JDK. It has the similar signature, but applies the merge operation in-place.\r\nIt would be very confusing to have two `merge` operations on a mutable map, where one merges in-place and the other returns a new map.", "id": 274}
{"pred": "<msg>I think we should keep this.", "target": "@mglukhikh Just in case, improving type info around `try` expression can unmute a bb test.", "id": 275}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have a `TestProject` that has a `ProvideInput` method that returns a `FileSystemLocation` and then call that method from the `TestProject` constructor.", "target": "Why not create Provider<RegularFile> directly?", "id": 276}
{"pred": "<msg>I think this should be `string.last.isLetter()`", "target": "Better to swap `assertFais` and `assertPrints`, because the former will be commented out.", "id": 277}
{"pred": "<msg>I think this is not correct. The type of the variable is not the type of the loopVariable.", "target": "@punzki could you take a look?\r\n\r\nI think this used to work in JVM because bytecode generator is able to fix type mismatch by inserting casts even without explicit IrTypeOperator. I'm not sure if we should rely on this in IR for common lowerings. WebAssembly backend, I'm working on, never encountered a situation where initialization expression type is not a subtype of variable type other than in this case. Do you mind if I make type conversion explicit in this case? Type difference between generic function return type and call expression type is typically generated by frontend, so I guess it is OK.", "id": 278}
{"pred": "<msg>This is a bit confusing. It seems like the original type is the same as the super type.", "target": "I believe we should propagate `!!`-nullability inside `lowerType`, similar to what you did in https://github.com/JetBrains/kotlin/pull/3869. So, subtyping check `T <: Captured(in Foo)!!` will be transformed into `T <: Foo!!`, otherwise we'll just lose information about nullability here", "id": 279}
{"pred": "", "target": "Commit message: to perform aN interprocedural analysis to existING CFA", "id": 280}
{"pred": "<msg>This is a bit confusing. Why do we need to do this?", "target": "It's better to use named arguments here", "id": 281}
{"pred": "<msg>This is not a symbol, it's a reference.", "target": "There is already exists `fun FirReference.getResolvedSymbolOfNameReference(): FirBasedSymbol<*>?` in `FirUtils.kt`\r\n\r\nAlso please avoid using implicit return types for public properties and functions", "id": 282}
{"pred": "<msg>I think this is the only place where we need to remove this.", "target": "Duh, I'm removing my own comments. \ud83e\udd26  Well, on the bright side, at least now we match with JVM_IR behavior.", "id": 283}
{"pred": "<msg>This is the only place where we need to override this method.", "target": "The oldest AGP version used in integration test is 3.1.0(released in March 2018) , so I assume it is the oldest one KGP support, which should have api/implementation configs.", "id": 284}
{"pred": "", "target": "Rename to \"maybeUpdateSettingsScript\"?", "id": 285}
{"pred": "<msg>I think we should remove this function and just call `enableFeaturePreview(\"GRADLE_METADATA\")` in `buildGradleMetadata`", "target": "Change to \"version>= 5.4\".", "id": 286}
{"pred": "<e0>private readonly List<Project> commonProjects = arrayListOf<Project>()", "target": "Make this one private.", "id": 287}
{"pred": "<msg>This is not used anywhere.", "target": "Not sure both these structures are needed.... Will do some experiments...", "id": 288}
{"pred": "<msg>This is a bit confusing. I think we should just use `function.modality` here.", "target": "why not `it`?", "id": 289}
{"pred": "<msg>This is a minor style change, but I think it's better to keep the original formatting.", "target": "Please revert formatting changes unrelated to the code regions you have changed.", "id": 290}
{"pred": "<msg>This is a bit weird, why do we need to serialize this?", "target": "Companion object with just a single private const should be private.", "id": 291}
{"pred": "<msg>This is a bug fix.", "target": "This change should be in a separate commit, or even better, in a separate PR.", "id": 292}
{"pred": "<msg>I think this is a breaking change.", "target": "I don't see much sense in transforming it to `object`. It is instantiated once and then is kept in a private property of `Random` companion object. So no need to have another instance where its reference is stored.\r\nSame for `FallbackThreadLocalRandom`", "id": 293}
{"pred": "<msg>I think this should be `serialVersionUID`", "target": "I still don't get what bad can happen if we set `serialVersionUID = 1L` in all such classes?", "id": 294}
{"pred": "<msg>I think we can remove this test.", "target": "After we settle with serialized representation and serialVersionUID, let's add some serialization stability tests.\r\nSomething like https://github.com/JetBrains/kotlin/blob/1.4.20/libraries/stdlib/jvm/test/collections/CollectionJVMTest.kt#L192-L207", "id": 295}
{"pred": "<msg>This is a bug fix.", "target": "Unrelated change", "id": 296}
{"pred": "<msg>This is a bit confusing. It seems like we're checking if the explicit receiver is a simple name expression, but we're checking if it's a class literal expression. What's the difference between `explicitReceiver` and `explicitReceiver.anyDescendantOfType<KtSimpleNameExpression>`?", "target": "This whole `isConvertibleCallInLambda` function looks scary to me. I'm sure that it's possible to write it in a more simple way. And I'm a bit afraid that you change this scary function. I'd better appreciate the refactoring of this function. But since your code covers more cases I'll merge it", "id": 297}
{"pred": "<msg>I think this should be `abstract class C : B {}`", "target": "Let's change the test case a little bit to use the classes from the hierarchy. (If the classes aren't loaded at runtime, they are not verified by the JVM and thus may contain invalid bytecode, which the test wouldn't catch)\r\n```\r\ninterface A {\r\n    fun foo(): String = \"Fail\"\r\n}\r\n\r\nabstract class B : A {\r\n    abstract override fun foo(): String\r\n}\r\n\r\nabstract class C : B()\r\n\r\nclass D : C() {\r\n    override fun foo(): String = \"OK\"\r\n}\r\n\r\nfun box() = D().foo()\r\n```", "id": 298}
{"pred": "<msg>I think we should also add this to the `isHidden` method of `TypeAlias`", "target": "This was the bug. declaration.isAssignable was passed in the isHidden position.", "id": 299}
{"pred": "<msg>I think we should just remove this line.", "target": "Possible typo detected: Here this option name is `strictMode`; but in `KaptCliOption`, this option name is `strict`. (They were first introduced in https://github.com/JetBrains/kotlin/commit/c83581e6b8155c6d89da977be6e3cd4af30562e5.) // cc @yanex ", "id": 300}
{"pred": "<msg>I think this is a bit confusing. I think we should just say that the type of the generated file is the AP type that was used as originating elements.", "target": "Misspelling: from", "id": 301}
{"pred": "<msg>I think this is a bit confusing, since it's not actually updating the status. Maybe rename to `updateStatus`?", "target": "Here also entry enumeration should be better", "id": 302}
{"pred": "<msg>I think we can remove this test. It's not testing anything useful.", "target": "Please use `assertSame` here. Also the entire method `testPersistedDeserialization` can be inlined.", "id": 303}
{"pred": "<msg>This is not a good idea. It will be a problem if we have a lambda with a return expression that has a unit return type.", "target": "Better to be added with https://github.com/JetBrains/kotlin/commit/def647c0941769e3f7e08ecf242174f74c626e80#diff-5fb4206d83fbcd3e7c827c3b12541010eaf8de08ed8dd2bd470b993cfc8760d9\r\n\r\nAnyway, this also indicates why `Unit` return needs a special handling.", "id": 304}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a method `isExpectedType` that returns `bool` and then use that method here.", "target": "Not sure what makes things look questionable, but it wouldn't be a coincidence that top-down propagation of types (from explicit info of enclosing one to inner item) appears again at https://github.com/JetBrains/kotlin/pull/3968/commits/3815dca0a0298b3698a0ae1b911d8030de4266ac", "id": 305}
{"pred": "<msg>I think this is a bug fix.", "target": "This change is not related. Better to keep it consistent with the other function definitions.", "id": 306}
{"pred": "<msg>I think this should be `transient`", "target": "Ok, I think the variant with all transient fields and `readResolve` will do (without introducing a serialization surrogate). :+1:", "id": 307}
{"pred": "<msg>I think we should add a `render` method to the `KlibMetadataProtoBuf` class.", "target": "IIUC, (secondary) constructors aren't supported (here and in other parts of the machinery).", "id": 308}
{"pred": "<msg>I think this is not needed.", "target": "So, these two break `// FIR_IDENTICAL`, and indeed, these are `FirNamedReference` without pointing any target/candidate symbol. This will fail eventually if you compile this.", "id": 309}
{"pred": "<msg>This is the only place where we need to set the parent.", "target": "These two changes are just clean-up while looking at `parent` setting. `createIrFunction` called `bindAndDeclareParameters` above, which set `parent` directly, which could be unified as `setAndModifyParent` call.", "id": 310}
{"pred": "<msg>I think we should add `@Since` annotation to this class.", "target": "Why does it help? Is it because these functions are in other package than the Char itself? ", "id": 311}
{"pred": "<msg>I think this should be `it.toUppercaseChar()`", "target": "It's not a good idea to use experimental API in samples", "id": 312}
{"pred": "<msg>This is a breaking change.", "target": "Revert", "id": 313}
{"pred": "<msg>I think this is a bug. The `char -> char.toUpperCase()` is not the same as `char -> char.toUpperCase()`.", "target": "revert", "id": 314}
{"pred": "<msg>Why is this change necessary?", "target": "revert", "id": 315}
{"pred": "<msg>This is a bit of a nit, but I think it would be better to use `it.toUpperCase()` here.", "target": "revert", "id": 316}
{"pred": "<msg>I think this is not needed.", "target": "Note that with `uppercase[0] + uppercase(1).lowercase()` capitalize behavior changes a bit", "id": 317}
{"pred": "<msg>I think we should add a `@Experimental` annotation here.", "target": "Add the note about one-to-many and add sample link", "id": 318}
{"pred": "<msg>I think we should use `Char.toLowerCase()` here.", "target": "The only case (`'\u0130'`) where `lowercase.length > 1` the first char (`'i'`) of the `lowercase` is the correct 1-to-1 mapping equivalent.", "id": 319}
{"pred": "<msg>This is not a good name. It is not a boolean.", "target": "Please use `DescriptorVisibilities.isPrivate`", "id": 320}
{"pred": "<msg>I think we should remove this file.", "target": "Please add explicit `// !LANGUAGE: -PackagePrivateFileClassesWithAllPrivateMembers` here for clarity. :)", "id": 321}
{"pred": "<msg>I think we should keep the constructor and mark it as `@ExperimentalUnsignedTypes`", "target": "We will need primary constructor with property when we will make Char inline class again.\r\n\r\nCould we keep primary constructor as is, and make UShort one secondary: \r\n```\r\npublic constructor(code: UShort) : this(chode.toInt())\r\n```\r\n?", "id": 322}
{"pred": "<msg>I think we should add a new state for this.", "target": "Could you please add a comment mentioning that this is about KT-10884? Otherwise looks good :).", "id": 323}
{"pred": "<msg>I think we should add the new FQN to the existing `io.reactivex.rxjava3.annotations.Nullable`", "target": "I'm not sure if it's possible to use trailing commas here? As in I'm not sure what kotlin language level the compiler code targets", "id": 324}
{"pred": "", "target": "Returning constant value seems unnecessary, please use `.also { }` construction on a call site\r\n", "id": 325}
{"pred": "<msg>This is not correct. It should be `irThis()` instead of `irThis()`.", "target": "Wouldn't it result in non-primitive fields being compared first, and primitives second? Shouldn't it be the opposite?", "id": 326}
{"pred": "<msg>This is a bug fix.", "target": "Otherwise it would be `NON_MEMBER_FUNCTION_NO_BODY`, but I don't think the purpose of this test is to check that.", "id": 327}
{"pred": "<msg>This is a bug fix.", "target": "Same here. Not sure what the intention was, though. As per the test name, `conflictingOverloads`, the only conflicting declaration is the class `mest` below.", "id": 328}
{"pred": "<msg>This is a bit weird. Why is this needed?", "target": "This and below are different. Actually, not trivial to _not_ introduce other errors while removing `NON_MEMBER_FUNCTION_NO_BODY` case.", "id": 329}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have the `?:` on the next line, so that it's clearer what the `?:` is for.", "target": "I accidentally used this for `USELESS_VARARG_ON_PARAMETER`, and... after https://github.com/JetBrains/kotlin/commit/40bec30393dea6462ba2548da88296a80d99f15a, this one shows the difference. It turned out that old FE reports that diagnostic on the parameter as a whole. Glad we can find this mistake earlier.\r\n\r\nThere are other diagnostics that will use this, so we can keep this. At least I can confirm it really marks `vararg` modifier. :)", "id": 330}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have a `TODO()` here, so that we don't have to worry about the `UNSAFE_CALL` case.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-44510", "id": 331}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a problem.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-44511", "id": 332}
{"pred": "<msg>This is a bug fix.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-44512\r\n\r\nAlso one below (`withChangesToNull`)", "id": 333}
{"pred": "<msg>This is a bit of a hack, but I don't think it's worth it.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-44513", "id": 334}
{"pred": "<msg>This is a breaking change.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-44515", "id": 335}
{"pred": "<msg>I think this is a bug. The `!` is not needed.", "target": "See comment here: https://youtrack.jetbrains.com/issue/KT-41015#focus=Comments-27-4649573.0-0", "id": 336}
{"pred": "<msg>This is a bug fix.", "target": "These should be `SMARTCAST_IMPOSSIBLE` and I left a TODO there.\r\n\r\nWill see/learn what _predictable_ nullability means at https://github.com/JetBrains/kotlin/commit/41ebfd025e6cc02cc5559b1a79d6335dd3831cb7 :) Any advices/suggestions are welcome!", "id": 337}
{"pred": "<msg>This is a test, so I'm not sure what the best way to fix it is.", "target": "For my own record, this should be rather `ITERATOR_ON_NULLABLE`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/controlStructures/ForLoopWithExtensionIteratorOnNullable.kt#L12", "id": 338}
{"pred": "<msg>I think this is a typo.", "target": "For my own record, these should be rather `HAS_NEXT_FUNCTION_NONE_APPLICABLE` and `NEXT_NONE_APPLICABLE`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/controlStructures/forWithNullableIterator.kt#L11", "id": 339}
{"pred": "<msg>This is a test that should be inlined.", "target": "To be honest, no idea yet.\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/regressions/kt557.kt#L11\r\n\r\nAt DOT operator, the receiver has `TYPE_MISMATCH`, and the call is reported as `UNRESOLVED_REFERENCE_WRONG_RECEIVER` (well, because type mismatches, hm). We don't have a type checker that reports `TYPE_MISMATCH`, don't we?", "id": 340}
{"pred": "<msg>I think this is a good change, but I'm not sure if it's safe to remove this.", "target": "Similar to `kt557`, this should be `UNRESOLVED_REFERENCE_WRONG_RECEIVER`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/testsWithStdLib/coroutines/restrictSuspension/outerYield_1_3.kt#L90", "id": 341}
{"pred": "<e0>}", "target": "Just for the record, many errors in this file should be rather `UNRESOLVED_REFERENCE_WRONG_RECEIVER`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/extensions/throwOutCandidatesByReceiver.kt#L10", "id": 342}
{"pred": "<msg>This is a test that should be reverted.", "target": "Perhaps, this is the only regression. In old FE, `a` has `OPERATOR_MODIFIER_REQUIRED` as well as `COMPONENT_FUNCTION_MISSING`. FIR should report unresolved error rather than inapplicable candidate. :\\\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/declarationChecks/MultiDeclarationErrors.kt#L14", "id": 343}
{"pred": "<msg>This is a bug fix.", "target": "OI/NI behave differently: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/resolve/invoke/errors/unsafeCallWithInvoke.kt#L9\r\n\r\nAssuming NI is default in FIR, I think we should report `UNSAFE_IMPLICIT_INVOKE_CALL` here?", "id": 344}
{"pred": "<msg>This is a good example of how the compiler can optimize this out.", "target": "There are many, many cases like this. Somehow `// !CHECK_TYPE` is not quite working well with FIR yet?", "id": 345}
{"pred": "<msg>This is a C++14 thing, so I'm not sure if it's safe to remove the `INAPPLICABLE_CANDIDATE` macro.", "target": "For the record. In addition to `.`, this is another place where the diagnostic positioning matters: it should be array access.", "id": 346}
{"pred": "<msg>I think this should be `UNSAFE_CALL`", "target": "For the record, this should be `SMARTCAST_IMPOSSIBLE` instead.", "id": 347}
{"pred": "<msg>This is a bug fix.", "target": "The contract for the extension function `case_1` above is that, if returned, the given argument is not null. Thus, `value_2` should be not null here.\r\n\r\nMany other unsafe calls in this file are originated from such incorrect contract propagations.", "id": 348}
{"pred": "<msg>This is a bug fix.", "target": "Note that this test intentionally adds `-UNSAFE_CALL` to focus on `val` reassignments.", "id": 349}
{"pred": "<msg>I think this is a good change, but I think it's better to keep the `INAPPLICABLE_CANDIDATE` in the code.", "target": "After assigning `null`, it's expected to be resolved to:\r\n```\r\nfun <T: String?> T.case_9() = ...\r\n```\r\nabove, but I'd say this looks a lot like https://youtrack.jetbrains.com/issue/KT-41017", "id": 350}
{"pred": "<msg>I think this should be `UNSAFE_CALL`", "target": "For the record, this is also `SMARTCAST_IMPOSSIBLE`.", "id": 351}
{"pred": "<msg>I think this is a mistake.", "target": "This one and one more below are rather resolution errors. It should be `tests.foo`, instead of these `invoke`.\r\n\r\nThe original issue was: https://youtrack.jetbrains.com/issue/KT-37391", "id": 352}
{"pred": "<msg>I think this is a bug.", "target": "This (25) and below two (26, 27) share the same issue. Filed https://youtrack.jetbrains.com/issue/KT-44559", "id": 353}
{"pred": "<msg>I think this should be `UNSAFE_CALL`", "target": "This (30) and below (31) share the same issue. Filed https://youtrack.jetbrains.com/issue/KT-44560", "id": 354}
{"pred": "<msg>This is a bug fix.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-44561\r\n\r\nThere are many more variants in this file as well as: `pos/2.fir.kt` and `pos/7.fir.kt`. ", "id": 355}
{"pred": "<msg>I think this should be a `FirErrors.UNSAFE_CALL` error.", "target": "Forgot to mention this. I've tried this by adding a naive check that just checks an `invoke` function call, but then found several cases that require overrides check in general. There are a couple utils that are used at resolution and `fir2ir` regarding `invoke` lookup, and I guess it will require more refactoring, which I guess would be better to be a separate PR/commit.", "id": 356}
{"pred": "<msg>This is a bit of a misnomer. It's not a function, it's a function that returns a type.", "target": "After this commit `convertKotlinType()` will be always used for properties with delegates.\r\nUsing it only for anonymous-type delegates would be safer, I think.", "id": 357}
{"pred": "<msg>I think this is not needed.", "target": "Minor: we usually start function names with verbs, such as `get`.", "id": 358}
{"pred": "<msg>I think we should add a new error here.", "target": "Instead of `PsiElement`, it's better to be specific: `KtTypeParameterList`: https://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/Errors.java#L178", "id": 359}
{"pred": "<msg>I think we should have a separate error for this.", "target": "Same for `PsiElement`. It's better to use `KtClassOrObject`: https://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/Errors.java#L179", "id": 360}
{"pred": "<msg>I think we should have a separate error for this.", "target": "@mglukhikh already mentioned below, but here, you should use `DECLARATION_NAME` as a positioning strategy.", "id": 361}
{"pred": "<msg>This is the only change in this PR.", "target": "This could be read as just a commented code - please wrap it in quotes like\r\n```\r\n`if () { }`\r\n```\r\nand/or add couple meaningful words (e.g. `case ...`)", "id": 362}
{"pred": "<msg>This is the only change that I'm not sure about.", "target": "If you want to refactor some files according to code style then please do it in separate commit. Otherwise it's hard to understand where are meaningful changes and where is a clenup", "id": 363}
{"pred": "<msg>This is a bit confusing. I would expect the default to be the first parameter in the list.", "target": "In FE 1.0 this diagnostic has two parameters with expected and actual setter parameter type. Please add them here too\r\n\r\nSee `Errors.WRONG_SETTER_PARAMETER_TYPE`", "id": 364}
{"pred": "<msg>I think we should not use KtParameter in the code.", "target": "Redundant import", "id": 365}
{"pred": "<msg>I think this is a typo.", "target": "Missing space (and also redundant chage)", "id": 366}
{"pred": "", "target": "Replacing nullability of `FirTypeRef` doesn't makes any sense, because type ref has no nullability. I rewrote changes in `transformElvisExpression` so they looks more idiomatic", "id": 367}
{"pred": "<msg>Please add copyright header", "target": "I would also add tests with the `correctErrorTypes` option being enabled.", "id": 368}
{"pred": "<msg>I think this is not needed.", "target": "If you need a visual separation of quickfixes blocks, it is better to create a new `KtQuickFixesList` like it's done now for `modifiers` and `overrides`. `KtQuickFixesList.createCombined` was created exactly for that reason :)", "id": 369}
{"pred": "<e0>// @JvmOverloads constructors and ordinary methods don't have \"this\" local variable", "target": "You can avoid additional assignment here:\r\n\r\n```\r\nname = name\r\n    ?: localVariables.getOrNull(index + localVariableIndexOffset)?.name\r\n    ?: originalDescriptor.valueParameters.getOrNull(index)?.name?.identifier\r\n    ?: \"p${index - startParameterIndex}\"\r\n\r\n```", "id": 370}
{"pred": "<msg>This is not needed.", "target": "I suggest specifying return types for non-trivial functions.", "id": 371}
{"pred": "<msg>This is a bit of a hack, but I think it's fine for now.", "target": "That's not actually correct because annotation arguments are resolved in the same transformer as function calls.", "id": 372}
{"pred": "<msg>I think we can remove this class.", "target": "Same here. You need to extend `FirClassChecker` instead, in order to visit `declaration: FirClass<*>`. It looks like member objects are visited/checked for now.", "id": 373}
{"pred": "<msg>This is the only place where we need to check for the setter.", "target": "Minor, but isn't it still worth leaving some comments here (and corresponding part in `RawFirBuilder`) that we still need to build a setter for `val` to report `VAL_WITH_SETTER`?", "id": 374}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a good idea to add this to the public API.", "target": "Nit: This could be `val` since no parameter/context is needed.", "id": 375}
{"pred": "<msg>I think this is a bit confusing. I think it should be `Creates an initializer adapter function that can replace IR expressions of getting constructor parameter value by some other expression.`", "target": "```suggestion\r\n    Also adapter may replace IR expression of getting `this` value by another expression.\r\n```", "id": 376}
{"pred": "<msg>I think this is a bit confusing. I think it should be `Creates an initializer adapter function that can replace IR expressions of getting constructor parameter value by some other expression.`", "target": "```suggestion\r\n    Creates an initializer adapter function that can replace IR expressions of getting constructor parameter value by some other expression.\r\n```", "id": 377}
{"pred": "<msg>I think this is not needed, `contains` is deprecated.", "target": "Due to @UnsafeVariance we cannot trust `elements` collection element static type here. For example, try casting a progression to `Collection<Any>` and call `containsAll(listOf(\"x\"))` on that collection.\r\nTo avoid this problem, cast elements to `Collection<*>` and work only with the result further in the body of `containsAll`.", "id": 378}
{"pred": "<msg>This is not a valid size body. It should be `if (kind == LONG) \"($it).toIntExactOrNull() ?: Int.MAX_VALUE\"`", "target": "Potential overflow for ranges like `-1..Int.MAX_VALUE`.\nAlso let's avoid boxing to a nullable Int where possible.", "id": 379}
{"pred": "<msg>This is not a valid way to write this.", "target": "Potential overflow for a range `0UL..ULong.MAX_VALUE`", "id": 380}
{"pred": "<msg>I'm not sure if this is the right way to suppress this.", "target": "Why not removing `inline` modifier instead? :)", "id": 381}
{"pred": "<msg>This is a breaking change.", "target": "Can be inlined too :)", "id": 382}
{"pred": "<msg>This is not needed.", "target": "Let's not mix up factories creation and registration. E.g, factories can be moved to `AddModifierFix`/`RemoveModifierFix` companions", "id": 383}
{"pred": "<msg>I think we should keep the `reportOn` call here.", "target": "Maybe personal preference, but having `custom` sounds awkward. Just `hasBody`? If it's a default accessor, it won't have a body anyway.", "id": 384}
{"pred": "<msg>This is a bug.", "target": "This is the only one that differs from FE 1.0 behavior, but I can't tell whether it's a false alarm or not. Due to the labeled return below, this lambda exits to outer, and thus won't be invoked multiple times. However, as the function name indicates, I guess the contract for the caller is that the lambda can be invoked _at least_ once, hence the event occurrence count for this variable would be `AT_LEAST_ONCE`, which also means this can be revisited.\r\n\r\nI don't think there is anything we can do regarding CFG/contract here. cc @demiurg906 ", "id": 385}
{"pred": "<msg>This is the only change that I'm not sure about.", "target": "Can we just use `SKIP_CURRENT_DECLARATION_AND_CHECK_NESTED` here? I believe this will let us skip the generated declaration itself (e.g., the anonymous object) but get to the real declarations inside (e.g., the nested class in the enum entry).", "id": 386}
{"pred": "<e0>//", "target": "Note that technically they're identical, but somehow other tags with `{JVM}` bother.", "id": 387}
{"pred": "<msg>I think this is the right place to fix this. The problem is that we are not checking the parent of an enum entry initializer.", "target": "Nit: perhaps point to https://youtrack.jetbrains.com/issue/KT-45115 ?", "id": 388}
{"pred": "<msg>This is not a valid test. You need to use `assertPrints` and `assertPrints` instead.", "target": "This should be `assertFalse`, not `assertFails`. Also, it appears you are missing a closing `)`", "id": 389}
{"pred": "<msg>This is not a valid test. You need to use `assertPrints` instead.", "target": "I don't believe any of these lines should end with a `;`", "id": 390}
{"pred": "<msg>This is the actual fix.", "target": "Let's get rid of this multiline cast by extracting this into a function :)", "id": 391}
{"pred": "<msg>>require [](start = 12, length = 6) This is not needed.", "target": "To be safer (and match with comments), I think it's good to double-check if `delegatedTypeRef`'s `source` is `ArrayTypeFromVarargParameter`.", "id": 392}
{"pred": "<msg>I think we should add a `KtFirDiagnostic.VarargOutsideParentheses()` overload that takes a `Token` and returns a `KtFirDiagnostic<PsiElement>`", "target": "I wonder this could be more specific, i.e., `KtExpression` too.", "id": 393}
{"pred": "<msg>I think we should add a license header here.", "target": "Hm, all these newly added files still have old copyright notice?", "id": 394}
{"pred": "<msg>I think this should be `updated &&`", "target": "Unfortunately this does not do what you probably expect. This is only a return from lambda, no more. It does not stop `processFunctionsByName` itself, sorry.", "id": 395}
{"pred": "<msg>This is not correct. The `putIfAbsent` will return `null` if the key doesn't exist.", "target": "Same problem as before", "id": 396}
{"pred": "<e0>/**", "target": "Can't figure out how to leave a comment to unchanged lines, leaving here, KDoc to Duration class:\r\n\r\n>To construct a duration use either the extension function toDuration, or the extension properties hours, minutes, seconds, and so on, available on Int, Long, and Double numeric types.\r\n\r\nWe should recommend using factories instead of extensions", "id": 397}
{"pred": "<msg>This is a public method, so it should be `public fun convert(value: Int, sourceUnit: DurationUnit, targetUnit: DurationUnit): Duration = convertDurationUnit(value, sourceUnit, targetUnit)`", "target": "Here and everywhere below: \r\n\r\n`Returns a [Duration] equal to this [Int] number of ...`\r\n\r\nProbably should be \r\n`Returns a [Duration] equal to [value] number of ...`\r\nor\r\n`Returns a [Duration] equal to [Int] [value] number of ...`\r\n\r\n\r\nas we no longer have a receiver ", "id": 398}
{"pred": "<msg>I think this should be `LazySafeModeClassDescriptor`", "target": "```suggestion\r\n    private val lazySafeModeClassDescriptor = irClass.module.findClassAcrossModuleDependencies(\r\n```", "id": 399}
{"pred": "<msg>I think we can remove this class.", "target": "I'd get rid of this checker and implemented its logic in `FirInlineClassDeclarationChecker`. \r\n", "id": 400}
{"pred": "<msg>This is a bit confusing. I think we should rename this to `getFirstPrimaryConstructor` or `getFirstPrimaryConstructorProperty`.", "target": "When we call this function, primary constructor and its single parameter is already found. I think it's better to get rid of this function and unite this search with loop on class declarations.", "id": 401}
{"pred": "", "target": "I'd integrate this in `FirInlineClassDeclarationChecker`.", "id": 402}
{"pred": "<msg>This is not needed.", "target": "Also, please declare this as companion object property to avoid constant variable re-creation.", "id": 403}
{"pred": "<msg>This file should be removed.", "target": "I'd integrate this in `FirInlineClassDeclarationChecker`.", "id": 404}
{"pred": "<msg>I think this is not needed.", "target": "DECLARATION_NAME light tree positioning strategy works erroneously here. I will fix this problem myself.", "id": 405}
{"pred": "<msg>I think we should use `BadArgumentTarget` instead of `BadNamedArgumentsTarget`.", "target": "Minor: The description can be in a property and returned in `toString()`, i.e.,\r\n```kt\r\nenum class BadNamedArgumentsTarget(val description: String) {\r\n  NON_KOTLIN_FUNCTION(\"non-Kotlin functions\"),\r\n...\r\n  override fun toString() = description\r\n}\r\n```", "id": 406}
{"pred": "<msg>I think this should be `function.asBadForNamedArgumentTarget?.let`", "target": "The value doesn't change for each argument, so you can make this a lazy property in the `FirCallArgumentsProcessor` class, e.g.:\r\n```kt\r\nval badForNamedArgumentTarget: BadForNamedArgumentTarget? by lazy = function.asBadForNamedArgumentTarget\r\n```", "id": 407}
{"pred": "<msg>I think we should add a note here that this is deprecated and will be removed in the future.", "target": "Now it's time for `SinceKotlin(\"1.5\")`  : )", "id": 408}
{"pred": "<msg>I think we should add a `@InlineOnly` annotation here.", "target": "It would be valuable to support it for nullable type and value.", "id": 409}
{"pred": "<msg>I think we should add a `@InlineOnly` annotation here.", "target": "`typeOf<T>()` provides more precise information about the type, especially its nullability.", "id": 410}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use `assert.isString` here.", "target": "Could you inspect the assertion returned by `checkFailedAssertion` and check that its message contains the information we expect?", "id": 411}
{"pred": "<msg>I think this should be `assertSame`", "target": "```suggestion\r\n/** Asserts that [value] is of type [T], with an optional [message]. */\r\n```\r\n\r\nAlso makes sense to add a note that due to type erasure the type check may be partial, e.g. `assertIs<List<String>>(value)` only checks for the class being `List` and doesn't check the type of elements because it's erased.", "id": 412}
{"pred": "<msg>I think we should add a `@InlineOnly` annotation here.", "target": "```suggestion\r\n/** Asserts that [value] is not of type [T], with an optional [message]. */\r\n```", "id": 413}
{"pred": "<msg>This is not needed.", "target": "Nit: we should probably unify on one style here. Either put in types on the other lines or simplify the other lines as well (I prefer the latter)?", "id": 414}
{"pred": "<msg>I think we can remove this class.", "target": "General note: I would rename this to just `FirConstPropertyChecker` (will do myself) and add all other const checks in this checker (when ready).", "id": 415}
{"pred": "<msg>I think we should use `noValueForParameter` here.", "target": "Could you point out some changed examples?", "id": 416}
{"pred": "<msg>This is a test case that should be removed.", "target": "Nice! :)", "id": 417}
{"pred": "<msg>This is the only place where we need to check the type of the last element.", "target": "Perhaps add a comment on what you're trying to do", "id": 418}
{"pred": "<msg>I think this file is not needed.", "target": "This is due to https://youtrack.jetbrains.com/issue/KT-45344", "id": 419}
{"pred": "<msg>I think we can remove this file.", "target": "Can you turn this comment into a kdoc? Something like the following would make the referenced classes and methods clickable in the IDE.\n```\n/** This is the same as [QuickFixesPsiBasedFactory] but [KtAnalysisSession] can be used in [doCreateQuickFix]. */\n```", "id": 420}
{"pred": "<msg>I think we can remove this file.", "target": "Should this be renamed to `replaceWithSafeCallFixFactory` to match FE1.0? Also, I think the name should be either SNAKE_CAP or lowerCamel.", "id": 421}
{"pred": "", "target": "Please rebase (also for changes in HLDiagnosticConverter.kt)", "id": 422}
{"pred": "<msg>I think we should have a test with `replaceInfixOrOperatorCall` and `replaceInfixOrOperatorCall` as well.", "target": "None of tests from `replaceInfixOrOperatorCall`/`replaceWithDotCal` are passing, may be let\u2019s not generate them?\r\n\r\n", "id": 423}
{"pred": "<msg>I think this is a bug.", "target": "\ud83d\ude2b will fix", "id": 424}
{"pred": "<msg>This is not needed.", "target": "Now this util file, `FirSourceChild`, should be renamed somehow. :) Say, `FirSourceUtils` ?", "id": 425}
{"pred": "", "target": "typo: \"Conventions\"", "id": 426}
{"pred": "<msg>I think we should also test that the error message is the same as the one we have in `testExpectFails`.", "target": "Note that different platforms can have different `toString` representations of `KType` and `KClass`. Better to check that the message contains essential information rather than to expect it in exact form.", "id": 427}
{"pred": "<msg>This is not correct. The argument is not a parent.", "target": "Nit: You can introduce either `val isGet = getArgument == null` or `isSet` and use here and below for `name`.", "id": 428}
{"pred": "", "target": "FYI: this should be part of https://github.com/JetBrains/kotlin/commit/d3b42709fd35748f0d5ec1016da52a08944a951c and probably addressed soon.", "id": 429}
{"pred": "", "target": "Ditto.", "id": 430}
{"pred": "<msg>This is a bit of a nit, but I think it would be better to have the error message in the same line as the message in the other file.", "target": "Nit: below `ConeSimpleDiagnostic` instantiation is written in one line, so I guess this could be in one line too. ;)", "id": 431}
{"pred": "<msg>I think we should use `DiagnosticKind.ValueParameterWithNoTypeAnnotation` here.", "target": "Nice catch! I wasn't aware of this diagnostic when I added: https://github.com/JetBrains/kotlin/commit/9aaa952b39b0e7882e7eb78b3ed981ed7a84ddac", "id": 432}
{"pred": "<msg>This is a test that should be fixed.", "target": "Good to see this unification!", "id": 433}
{"pred": "<msg>This is not a valid code style.", "target": "Nit: seems not part of this change.", "id": 434}
{"pred": "", "target": "Nit: Spaces before and after `:`", "id": 435}
{"pred": "<msg>This is a breaking change.", "target": "Nit: Add newline before", "id": 436}
{"pred": "<msg>This is a test that should be updated to use `NO_GET_METHOD` instead of `UNRESOLVED_REFERENCE`.", "target": "Shouldn't we expect `NO_SET_METHOD` here too? On the assignment part of the `+=`.", "id": 437}
{"pred": "", "target": "Variable `res` is again uninitialized, but maybe it was incorrectly initialized in the previous PR.", "id": 438}
{"pred": "<msg>I think we should check for `isVar` here too.", "target": "Nit: not formatted.", "id": 439}
{"pred": "<msg>I think we should also log a warning if the cache size is not set.", "target": "\"compilation classpath\"?", "id": 440}
{"pred": "<msg>This is not a valid syntax.", "target": "And just as I published this I realised that `B::v.get(this)` is still broken. Oh well.", "id": 441}
{"pred": "", "target": "@mglukhikh  I just found there is `CheckerContext#findClosest<T>()`. Feel free to remove this. Also noticed that, in your experimental branch, its usage is also gone?", "id": 442}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a separate class for each field.", "target": "FYI, this second report is the only thing that breaks `// FIR_IDENTICAL`", "id": 443}
{"pred": "<msg>I think this should be a `TO_STRING` instead of `TO_STRING`.", "target": "The error message needs to render the (expected) property type.\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/rendering/DefaultErrorMessages.java#L478", "id": 444}
{"pred": "<msg>I think this is a good change, but I think it would be better to have a test case for this case.", "target": "This shouldn't be type mismatch: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/EnumEntryAsType.kt#L13", "id": 445}
{"pred": "<msg>This is a syntax error.", "target": "This report seems not right either: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/varargs/varargInSetter.kt#L2", "id": 446}
{"pred": "<msg>I think this is a good change, but I think it would be better to have a separate test for this.", "target": "All changes in this file look not correct: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/variance/InvariantPosition.kt#L41\r\n\r\nBtw, these properties don't have user-contributed setters at all, which means you need to bail out for default accessors.", "id": 447}
{"pred": "<msg>I think we should add a note here that this is deprecated and will be removed in the near future.", "target": "`@SinceKotlin(\"1.5\")`", "id": 448}
{"pred": "<msg>I think we should add a `@since` annotation here.", "target": "Please rename all `delta` arguments name to `absoluteTolerance`", "id": 449}
{"pred": "<msg>I think this should be `PackageViewDescriptorAccessor`", "target": "The name like `PackageViewDescriptor` seems to be more clear to me, but I don't insist here", "id": 450}
{"pred": "", "target": "Revert changes to this file.", "id": 451}
{"pred": "<msg>I think this is a bug.", "target": "Now that the issue is fixed, this comment is no longer needed, so please remove it", "id": 452}
{"pred": "<msg>This is the only place where we need to use `withForcedTypeCalculator`", "target": "Note that this is not necessary as mentioned at: https://github.com/JetBrains/kotlin/pull/4124#discussion_r583631765", "id": 453}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a separate function that returns a list of IrDeclaration objects, and then call that function here.", "target": "nit: this `l` label does not seem to make the code more readable. Consider removing it and just use `@mapNotNullTo` where needed below.", "id": 454}
{"pred": "<msg>I think we should add a `@private` annotation here.", "target": "No tests for cases when StubRenderer has to emit both commits -- kdoc and `stub.comment`.", "id": 455}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a good idea to have a special case for `String` here.", "target": "I'd name it `checkConstantArguments` and change its visibility to `internal`", "id": 456}
{"pred": "<msg>This is a bit weird. I think it should be `<!FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS!>`", "target": "This is incorrect, because `IFoo2` has exactly one abstract method which is inhereted from `IFoo`", "id": 457}
{"pred": "<msg>I think this is a typo.", "target": "Those changes also incorrect. Function `functionDelegate` has default implementation, so `F4` can be `fun interface`. See FE 1.0 counterpart in `functionDelegateClashOnJvm.kt`", "id": 458}
{"pred": "<msg>This is a bit weird. I would expect `F4` to be an interface.", "target": "Also it's worth to implement `FunctionDelegateMemberNameClashChecker` in this PR, because it is part of checkers for `fun` interfaces", "id": 459}
{"pred": "<msg>I think we can remove this import.", "target": "Why is this change requreid?", "id": 460}
{"pred": "<msg>This is a bug fix.", "target": "Ah, I think this is the reason you changed the error's type. You can use `as? FirPropertySymbol` here.", "id": 461}
{"pred": "<msg>I think we should keep the old name for now.", "target": "Not in order?", "id": 462}
{"pred": "<msg>This is a bug fix.", "target": "Filed https://youtrack.jetbrains.com/issue/KT-45814", "id": 463}
{"pred": "<msg>I think this is a good change. It's not clear to me why this is necessary.", "target": "Here and below, filed https://youtrack.jetbrains.com/issue/KT-45816", "id": 464}
{"pred": "<msg>This is a breaking change.", "target": "Please squash this commit with first one before pushing", "id": 465}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have a `Predicate<T>` type that returns a boolean, and then the `Predicate<T>` can be used to check if the element is a `KtProperty`.", "target": "Simplify?\r\n\r\n```suggestion\r\n            return markElement(if (element is KtProperty) element.initializer ?: element else element)\r\n```", "id": 466}
{"pred": "<msg>I think this is a good change, but I think it's better to keep the old syntax.", "target": "FE1.0 does not report this because the type of `x` is `Any` rather than an intersection of `En` and `En2`. It seems the FE1.0 checker is not taking smart cast into consideration for this diagnostic. For example, the following code demonstrate the bug in FE1.0:\r\n\r\n```\r\nfun foo(x: Any, s: String) {\r\n    if (x is String) {\r\n        x == 1 // FE1.0 thinks this is OK\r\n    }\r\n    s == 1 // FE1.0 reports EQUALITY_NOT_APPLICABLE\r\n}\r\n```", "id": 467}
{"pred": "<msg>This is a bit of a hack. I think it's better to just remove the entire `if` statement.", "target": "This is similar to https://github.com/JetBrains/kotlin/pull/4281#discussion_r607421688. BTW, I was surprised to learn `kotlin.String` is not a subtype of `java.lang.CharSequence`.", "id": 468}
{"pred": "<msg>I think this should be `static`", "target": "apReportFile can be non-nullable here, because you already check it's nullability in ?.let about", "id": 469}
{"pred": "<msg>This is a bug fix.", "target": "Minor: I'd leave Other at the end", "id": 470}
{"pred": "<msg>I think we should add these to the `DiagnosticErrors` enum.", "target": "As I can see ILLEGAL_ESCAPE_SEQUENCE has no usages in FE 1.0 and can be dropped.", "id": 471}
{"pred": "<msg>This is not a good name. It is not a function.", "target": "Please create a separate file with functions related to constant expressions (this one, `checkConstantArguments`, `ConstantArgumentKind`, etc.). You can call this file `FirConstChecks.kt` or something like this.", "id": 472}
{"pred": "<msg>I think this is a bit confusing. I think it should be `propertyNameOnTheNextLine`", "target": "Ideally we should skip reporting this since `lazy` is unresolved. But there does not seem to be a way to communicate this between `ErrorNodeDiagnosticCollectorComponent` and the standalone checker.", "id": 473}
{"pred": "<msg>I think this is a typo.", "target": "The problems with delegate is not reported here because `d` is not initialized. But unitialized variable is not reported as for now. If we want to avoid such regression for the time being. I can make the delegate checker report (redundant) issues with delegate. That would introduce more redundant reporting elsewhere though.", "id": 474}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "Different how? Could you please provide an example?", "id": 475}
{"pred": "<msg>This is a bit confusing. It seems like the static constructor is only called for static serializable classes, but it is called for non-static serializable classes.", "target": "'internal' comment here may create confusion that it is related to internal visibility, not the `isInternalSerializable` function. So i'd rather avoid this word here", "id": 476}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a `filterIsInstance` method that returns a list of `Field`s.", "target": "Wrong indent?", "id": 477}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a `filterIsInstance` method that returns a list of `Field`s.", "target": "Shouldn't we do the same for `bitFields` below?\nIf yes, then please add a test checking this.", "id": 478}
{"pred": "<msg>I think this is not correct. IncompleteField is an inner record.", "target": "Is this correct?", "id": 479}
{"pred": "<msg>This is a bit confusing. I think we should just use `firstOrNull` here.", "target": "Would this work for \n```c\nstruct S {\n    char a;\n    struct {\n        __attribute__((aligned(4)))\n        char x;\n    };\n};\n```\n?", "id": 480}
{"pred": "<msg>This is the only place where we generate the golden mask check.", "target": "```suggestion\r\n                    // synthetic constructor is created only for internally serializable classes - so companion definitely exists\r\n```", "id": 481}
{"pred": "<msg>This is the only place where we need to create a `RecordType` from a `StructDecl`.", "target": "This looks better, but still `StructDecl` (and `RecordType`) seems kinda useless here, and it should be pretty easy to get rid of.\r\n\r\n`findNamedParent` still looks redundant: why do we need to _find_ parent, if we already _know_ it? I mean, for the root struct it is the struct itself, and for nested anonymous structs we know the exact parent here.\r\nAlternatively, we could also make parents unnecessary, if we stopped using the root struct as the base for field offsets (which also makes some sense). But I believe this might depend on the way other issues are handled.", "id": 482}
{"pred": "<msg>I think we should keep this line.", "target": "Why inline flag shouldn't be loaded?", "id": 483}
{"pred": "<msg>I think we can remove this line.", "target": "Not sure if this is a good case for our test for `KProperty2`", "id": 484}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a `MainClassRunner` that takes a `workingDir` and a `classFile` and returns the `className` and `workingDir` respectively.", "target": "The method `toRelativeString` may throw an `IllegalArgumentException` when our `classFile.canonicalFile` and `workingDir.canonicalFile` have different roots, but it has been circumvented in our `if` statement,  so there is no need to catch it.", "id": 485}
{"pred": "<msg>This is a bug fix.", "target": "I don't understand how your checker could provoke this change (will recheck myself)", "id": 486}
{"pred": "", "target": "Why this change is needed?", "id": 487}
{"pred": "<msg>I think this should be `KtIconProvider`", "target": "Please, consider adding KtAnalysingSession as receiver parameter for all functions here. This is needed to ensure the contract that we can access symbols only in KtAnalysisSession context", "id": 488}
{"pred": "<msg>This is a bit confusing. Why is `s` not visible here?", "target": "This is a little puzzling. I would like to have a look at that separately from this change.", "id": 489}
{"pred": "<msg>nit: typo in \"for the\"", "target": "Nit: The delegate can be any expression, not just an object literal (e.g., function call, name reference).", "id": 490}
{"pred": "<msg>This is a bit of a misnomer. It's not a method of the `FirClass` itself. It's a method of the `FirClass` itself. It's a method of the `FirClass` itself. It's not a method of the `FirClass` itself.", "target": "This comment should be modified (class _can_ be abstract or sealed)", "id": 491}
{"pred": "<msg>This is a bit weird. Why not just call `deriveFirTestFile`?", "target": "Do you mind fixing the typo in the package name \"uitls\"? :)", "id": 492}
{"pred": "<msg>I think we should add a note here that this is a bug in the checker.", "target": "Suggestion: Be specific and say \"in FirFunctionParameterChecker\" instead of \"in checkers\" (also below in `forConstructorParameters`)", "id": 493}
{"pred": "", "target": "Not sure about naming, maybe \"splitLocalVariableRangesByFinnalyBlocks\"?", "id": 494}
{"pred": "<msg>I think we should keep the `type` argument here, since it's not used in the constructor.", "target": "Is `type` here used?", "id": 495}
{"pred": "<msg>This is a bit confusing. It seems like it's only checking if the offset starts from non-zero, but it's actually checking if the offset starts from zero.", "target": "So for\n```c\nstruct S {\n    struct {\n        int x;\n    };\n    int y;\n};\n```\n`immediateOffset` of the `AnonymousInnerRecord` will be negative? Is this intended?", "id": 496}
{"pred": "<msg>I think we should just check for `functionCall.calleeReference` here.", "target": "Can you rename this to `hasFunctionReferenceErrors`?", "id": 497}
{"pred": "<msg>I think we should use `isInt` here.", "target": "Note that this is `&&` clause, which means the previous one is `true`, where both sides of `||` include `y is Int` or `isInt(y)` with contract `y is Int`. Hence, this is what FIR smartcast detects well (while FE 1.0 didn't warn anything).", "id": 498}
{"pred": "<msg>This is a bit confusing. Why is this needed?", "target": "Note that this test is same as `basicOn` below, but without `SafeCastCheckBoundSmartCasts`, which disables collection of nullability info. As we all know(?), nullability is not available for `== null`, but available for `!= null` in FIR DFA. That's why, with or without that flag, we're seeing those variables as non-null `SomeSubClass`. That flag is on since 1.2, so seeing the same result with `basicOn` seems okay.", "id": 499}
{"pred": "<msg>This is a bit weird. I would expect `en2 is En` to be true, but I don't see any other way around that.", "target": "Unlike cast (`as`),  FE1.0's `is` check doesn't see if the use of type checking defines the expression type. I.e., it never checks exact cast, but always up cast. It's unclear whether FE1.0 doesn't have smartcast info at this point or intentionally uses the user-specified type (`Any?`). In contrast, FIR has smartcast info here (`En`) from the initial value, and regards this (and below) `is` is redundant.", "id": 500}
{"pred": "<msg>This is a bit weird.", "target": "`foo2`'s return type is `T`, but again, with smartcast, its type is seen as `Nothing`. Not sure how `T/Nothing.plus` is resolved, and I think if that becomes unresolved or error type, this warning would be gone. Anyhow, with that resolution, `.plus(\"\")` is `String`, and thus redundant cast. :\\", "id": 501}
{"pred": "<msg>This is a bit weird.", "target": "Quite similar here. `foo()` returns `Nothing` (or technically, `throw`), which makes `is String` up cast. :\\", "id": 502}
{"pred": "<msg>This is a bit weird. I think it should be `this@case_4_3_wrap is ClassLevel1`", "target": "This seems false warning, but smartcast for `this` is `ClassLevel1 & T`. Didn't dig further why smartcast has that, but I suspect that such info is back-propagated from the below `this@... !is ClassLevel1` (if persistent flow is not isolated)?", "id": 503}
{"pred": "<msg>I think this is a bug.", "target": "This and below seem what FIR DFA is doing better (i.e., FE1.0 didn't warn). With proper checks (`if (x == null) return` or `if (x is Any) { ... }`), `x` starts with non-null `Any` in the beginning of the loop, and then after `x = ... equals ...`, smartcast info for `x` is `Boolean`, hence redundant `is Any`.\r\n\r\nIt's irony, though, that, with special handling via preliminary loop visitor, `x`'s type before reassignment is still `Any?` so that `UNSAFE_CALL` behavior matches, hmm.", "id": 504}
{"pred": "", "target": "This code block has just been moved earlier. It is unchanged.", "id": 505}
{"pred": "<msg>This is a bug fix.", "target": "Well, at least, we are consistent now (see line 22 above).", "id": 506}
{"pred": "<msg>This is a bug.", "target": "This one seems interesting. From the path that passed through `if`, `x is String`. From the synthetic `else`, `x == null` (or `x is Nothing?`). After type `or`ing, now `x is String?`. :\\\r\n\r\nI updated `isAcceptableForSmartcast` accordingly, but seems not good enough. I expect type `or` also needs to drop `Nothing?` at every step?", "id": 507}
{"pred": "<msg>I think this is a mistake.", "target": "`-USELESS_NULLABLE_CHECK` appears twice. I think you can just remove this.", "id": 508}
{"pred": "<msg>This is a bit confusing. I think we should just remove the `as?` part.", "target": "I use this assertion to detect remaining cases, but let me know if you think it's better to remove this override as a whole.", "id": 509}
{"pred": "<msg>I think this should be `KtType.makeNullable(this)`", "target": "Maybe some more general function like `KtType.withNullability(newNullability: KtNullablility): KtType`", "id": 510}
{"pred": "<msg>I think this should be `>= 4`", "target": "Should we introduce a `const val` somewhere for this magic number, just in case if we want to expand again?", "id": 511}
{"pred": "<msg>This is not needed.", "target": "This is the same as `left` below so you can just rename `left` to `receiverExpression` (and maybe `right` to `singleArgument`?).", "id": 512}
{"pred": "<msg>This is not needed.", "target": "Btw, this was the motivation of #4340 :)", "id": 513}
{"pred": "<msg>I think this import is not needed.", "target": "Accidentally added? Remove", "id": 514}
{"pred": "<msg>I think we should add a new error message for this case.", "target": "Super nit: Not imported in this commit. But it is in the next one, so no big deal :)", "id": 515}
{"pred": "<msg>This is a bit weird. Why not just `parent.arguments.indexOf(this)`?", "target": "Nit: explicit return type? (even though index sounds like an integer :) )", "id": 516}
{"pred": "<msg>I think this should be `>=`", "target": "And... I expect you to use that constant here as well...", "id": 517}
{"pred": "", "target": "Thank you for adding this override :+1: ", "id": 518}
{"pred": "<msg>I think we can remove this line.", "target": "Nit: could use here Kotlin lambda (also evaluated lazily):\r\n```kotlin\r\n.from({ AndroidGradleWrapper.getRuntimeJars(androidPlugin, androidExt) })\r\n```", "id": 519}
{"pred": "<msg>I think this is a bit confusing. We're not actually using the `classes` variable in the `get` method, but rather using the `facadeOrScriptClass` variable.", "target": "Now `UFile` is also in its final shape I guess. My next step would be to think of ways to simplify/unify `UFile` and `UImportStatement` at each plugin.", "id": 520}
{"pred": "<msg>I think this is not needed.", "target": "`it.offset == 0L` is probably always `false` now.", "id": 521}
{"pred": "<msg>I think this test is not necessary.", "target": "Will this work for big-endian targets?", "id": 522}
{"pred": "<msg>I think we should keep the old code and just use `artifactType.isEmpty()` instead of `artifactType.ifEmpty`.", "target": "I would prefer not to have irrelevant changes in such commits. It makes history analysis more difficult. If you want to suggest such refactorings, please submit a separate PR, or at least in a separate commit.", "id": 523}
{"pred": "<msg>This is a bit confusing. It's not a chain of String::plus, it's a chain of String::plus.", "target": "The `blockDecomposerLoweringPhase` step creates String concatenations, so it needs to run first", "id": 524}
{"pred": "<msg>This is a bit weird, but I guess it's fine.", "target": "This one lowers the `String::plus` to `jsPlus`, so the fix for Longs needs to happen first", "id": 525}
{"pred": "<msg>This is a breaking change. We should keep the old name.", "target": "Same", "id": 526}
{"pred": "<msg>I think we should also check if the node is a member assignment.", "target": "Please note that this checker isn't invoked against member properties yet, and thus we don't see any changes in this commit/PR. Extending this to member properties in general is on my TODO list.", "id": 527}
{"pred": "<msg>This is a bit confusing. It seems like we're adding a constraint to the type of the argument, but we're not adding it to the type of the smartcast. I think we should just add it to the type of the argument, and then we can just check if it's a subtype of the smartcast.", "target": "Here you should report error only when smartcast is unstable", "id": 528}
{"pred": "<msg>I think we can remove this override.", "target": "IMO this property should be `val` (and `originalExpression` should be `val` too actually).\n\nExpressions with smartcasts (as any other expressions) should not be revisited after they were resolved, so having some mutable state in this class is strange", "id": 529}
{"pred": "<msg>I think this TODO is not needed anymore.", "target": "Nit: space after elivs? Below too.", "id": 530}
{"pred": "<msg>I think this should be `receiverExpression`", "target": "I suspect either `receiverExpression` or `lhs` isn't needed here", "id": 531}
{"pred": "<msg>This is a breaking change. The `KtExpression` is not a `FirExpression` but a `KtExpression` with a `FirExpression` as the receiver.", "target": "I suspect either `receiverExpression` or `lhs` isn't needed here", "id": 532}
{"pred": "", "target": "Please make this function `inline`", "id": 533}
{"pred": "<msg>This is a bit confusing. I think we should just use `when` here.", "target": "Name suggestion: `qualifiedCall` (also for light tree changes)", "id": 534}
{"pred": "<msg>I think we can remove this import.", "target": "Then, I think you can remove `import ...impl.FirBlockImpl` below too?", "id": 535}
{"pred": "<msg>I think this should be `inline`", "target": "Nit: additional line", "id": 536}
{"pred": "<msg>I think we should remove these.", "target": "```\r\njava.lang.IllegalStateException: ERROR:\r\nTypeError: Cannot read property '_value_2' of undefined\r\n    at _no_name_provided__74.doResume_0_k$ (returnUnboxedFromLambda_v5.js:15119:42)\r\n    at _no_name_provided__74.invoke_sv8swh_k$ (returnUnboxedFromLambda_v5.js:15095:16)\r\n    at _no_name_provided__1_1.l [as _$this_createCoroutineUnintercepted] (returnUnboxedFromLambda_v5.js:15148:16)\r\n    at _no_name_provided__1_1.doResume_2_0_k$ (returnUnboxedFromLambda_v5.js:13518:17)\r\n    at _no_name_provided__1_1.doResume_0_k$ (returnUnboxedFromLambda_v5.js:13521:17)\r\n    at _no_name_provided__1_1.CoroutineImpl_0.resumeWith_jccoe6_k$ (returnUnboxedFromLambda_v5.js:13428:37)\r\n    at _no_name_provided__1_1.CoroutineImpl_0.resumeWith_bnunh2_k$ (returnUnboxedFromLambda_v5.js:13458:17)\r\n    at startCoroutine (returnUnboxedFromLambda_v5.js:2072:19)\r\n    at Object.box (returnUnboxedFromLambda_v5.js:14990:5)\r\n    at (d8):1:10\r\n```", "id": 537}
{"pred": "<msg>I think we should remove these.", "target": "```\r\norg.junit.ComparisonFailure: expected:<[OK]> but was:<[fail: 2]>\r\n```", "id": 538}
{"pred": "<msg>This is a breaking change. We need to keep the old signature and add a new one.", "target": "This comment becomes stale.", "id": 539}
{"pred": "<msg>I think this is not needed.", "target": "Name suggestion: `postponedLambdaArgs`", "id": 540}
{"pred": "<msg>I think this should be `File(filePath).parentFile`", "target": "Maybe  `val testName  = File(filePath).nameWithoutExtension`", "id": 541}
{"pred": "<msg>This is a bug fix.", "target": "Need to update the above comment (on `.fir` and original) too? Like `// Safe: since run is in-place`", "id": 542}
{"pred": "<msg>I think this is a good idea, but I think it would be better to use `assert.strictEqual`", "target": "Why add the assert here, if the code below checks the same and gracefully handles the case when it is not true?", "id": 543}
{"pred": "<msg>I think we should also check for `INLINE_ONLY_ANNOTATION_FQ_NAME` in the `getIntrinsic` method.", "target": "This should probably be at least `implFun.isEffectivelyInlineOnly()`, because invokedynamic won't work if the function has reified type parameters.\r\n\r\n```\r\nimport java.util.function.Consumer\r\n\r\ninline fun <reified T> foo(x: T) =\r\n    println(\"${T::class.simpleName}($x)\")\r\n\r\nfun call1(c: Consumer<String>, s: String) {\r\n    c.accept(s)\r\n}\r\n\r\nfun main() {\r\n    call1(::foo, \"Hello World!\") // java.lang.UnsupportedOperationException: This function has a reified type parameter and thus can only be inlined at compilation time, not called directly.\r\n}\r\n```\r\n\r\nPlus, if the function is a property accessor, the property has the annotation, not the function (`isEffectivelyInlineOnly` handles that too).\r\n\r\nMaybe it's best not to use invokedynamic with inline functions at all so that they are indeed copied as before?", "id": 544}
{"pred": "<msg>I think this is the right place to fix this issue.", "target": "Yes, I've thought about that (and did some performance measurements on artificial projects). The benefit of creating a function reference with `invokedynamic` instead of an explicit class is rather marginal, and, in fact, it might be even a disadvantage in some very specific corner cases, since you effectively move some work from compile time to execution time, while the rest (loading a class, creating an instance, invoking implementation method) remains the same. I see no actual reason to take extra actions (like creating additional methods) just for the sake of using `invokedynamic`.\r\n", "id": 545}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have a `const` here, so that we don't have to repeat the same thing in two places.", "target": "Please, wrap it with `withValidityAssertion { ... }` to check that current analysis session is still valid", "id": 546}
{"pred": "<msg>I think this is not needed.", "target": "Please, extract this regexp into pattern, so we can easily reuse it for other intentions ", "id": 547}
{"pred": "", "target": "FYI, the future changes regarding this API are here: https://github.com/JetBrains/kotlin/pull/4429", "id": 548}
{"pred": "<msg>This is a bit confusing. I think we should just return `classShortenOption(classLikeSymbol)` here.", "target": "This is quite long, and you make the same call a few times. Maybe you can add a helper function in `ShorteningContext`?", "id": 549}
{"pred": "<msg>I think this should be `this.subList(prefix.size, this.size)`", "target": "Shouldn't this be \"startsWith\", to be consistent with the current implementation for String?", "id": 550}
{"pred": "<msg>I think this should be `ProxlyExhaustive`", "target": "Maybe add a comment for this one too, something like,\r\n```\r\n/**\r\n * This value is used if the subject has type other than `Nothing`, in which case it's literally exhaustive\r\n * only if type's possible cases are properly covered.\r\n */\r\n```", "id": 551}
{"pred": "<msg>I think we should keep the `fun` keyword here.", "target": "Nit: I think 2nd `corresponding` is not necessary? Also, `KtClassOrObject` w/ capital K.", "id": 552}
{"pred": "<msg>This is not correct. The qualifier is a list of FirQualifierPart, not a list of FirEnumEntry.", "target": "```kt\r\nif (!enumClassFir.isEnumClass) return null\r\n```", "id": 553}
{"pred": "<msg>This is the only change in this file.", "target": "FYI: Looks like that current default inline scheme is overcompilicated in that sense that it's possible to keep general scheme here with `$default` wrapper that fills default values and then call inline function without any inlining at this step.\r\nAnd only on call site both function could be combined together. But it require some work in compatibility aspect", "id": 554}
{"pred": "<msg>I think this should be `CallableReturnTypeUpdaterApplicator.Type`", "target": "Minor formatting: should be placed at new line", "id": 555}
{"pred": "<msg>This is not needed.", "target": "Maybe expandedClassSymbol?\r\nAlso, please add KDoc", "id": 556}
{"pred": "<msg>I think this should be `withIsOperandOfIsOperator`", "target": "Nit: Capitalize \"I\" in first \"is\"", "id": 557}
{"pred": "<msg>I think we should pass `areBareTypesAllowed` here.", "target": "Nit: Can you name the last parameter? `isOperandOfIsOperator = false`", "id": 558}
{"pred": "", "target": "Nit: unnecessary new line", "id": 559}
{"pred": "<msg>I think this should be `List<String>`", "target": "Maybe add a comment with example? I guess it's like: p.q.Outer.Inner.Companion -> [p, q, Outer, Inner, Companion] (or reversed)?", "id": 560}
{"pred": "<msg>I think we can remove this and just use `ElementToShorten` directly.", "target": "NAMING: Again, I would use `useStarImport` here", "id": 561}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a big deal.", "target": "byteArray should be passed instead of valueBytes, I suppose", "id": 562}
{"pred": "<msg>This is a bit confusing. It's not a function, it's a function call.", "target": "NAMING: How about `processCallableQualifiedAccess`?", "id": 563}
{"pred": "<msg>This is a bug fix.", "target": "FE1.0 does accept this because the non-top level `MyBase` is resolved in FE1.0. However, FIR does not honor non-top level type alias, hence `MyBase` is rejected here.", "id": 564}
{"pred": "<msg>This is a syntax error.", "target": "This should be captured val initialization, which means the current captured writes detector misses something... Anyway, reporting a different diagnostic would be okay-ish. :\\", "id": 565}
{"pred": "<msg>I think this is a typo.", "target": "`UseCallsInPlaceEffect` is enabled since 1.3, so having the same results with `..._after.fir.kt` is expected.", "id": 566}
{"pred": "<msg>This is a bit weird. Why is it necessary?", "target": "This is a false alarm, and the reason behind this is that property initialization info is kind of aggregated to property symbol only, i.e., property accesses/writes with different receivers aren't differentiated yet. I left a TODO above in a related place. A quick trial reveals this is not a trivial issue. I'll keep working on it, while these changes are reviewed. Seems not harmful for full pipeline at the moment.", "id": 567}
{"pred": "<msg>I think we should add a new type here.", "target": "The `source` parameter here is actually `rValue.source` so you can just remove it so it's not confusing which element's source it is, and just use `rValue.source` everywhere (or a local variable for `rValue.source`).", "id": 568}
{"pred": "", "target": "Missing `WRONG_MODIFIER_TARGET`? cc @punzki ", "id": 569}
{"pred": "<msg>I think this should be `open fun initialize(context: CommonBackendContext, loopVariable: IrVariable, forLoopHeader: ForLoopHeader, loopVariableComponents: Map<Int, IrVariable>)`", "target": "Maybe you could move this initialization over to `transform` and change this function to `abstract fun analyze(forLoopHeader: ForLoopHeader)`. That way subclasses don't need to remember to call `super.initialize(...)` and also you only need the `ForLoopHeader` for now in `KonanBCEForLoopBodyTransformer`.", "id": 570}
{"pred": "<msg>This is a bit confusing. Why not just return `getStubOrPsiChild(KtStubElementTypes.CONTEXT_RECEIVER_LIST)`?", "target": "You don't need to check if stub != null\n`getStubOrPsiChild` already handle both cases\n\nThat comment may be applied to other similar methods you've added previous commits", "id": 571}
{"pred": "<msg>This is a very bad example. It should be able to be used without context.", "target": "Are there any cases that start working (green) after this commit applied?\nIf there are ones, maybe it's worth adding them here", "id": 572}
{"pred": "<msg>I think this is not needed.", "target": "I think some kind of receivers ambiguity diagnostic should be there as well\n", "id": 573}
{"pred": "", "target": "Looks like `WITH_REFLECT` is not needed in this test.\r\n\r\nAlso, it fails on the old JS backend (`JsCodegenBoxTestGenerated$DelegatedProperty.testDelegateToAnotherMutable`), please add `IGNORE_BACKEND: JS`", "id": 574}
{"pred": "<msg>I think we should remove these.", "target": "`WITH_RUNTIME` is not needed because it's implied by `WITH_REFLECT` (also in `delegateToGenericJavaProperty.kt` and `delegateToAnother.kt`)", "id": 575}
{"pred": "<msg>This is a bit hacky, but I think it's fine.", "target": "`IrConst<*>` expression is just a constant literal. It doesn't imply anything about given call expression being a result of direct invoke optimization for a lambda.", "id": 576}
{"pred": "<msg>This is a bit confusing. It seems like we are not actually checking if the left is a primitive or not.", "target": "Please, add a test with `@EnhancedNullability Int` (`@NotNull Integer getInteger()` in Java).", "id": 577}
{"pred": "<msg>I think this should be `FunctionTransformer`", "target": "Minor: Could you rename this  to `loopBody`?", "id": 578}
{"pred": "<msg>I think this is a bit confusing. I think it should be `compareConstValue` or `compareConstValue`", "target": "The changes to check for `val`s are good! Could you please expand on the tests too?", "id": 579}
{"pred": "<msg>This is a breaking change. We should keep the old method and deprecate it.", "target": "This was a code duplication, that was unified in one single _inline generic_ method for all types. This logic should be in one place, so we will reduce the number of potential issues.", "id": 580}
{"pred": "<msg>I think this is a bit of a hack. I think we should just use a regex to check if the string contains a dot.", "target": "`s` - is a body of a floating point number, for example in `500e100` - `s` = 500. But there WAS **no check** that it contains valid characters (digits), so we were in the situation when we could start processing of invalid string with a further logic and return `Infinity` in case of long string (`38` characters for `float` and `308` for `double`). ", "id": 581}
{"pred": "<msg>This is a bit confusing, since the `d` is not a map.", "target": "We use codegen/bytecodeListing tests for such cases, it makes ABI comparison between old and new back-end easier.", "id": 582}
{"pred": "", "target": "Please, add irText tests for a class with context receiver.", "id": 583}
{"pred": "<msg>This is the only place where we have to do this. We should just remove the `else` branch and just have the `buildResolvedTypeRef` call the `buildResolvedTypeRef` method.", "target": "Nit: maybe `when(types.size) { ... }` instead of `if ... else if ... else`?", "id": 584}
{"pred": "<msg>This is not correct. The class symbol is not a regular class symbol.", "target": "Nit: this change made the line shorter, so line wrapping seems not necessary.", "id": 585}
{"pred": "<msg>>lable [](start = 58, length = 4) I think we should just remove this.", "target": "```suggestion\r\n            // Only report label issues if the label is set and the receiver stack is not empty\r\n```", "id": 586}
{"pred": "<msg>>lable [](start = 58, length = 4) nit: lable", "target": "Calculate `val = implicitReceiverStack.lastDispatchReceiver()` only one time and use it in two places (here and in `else` branch).", "id": 587}
{"pred": "<msg>This is the only place where we need to do this.", "target": "Hi @mglukhikh , I am not confident about this change here. Without it, the logic would convert a `Captured<in String>` to a `String`, which seems wrong. It should instead be converted to `Any` instead. I thought about this and it seems to be the case for `out` projection as well. Hence it appears `lowerType` is useless.", "id": 588}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "It can be optimized since `mark` always returns only single element:\r\n\r\n```suggestion\r\n                        add(markSingleElement(child))\r\n```\r\n\r\n", "id": 589}
{"pred": "<msg>This is not used anywhere.", "target": "TODO: Split adding new argument and refactoring", "id": 590}
{"pred": "<msg>I think we can remove the `extensionArgumentReceiver` parameter from the method signature.", "target": "TODO: Split adding new argument and refactoring", "id": 591}
{"pred": "<msg>This is a bit of a hack, but I'm not sure how to do it better.", "target": "Before someone asks, the problem is that `allScopes` is protected in `IrElementTransformerVoidWithContext` which is in backend.common while `isInPublicInlineScope` is defined in backend.jvm, i.e., we can't define this utility as an extension function without refactoring somewhere. And I don't want to make such a refactoring part of this PR.\r\n", "id": 592}
{"pred": "<msg>This is a bug fix.", "target": "Property `fir` has `FirRegularClassSymbol` type. Can you please rename it back?", "id": 593}
{"pred": "<msg>This is not used.", "target": "Super minor: if `classSymbol` below is renamed to `superClass`, isn't it aligned if we renamed this to `superClassId`? :)", "id": 594}
{"pred": "<msg>I think this is not needed anymore.", "target": "This is probably not related to this PR, looks like someone forgot to update the expected data for this test.", "id": 595}
{"pred": "<msg>I think we should also add a check that the lock is not already locked.", "target": "Super minor, but do we usually name something like `localLock`? :)", "id": 596}
{"pred": "<msg>I think we should use `Pair` here instead of `Pair<Annotation, Set<AnnotationQualifierApplicabilityType>>`", "target": "I don't insist here, but we're trying to use one-capital-letter names for type parameters (e.g. `A` here)\nSame for AbstractAnnotationTypeQualifierResolver\n", "id": 597}
{"pred": "<msg>I think this class is not needed.", "target": "ditto about parameter name\n", "id": 598}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a separate method for this.", "target": "Please, add `BothTowerLevelAndContextReceiversGroup` case to the when at `recordLookups` below, too", "id": 599}
{"pred": "<msg>This error message is not clear to me.", "target": "`$valueExpression` will always just print the node type, consider adding `getElementTextWithContext()` and/or info about `valueParameterDescriptor`", "id": 600}
{"pred": "<msg>This is the only place where `type` is used.", "target": "I guess the `let` call can be inlined now for simplicity\r\n```suggestion\r\n        visitor.visitType(type.flags)?.let(type::accept)\r\n```", "id": 601}
{"pred": "", "target": "Same", "id": 602}
{"pred": "<msg>I think we should use `isEmpty` here.", "target": "Can be rewritten by the following way without redundant access to the map:\r\n\r\n```suggestion\r\n        // ASM caches the result of getCommonSuperClass, so it is safe to do remove\r\n        val mapping = mappings[type]\r\n        if (mapping != null) {\r\n            val result = mapping.remove(superType)\r\n            if (mapping.isEmpty()) {\r\n                mappings.remove(type)\r\n            }\r\n            return result\r\n        }\r\n        return false\r\n```", "id": 603}
{"pred": "<msg>I think we should use `KonanConfigKeys.LAZY_ENTRY_ENTRY_NAME` instead of `EntryPointName`", "target": "The absolute majority of our users invoke compiler via Gradle, so it makes sense to show how to adjust Gradle script instead of compiler flag. Let's change the message to the following:\r\n\r\n> Android Native executables are currently built as shared libraries with NativeActivity support, but the default behavior is going to change in 1.7.0 to build regular executables instead.\r\n> To keep using NativeActivity support, add `binaryOptions[\"androidProgramType\"] = \"nativeActivity\"` to your androidNative executable configuration block in Gradle script:\r\n> ```\r\n> binaries {\r\n>     executable {\r\n>         binaryOptions[\"androidProgramType\"] = \"nativeActivity\"\r\n>     }\r\n> }\r\n> ```\r\n> See https://youtrack.jetbrains.com/issue/KT-49406 for more details.\r\n\r\nI'll populate the YouTrack ticket with a content (including other ways to tune the compiler behavior) a bit later.", "id": 604}
{"pred": "<msg>I think this should be `listOf(\"-fPIE\", \"-pie\")`", "target": "Let's change these lines to something like this:\r\n```kotlin\r\nwhen (kind) {\r\n    LinkerOutputKind.EXECUTABLE -> +listOf(\"-fPIE\", \"-pie\")\r\n    LinkerOutputKind.DYNAMIC_LIBRARY -> +listOf(\"-fPIC\", \"-shared\")\r\n    LinkerOutputKind.STATIC_LIBRARY -> {}\r\n}\r\n```\r\nMotivation:\r\n* It is more explicit that we add these flags only when producing executables.\r\n* Nothing will go wrong if we add another `LinkerOutputKind`.", "id": 605}
{"pred": "<msg>This is the only place where we need to call `arrayListOf`", "target": "@dnpetrov Please, take a look at this part", "id": 606}
{"pred": "", "target": "Please put this property just after `continuationToRetainedCompletionConverter`, to improve the readability.", "id": 607}
{"pred": "<msg>I think this should be `unitAsNullableUnit(3)`", "target": "Please add a test for calling `unit` method. Not sure why is it missing.", "id": 608}
{"pred": "<msg>This is not used.", "target": "The option name should indicate that it affects only Obj-C export. E.g. `unitSuspendFunctionObjCExport`.", "id": 609}
{"pred": "", "target": "Leftover.", "id": 610}
{"pred": "<msg>I think we can remove this method and just use `ConeClassifierLookupTag.toSymbol` directly.", "target": "Remove this file from commit, because it was moved from `:resolve` module to `:providers` (`compiler/fir/providers/src/org/jetbrains/kotlin/fir/resolve/LookupTagUtils.kt`)", "id": 611}
{"pred": "", "target": "Should be moved into previous commit", "id": 612}
{"pred": "<msg>I think we can remove this suppression.", "target": "It's more clean to write cast right inside recievier of `map` call. `(types as List<KotlinType>).map {...}...`", "id": 613}
{"pred": "<msg>This is not needed.", "target": "You can unsafely cast `newAttributes` to `List<TypeAttribute<*>>` here", "id": 614}
{"pred": "<msg>This is a bit of a hack, but I think it's fine.", "target": "Same", "id": 615}
{"pred": "<msg>This is not needed.", "target": "Same", "id": 616}
{"pred": "<msg>I think we should add this to the `analyzerServices.platformConfigurator` instead.", "target": "It's better to use `useImpl<TypeAttributeTranslators>()` here. `project` will be injected automatically", "id": 617}
{"pred": "<msg>I think we should add a note here that this is a temporary workaround until we have a better solution.", "target": "It's not `TODO`. IR backed should not support attributes by design", "id": 618}
{"pred": "<msg>I think we should also check that the type is not null.", "target": "Maybe it's better to replace `getCustomAttributes` with `hasCustomAttributes` and only then filter attributes?", "id": 619}
{"pred": "<msg>This is a temporary workaround for the issue.", "target": "Minor: dropped.", "id": 620}
{"pred": "<msg>I think this TODO is not needed.", "target": "`FieldPropertyLValue` is created for Java fields. Such properties should not have context receivers. Add an assertion here that `contextReceiverValues.isEmpty()`.", "id": 621}
{"pred": "<msg>I think this is not needed anymore.", "target": "Ignore this, will revert. Completely misread the problem :sweat_smile: \r\n", "id": 622}
{"pred": "<msg>This is a breaking change. We should keep the old behavior and add the new one.", "target": "Put separate check for `label.size > 1` and report an error", "id": 623}
{"pred": "<msg>Please avoid wildcard imports.", "target": "Revert", "id": 624}
{"pred": "<msg>This is a bit weird. Why do we need to return here?", "target": "Put `TODO: Update context receivers`", "id": 625}
{"pred": "<msg>I think we can remove this file.", "target": "Remove", "id": 626}
{"pred": "<msg>This is a mutable list, so we can't change it.", "target": "Can I revert it to `List`?", "id": 627}
{"pred": "<msg>I think we should keep the old signature and add a new one.", "target": "Revert (see the comment above)", "id": 628}
{"pred": "<e0>}", "target": "What about rendering functions, classes, and properties with context receivers?", "id": 629}
{"pred": "<msg>I think this is a good idea. I think we should add a TODO to remove this.", "target": "```suggestion\r\n * JVM signature of a synthetic method for properties which delegate to another property,\r\n * which constructs and returns a property reference object.\r\n * See https://kotlinlang.org/docs/delegated-properties.html#delegating-to-another-property.\r\n *\r\n * Example: `JvmMethodSignature(\"getX$delegate\", \"()Ljava/lang/Object;\")`.\r\n```", "id": 630}
{"pred": "<msg>I think this should be `plugins/atomicfu/atomicfu-compiler/test`", "target": "Probably only `*/testData/` required here ", "id": 631}
{"pred": "<msg>This is a bit of a misnomer. It's not a test, it's a test.", "target": "Could the function reference `Char::isLowerCase` be passed to `CharSequence.all` directly?\r\nThe introduction of a separate `val` doesn't seem to enhance clarity.", "id": 632}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use `assertTrue` here.", "target": "Introducing a named function is more Kotlin-ish than creating a lambda just to assign it to a `val`:\r\n```\r\nfun String.containsAllCharsOf(other: String): Boolean {\r\n    return other.all { this.contains(it) }\r\n}\r\n```", "id": 633}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use `assertTrue` here.", "target": "Is it equivalent to `line.containsAllCharsOf(sequence)`? Reusing the existing function would be better.", "id": 634}
{"pred": "<msg>This is not a valid test. It should be `assertTrue(containsWhiteSpace)`", "target": "In samples we use `assertPrints(value, stringRepresentation)` which is converted to \r\n```\r\nprintln(value) // stringRepresentation\r\n```\r\nin Kotlin website. E.g. the `splitToSequence` sample above is converted to this runnable code in docs website: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split-to-sequence.html", "id": 635}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use `val containsWhiteSpace: Boolean = name.any{ |s| s.startsWith(\"fatima\") }` instead of `val containsWhiteSpace: Boolean = name.any{ |s| s.startsWith(\"fatima\") }`", "target": "Could we use `assertPrints(name.any { it.isWhitespace() }, false)` directly?", "id": 636}
{"pred": "<msg>I think this is not needed.", "target": "`Class.getDeclaredAnnotation` is missing on JDK6 and older versions of Android, so the corresponding tests (`compiler/tests-different-jdk`, `compiler/android-tests`) are failing. Let's use `Class.getAnnotation` instead", "id": 637}
{"pred": "<msg>I think this should be `copyFiles`", "target": "It would be perfect to add comment about symlinks behavior with YouTrack issue ID.", "id": 638}
{"pred": "<msg>This is a bit confusing. I think we should just use `newAnnotations` here.", "target": "There is a strange(?) implementation of FilteredAnnotations.isEmpty() that some of the tests rely on: https://github.com/JetBrains/kotlin/blob/master/core/descriptors/src/org/jetbrains/kotlin/descriptors/annotations/Annotations.kt#L71", "id": 639}
{"pred": "<msg>I think we should add a note here that this is a temporary workaround until we have a better solution.", "target": "We need little bit more checks :) and since the task is abstract we can avoid nullability\r\n```\r\n@get:PathSensitive(PathSensitivity.ABSOLUTE)\r\n@get:IgnoreEmptyDirectories\r\n@get:InputFiles\r\n@get:SkipWhenEmpty\r\nabstract var files: FileCollection\r\n\r\n@get:OutputDirectory\r\nabstract var destDir: File\r\n```", "id": 640}
{"pred": "<msg>I think this should be `files(File(appleFrameworkDir(envFrameworkSearchDir), framework.outputFile.name))`", "target": "i think better:\r\n```\r\nif (envSign != null) task.doLast {\r\n```", "id": 641}
{"pred": "<msg>This test is not needed.", "target": "Makes sense to check an input string of \"abc123de56\" to ensure that only the _first_ match is actually replaced.", "id": 642}
{"pred": "<msg>I think this should be `MethodVisitor?`", "target": "Nice, reducing the size of the cache!", "id": 643}
{"pred": "<msg>This is a bit confusing. I think it should be `convertIrConst` and `convertIrCall`", "target": "That might be a bit too optimistic because of possible underflow.\r\nPlease, add the following test:\r\n```\r\nfun box(): String {\r\n    val M1 = Int.MAX_VALUE - 2\r\n    val M2 = Int.MIN_VALUE\r\n    var t = 0\r\n    for (x in M1..M2-1) {\r\n        ++t\r\n        if (t > 3) return \"Failed: too many iterations\"\r\n    }\r\n    if (t != 3) return \"Failed: t=$t\"\r\n    return \"OK\"\r\n}\r\n```\r\nWe are not going to do proper value range analysis here. However, there are some relatively frequent practical cases when we know for sure that `expr - 1` will never underflow. In particular KT-22334 listed one such example (`array.size - 1`; can never underflow because `array.size` is always non-negative). Same is true about `collection.size` and `charSequence.size`.", "id": 644}
{"pred": "<msg>This is the only change that I'm not sure about. The rest is just formatting.", "target": "Minor: I'd rather write it as \r\n```\r\nexpression.type.run { ... } ||\r\n    expression.run { ... }\r\n```\r\notherwise it's somewhat harder to understand that the last `||` is not actually a part of condition under `expression.type.run { ... }`.    ", "id": 645}
{"pred": "<msg>I think this is not needed.", "target": "Minor: give it a meaningful name - not just `matcher`, but something like `reversedArrayMatcher`.", "id": 646}
{"pred": "", "target": "unused", "id": 647}
{"pred": "<msg>I think we should add a new `IrGetValue` class that has a `copyWithOffsets` method.", "target": "Minor: probably it could be extracted to extension function, same as for IrConst", "id": 648}
{"pred": "<msg>This is not equivalent.", "target": "There's a similar pattern in line 620 for CharSequences and Strings, would you want to improve it as well?", "id": 649}
{"pred": "<msg>I think this is not needed.", "target": "Minor: better add an assertion that `insn.opcode == Opcodes.CHECKCAST` or something like that.", "id": 650}
{"pred": "<msg>I think this should be `isInlineOrValueClass()`", "target": "BTW even though this change doesn't seem to affect anything, it looks a bit incorrect because multi-field _value_ classes (`LanguageFeature.ValueClasses`, the feature which @zhelenskiy is working on) will not be represented in the way inline classes are represented in Kotlin metadata. We'll need at least a list of all primary constructor properties, not just the single one.\r\n\r\nBut since we haven't started working on, or even discussing, metadata for multi-field value classes, I don't think it matters a lot.", "id": 651}
{"pred": "", "target": "Please, add `// CHECK_BYTECODE_LISTING` directive and re-run the test.\r\nIt'll produce `kt50986.txt` file containing generated bytecode signatures.\r\nCheck that it passes in the old back-end as well (to make sure that we don't break ABI).", "id": 652}
{"pred": "<msg>I think this should be `List<ClassBinarySignature>`.", "target": "cc @qwwdfsad ", "id": 653}
{"pred": "<msg>I think we should add `@External` annotation here.", "target": "IMHO an API where there is just a registry of `AdditionalDataProvider<T, Key<T>>` may express the intention in a nicer way. Then, the registry is realized during model building and adding new providers will fail (as a safety check).", "id": 654}
{"pred": "<msg>This is a bit confusing. It seems like this method is only used in one place, and it's only used in one place. Maybe we can move it to a utility class?", "target": "serializable annotation always have one argument so I think we may skip a loop here", "id": 655}
{"pred": "<msg>This was unused.", "target": "Well spotted issue!", "id": 656}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a good idea to have a `get` method that returns a list of all the types.", "target": "I have a question about the `member` property.\r\n\r\nLooking at the `Javadoc` of the `Member` interface, it appears that this interface is not inherited by any classes other than `Method`, `Constructor` and `Field`.\r\nhttps://docs.oracle.com/javase/jp/8/docs/api/java/lang/reflect/Member.html\r\nIn other words, this `else` clause is executed when the `member` property is `null`.\r\n\r\nNow, is there a situation where the `member` property is `null` in `InlineClassAwareCaller`?\r\nIf present, modify the processing in `else`, and if not, modify the error message, respectively.", "id": 657}
{"pred": "<msg>This is not a constant.", "target": "```suggestion\r\n    // Copy-pasted from com.intellij.openapi.util.BuildNumber#FALLBACK_VERSION\r\n    private const val FALLBACK_IDEA_BUILD_NUMBER = \"999.SNAPSHOT\"\r\n```", "id": 658}
{"pred": "<msg>This is not needed", "target": "As mentioned in the PR, these stepping tests are not directly related to this PR, but support the corresponding PR on the plug-in side by clarifying the stepping behavior of the JVM backend v/ the IR backend.", "id": 659}
{"pred": "<msg>I think this is a bit confusing. I think we should have a method `filterIsInstance` that returns `true` if the type is a `FirTypeParameter` or `FirTypeParametersOwner`.", "target": "```suggestion\r\n        (container as? FirTypeParametersOwner)?.typeParameters?.withIndex()?.toList().orEmpty()\r\n```", "id": 660}
{"pred": "", "target": "Please add `// FIR status: ...` line with some description what's happening now", "id": 661}
{"pred": "<msg>This is a bit confusing. It's not a function, it's a function.", "target": "```suggestion\r\n        val symbolTableDecorator = context.symbolTable as FragmentCompilerSymbolTableDecorator\r\n```", "id": 662}
{"pred": "<msg>I think this is a bit too much. We can just add `kotlinParameterTypes.size + 31` to the end of the argument list.", "target": "```suggestion\r\n        val extraArgumentsTail = (if (isDefault) ((kotlinParameterTypes.size + Integer.SIZE - 1) / Integer.SIZE) + 1 else 0) +\r\n```\r\nMinor, but let's either use numbers in both places, or the constant `Integer.SIZE` in both places. :)", "id": 663}
{"pred": "<msg>I think we should add `@MustBeDocumented` here.", "target": "It should be opt-in. See the explanation in https://github.com/JetBrains/kotlin/pull/4818#discussion_r874853864.", "id": 664}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have the `fun` be a property of the `PropertyDescriptor` instead of a property of the `PropertyDescriptor`.", "target": "Seem a bit duplicated. Maybe extract a tiny inner class for `objCPropertyNames` and `swiftPropertyNames`?", "id": 665}
{"pred": "<msg>I think we should use `clazz.getObjCName(true)` here.", "target": "Please add `Swift` to the enclosing function name then.", "id": 666}
{"pred": "<msg>This is not a valid syntax.", "target": "Please use `assertEquals` instead:\r\n```\r\nimport kotlin.test.assertEquals\r\n\r\n...\r\n\r\nassertEquals(1, ::s.getDelegate())\r\n```", "id": 667}
{"pred": "<msg>I think this is not needed.", "target": "Maybe also change the type to e.g. String in one of the tests, to check that not only integer types are supported. :)", "id": 668}
{"pred": "<msg>I think we should also add the error message for the case where the declaration is not a property or function.", "target": "When a user gets this error, it might be a bit unclear for them that the error is caused by annotation targets.", "id": 669}
{"pred": "<msg>I think this should be \"Refined declaration overrides non-refined declarations from {0}\"", "target": "The message is probably not clear enough for different kinds of refinements, e.g. if super method is refined in Swift and this method is refined for Obj-C.\r\nIt should be enough to simply clarify the language.", "id": 670}
{"pred": "<msg>I think this is a bit confusing. It seems like it's only called once, and it's not used anywhere else.", "target": "I recommend to revert these changes", "id": 671}
{"pred": "<msg>I think we should also check that the name is not empty.", "target": "This error message should also mention the types incompatible `@ObjCName` were inherited from.", "id": 672}
{"pred": "<msg>I think this is not needed.", "target": "```suggestion\r\noperator fun Int.getValue(thisRef: Any?, property: KProperty<*>): String =\r\n    if (this == 1) \"OK\" else \"Fail\"\r\n```\r\nJust in case, let's check that the correct value is passed. Perhaps in other tests too.", "id": 673}
{"pred": "<msg>I think we can remove this class.", "target": "Same here, would be nice to drop a comment on each transformation -- what is transformed and to what", "id": 674}
{"pred": "<msg>I think we should add a `@RequiresOptIn` annotation to the `ObjCName` annotation.", "target": "The line above mentions that the annotation is applicable to \"class, property, parameter or function\".\nThis line uses \"object or interface\" that are not mentioned above. A little bit inconsistent.", "id": 675}
{"pred": "<msg>This is a test that should be removed.", "target": "Looks like this can be removed.", "id": 676}
{"pred": "<msg>I think we should add a `TODO` here to remove this once we have the proper support for FFI.", "target": "Throwing exceptions from compiler is a bad practice. I'll replace this `require` with reporting an error to message collector", "id": 677}
{"pred": "<msg>This is a bit of a hack, but I don't think it's a big deal.", "target": "Could you please add a test for this case?", "id": 678}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to use `<SMARTCAST_IMPOSSIBLE!>` instead of `p<!>.length`.", "target": "I don't really like this error here BTW because it says \"'p' is a local variable that is captured by a changing closure\" but that's wrong, the variable is changed *outside* the closure.", "id": 679}
{"pred": "<msg>I think this should be `VALUE_CANNOT_BE_PROMOTED`", "target": "When possible, it's better to set more precise element than just `KtElement`", "id": 680}
{"pred": "<msg>This is a bit of a misnomer. It's not a set of checks, it's a set of checks.", "target": "I'd recommend to make an experiment by adding this checker also to `CommonDeclarationCheckers` and run all tests after that.", "id": 681}
{"pred": "<msg>This is not used anywhere.", "target": "I'd prefer it to be declared as `val metadataVersion: BinaryVersion?`", "id": 682}
{"pred": "<msg>This is not used anywhere", "target": "This comment is unneeded", "id": 683}
{"pred": "<msg>I think this is the only place where we need to catch `Throwable`", "target": "@nav-nav: Hi Nataliya, last week @ausatiy mentioned that he'd like to remove this commit from this PR for \"code style\" reasons. However, I think this commit improves readability because:\r\n  - The logic here is that if something is thrown, we'll clean up the state. The new code with `try-catch` directly matches this logic, whereas with the previous `try-finally` approach, the code is spread at 3 different places (line 118, 173, 188) and we'd have to follow the value of the `cachesMayBeCorrupted` variable (i.e., it takes extra effort to express the same thing).\r\n   - The behaviors before and after this commit are exactly the same (note that `finally` catches `Throwable`, which includes `Error` and `Exception`). With this commit, it's easier to change `catch(e: Throwable)` to `catch(e: Exception)` or `catch(e: SomeSpecificException)` later if we want.\r\n\r\nI'm fine if you want to remove this commit, but if so it would be nice if you could let me know your reasons so we can have a discussion here.", "id": 684}
{"pred": "<msg>This is a breaking change. Please revert this change.", "target": "Seems like you have unintentionally removed a sample reference in some functions. Or is it on purpose?", "id": 685}
{"pred": "<msg>I think this should be `assertPrints(\"fatima\".all(Char::isWhitespace), \"false\")`", "target": "Let's have here two strings that have opposite properties. e.g:\r\n```\r\nassertPrints(\"London\".any(Char::isWhitespace), \"false\")\r\nassertPrints(\"Rio de Janeiro\".any(Char::isWhitespace), \"true\")\r\n\r\nassertPrints(\"London\".all(Char::isLetter), \"true\")\r\nassertPrints(\"Rio de Janeiro\".all(Char::isLetter), \"false\")\r\n```\r\nIn my opinion, it better shows how `all` and `any` differs. What do you think?", "id": 686}
{"pred": "<msg>I think this is not needed.", "target": "This should be enough:\r\n```\r\nsample(\"samples.collections.Collections.Aggregates.all\")\r\nspecialFor(CharSequences) {\r\n    sample(\"samples.text.Strings.all\")\r\n}\r\n```\r\n\r\nThe DSL means _\"samples.collections.Collections.Aggregates.all\" is the sample for all receivers, but for CharSequences there is a different sample_\r\n\r\nSo basically the second `sample(...)` overrides the previous.", "id": 687}
{"pred": "<e0>* Kotlin", "target": "Please rebase onto a fresh master, the updated copyright is already there.", "id": 688}
{"pred": "<msg>I think we should use `KtNodeTypes` here.", "target": "I would also add a fast-path for non-top level declarations (ones that don't have KtFile as a parent) to return here, too, because they would be traversed anyway when the checker is run on their containing declaration", "id": 689}
{"pred": "<msg>This is not a valid syntax.", "target": "Please, separate cases with error nodes (ones that are not assumed to be parsed) into a different file named `*_ERR.kt`\nDitto, for other tests inside `testData/psi`\n", "id": 690}
{"pred": "<msg>I think we should use `KotlinExceptionWithAttachments` here.", "target": "The `element::class.simpleName` is useful information too (and it's not a secret \ud83d\ude03). Let's move it to the error message string. For the attachment name, we should use something static, e.g., `elementText`", "id": 691}
{"pred": "<msg>I think we should add a new phase for this.", "target": "Note that this is a change from the previous commit. Since `DirectInvokeLowering` creates returnable blocks it should be a prerequisite of `ReturnableBlockLowering`.", "id": 692}
{"pred": "<msg>This is the fix.", "target": "(Possible future improvement:)\r\nIn certain cases Kotlin property accessors are translated to methods. In this case, `@ObjCName` can be applied to the setter parameter but likely has no effect.", "id": 693}
{"pred": "", "target": "Looks like an unused import?", "id": 694}
{"pred": "<msg>I think we can use `boolAnd` here.", "target": "`context.irBuiltins.eqeqSymbol`", "id": 695}
{"pred": "<msg>This is a bit confusing. It's not a method, it's a function.", "target": "`context.irBuiltins.andandSymbol`", "id": 696}
{"pred": "<msg>This is not used.", "target": "How would this work for\r\n```kotlin\r\ninterface I\r\nobject Impl : I\r\n\r\nsealed value class A : I\r\nvalue class B(val x: I) : A()\r\nobject C : A() {\r\n  override fun equals(other: Any?) = true\r\n}\r\n\r\nB(Impl) == C\r\n```\r\nIt looks like the code would end up calling `B.eq-impl0(Impl, C as I)` which will incorrectly return true?", "id": 697}
{"pred": "<msg>I think this is a bit confusing. I think we should just use `getInlineClassUnderlyingType(irClass)` here.", "target": "Isn't `getInlineClassUnderlyingType` just looking up the inline class representation in the metadata? What are we serializing there for sealed inline classes? Are we omitting it?\r\n\r\n---\r\n\r\nIn any case, it might be better to add this check to the `getInlineClassUnderlyingType` function instead of duplicating it here and below. Unless that ends up breaking some other code, which it might...", "id": 698}
{"pred": "<e0>// We ignore type arguments here, since there is no good way to go from type arguments to types in the IR anyway.", "target": "Since you're touching this code anyway, could you please rename this variable to `argumentType`? It's really not a type argument...", "id": 699}
{"pred": "<msg>This is the only place where we need to create a new block body.", "target": "The specialized equals method takes two unboxed arguments, so `coerceInlineClasses` here doesn't do anything except inform `ExpressionCodegen` of the new type before storing a copy of the argument in a local. You can probably just coerce the value parameters at each use instead.", "id": 700}
{"pred": "<msg>This is the only place where we have to check for `isFunctionDeclared`", "target": "Maybe you could use `overriddenSymbols` to figure out if there is an implementation of a function from `Any` with the correct name?", "id": 701}
{"pred": "<msg>This is a bit confusing. I think we should just have a single `if` statement for both `isSealed` and `valueKeyword == null`.", "target": "Error reporting could be slightly better. Currently this error is reported if the feature is not enabled:\r\n```\r\n1.kt:2:1: error: value classes can be only final or sealed\r\nsealed value class A\r\n^\r\n```\r\nwhich reads weird. I'd expect something usual like `UNSUPPORTED_FEATURE` here.", "id": 702}
{"pred": "<msg>This is not used.", "target": "This way you're not setting `correspondingPropertySymbol` for field/getter, getter name is non-conventional, and maybe there are some other problems. Let's use the builder API instead\r\n```\r\n    private fun generatePropertyForSealedInlineClass(irClass: IrClass) {\r\n        irClass.addProperty {\r\n            name = Name.identifier(\"\\$value\")\r\n            origin = IrDeclarationOrigin.FIELD_FOR_SEALED_INLINE_CLASS\r\n            visibility = DescriptorVisibilities.PROTECTED\r\n        }.also { irProperty ->\r\n            irProperty.addBackingField {\r\n                type = context.irBuiltIns.anyNType\r\n                origin = IrDeclarationOrigin.FIELD_FOR_SEALED_INLINE_CLASS\r\n                visibility = DescriptorVisibilities.PROTECTED\r\n                isFinal = true\r\n            }\r\n            irProperty.addGetter {\r\n                returnType = context.irBuiltIns.anyNType\r\n                origin = IrDeclarationOrigin.GETTER_OF_SEALED_INLINE_CLASS_FIELD\r\n                visibility = DescriptorVisibilities.PROTECTED\r\n            }\r\n        }\r\n    }\r\n```", "id": 703}
{"pred": "<msg>I think we should keep this method and mark it as `@Deprecated`", "target": "```suggestion\r\n    // we can't declare that method here for compatibility with Android SDK 25 and lower, so we leave it unimplemented\r\n```", "id": 704}
{"pred": "<msg>This is a breaking change. We should keep the old syntax.", "target": "`test.kt` and `test.fir.kt` must be identical modulo reported diagnostics. I'll fix it myself, so it's just a note for the future", "id": 705}
{"pred": "<msg>I think this is a good candidate for a test case.", "target": "It's very strange that `VAL_REASSIGNMENT` is not reported here. Looks like compiler bug. I've created an issue for it: [KT-53898](https://youtrack.jetbrains.com/issue/KT-53898)", "id": 706}
{"pred": "", "target": "Please, add a test with `KeepNullabilityWhenApproximatingLocalType` feature enabled, too", "id": 707}
{"pred": "<msg>This is a bit confusing. It's not measuring the time since the start, but the time since the start of the block.", "target": "I'm debating if `convertDurationUnit` should be used instead, though this is likely quicker.", "id": 708}
{"pred": "<msg>This is a bit confusing. I think it would be better to have a separate method for this.", "target": "This is effectively a breaking change, so I'm wondering if we should treat:\r\n- `const`\r\n- any kind of primitive + String values for a `val`\r\nas constants and inline them?\r\n\r\nThis ensures existing users do not break.", "id": 709}
{"pred": "<msg>This is the only place where we call `getCommonizedPlatformLibrariesFor` with `leaf` target.", "target": "What do you think about defining another function like \r\n```\r\nfun TaskProvider<NativeDistributionCommonizerTask>.getCommonizedPlatformLibrariesFor(target: SharedCommonizerTarget) = project.filesProvider {  ... } \r\n```\r\n\r\non the TaskProvider?\r\nWith this, others will have intuitively use this better version instead!", "id": 710}
{"pred": "<msg>I think this is a bit confusing. I think we should have a method `hasErrors` that returns `true` if the diagnostic reporter has errors.", "target": "1) I guess this check should be outside of the loop, in the beginning of the method, because `writeOutput` cannot introduce new compilation errors\r\n2) The following would be more reliable: `projectConfiguration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY).hasErrors()`\r\n3) I'd prefer to rename the method to `writeOutputsIfNeeded` to make it clear that outputs are not guaranteed to be written", "id": 711}
{"pred": "<msg>I think we should remove this test. It's not testing anything.", "target": "1) Let's use the standard `AbstractCliTest` for this (`compiler/testData/cli/jvm`), and check that the file is absent using the `ABSENT` directive (e.g. https://github.com/JetBrains/kotlin/blob/049b6899b729fd4c04ab4588743404150525019c/compiler/testData/cli/jvm/jvmIrByDefault1_5.test#L1)\r\n2) I'd prefer to avoid using unstable language features, let's make the test cause platform declaration clash via `@JvmName`\r\n3) Please add a copy of the test with K2 (`-Xuse-k2`), because it has another entrypoint which also needs to be checked\r\n\r\n", "id": 712}
{"pred": "", "target": "Move this file to [compiler/testData/diagnostics/tests/redeclarations](https://github.com/JetBrains/kotlin/tree/4737bb07dfa131d4167ae9fe0966c48ce11268c0/compiler/testData/diagnostics/tests/redeclarations). Rename it to `RedeclaratedVals.kt` (don't use `k2` prefix/suffix for test data since it's used in both frontends).", "id": 713}
{"pred": "<msg>This is not a valid test.", "target": "No need to use stdlib methods here (since it requires adding `// WITH_STDLIB` directive). You can just make the function returnable:\r\n\r\n```suggestion\r\n        return someVal\r\n```", "id": 714}
{"pred": "<msg>This is a bit of a misnomer. It's not a function, it's a function.", "target": "Your test doesn't cover this case. Please extend the test sample.", "id": 715}
{"pred": "<msg>This is a bit of a misnomer. It's not checking the block, it's checking the body.", "target": "The method doesn't check in the following case:\r\n\r\n```kt\r\nfun main(b: Boolean) {\r\n    if (b) {\r\n        val someVal2 = 2\r\n        val someVal2 = \"Two\"\r\n    }\r\n}\r\n```\r\n\r\nPlease consider more cases.", "id": 716}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have the line break on the previous line, so that it's easier to see what changed.", "target": "Remove formatting changes.", "id": 717}
{"pred": "<msg>This is a bit of a misnomer. It's not resolving the conflicting symbols. It's resolving the conflicting symbols for the file and regular class.", "target": "Incorrect function naming. Resolving is being performed on the previous stage, checkers only detect incorrect semantics. Rename it to something else, probably to `checkConflictingSymbols`.", "id": 718}
{"pred": "<msg>I think this should be `set`", "target": "`TestReport.destinationDirectory` input was added only in Gradle 7.4. Since KGP supports all Gradle versions from 6.8.3 I could not accept this change.\r\n\r\nI need to think how to fix it better.", "id": 719}
{"pred": "<msg>This is the only place where we use `irClass.isFinalClass` - it's not clear to me why we need to check for `modality == Modality.FINAL` here.", "target": "Could you please comment this change? It influences not only K2 but also K1, so it's not so clear for me.", "id": 720}
{"pred": "<msg>I think this is a bit of a misnomer. It's not a binary boolean expression. It's a binary expression that is not overridden.", "target": "I've created [KT-55096](https://youtrack.jetbrains.com/issue/KT-55096) to track this problem", "id": 721}
{"pred": "<msg>Why do we need to serialize this?", "target": "Shouldn't all of these implementations have a `serialVersionUID` property?", "id": 722}
{"pred": "<msg>I think this is not needed.", "target": "Add a test with `@JvmStatic` function accessing private properties of the object.", "id": 723}
{"pred": "<msg>I think this is a typo.", "target": "Changes like these make me uncomfortable with this change. I don't feel like I understand what is going on here. It looks like all the actual functional tests are passing, but it is clear that this changes things in subtle ways.", "id": 724}
{"pred": "<msg>This test is not necessary.", "target": "It seams, that the current code works only if the variable is passed to an argument. \r\n\r\nFor example, if I change the code to `foo(1, 2)` variables disappear. Also p2 disappear if use `foo(tmp1, tmp1+tmp1)`. Can you please check it, and add more complex tests?", "id": 725}
{"pred": "<msg>This is a bit of a misnomer. It's not saving the parameter to the expression mapping, it's saving the expression mapping for the parameter.", "target": "Did I understand correctly that you are using the inline function parameter as the key in the map? How it's supposed to work if the function is called several times? Can you please add a test on this case, if I'm missing something and it works?", "id": 726}
{"pred": "<msg>I think this should be done in the constructor of `IrExpressionTransformer`", "target": "There should be variables for these parameters in most cases. I think they are not shown now, as they are temporary variables. What do you think about creating a separate origin for them? I'm not sure about the name and scope, but this should be an easier solution, at least for cases, where variables are not optimized-out. ", "id": 727}
{"pred": "<msg>This is the only change that I'm not sure about.", "target": "@ligee FYI", "id": 728}
{"pred": "<msg>I think this is the only place where we need to enter a graph.", "target": "Most likely at this point this situation would never happen\n\nI'll add assertion and check if something fail", "id": 729}
{"pred": "<msg>I think this is a typo.", "target": "Please make this a `var` and check that changing its value works", "id": 730}
{"pred": "<msg>I think this should be `true` by default.", "target": "Seems unused.", "id": 731}
{"pred": "<msg>This is a bit confusing. I think it should be `config.configuration.getBoolean(BinaryOptions.objcExportIgnoreInterfaceMethodCollisions)`", "target": "Shouldn't actually be required here: no header is generated in this mode (e.g. the compiler is producing an executable).", "id": 732}
{"pred": "", "target": "Please add a default implementation (`false`). This interface has subclasses outside this repository, and adding a default implementation would prevent breaking those subclasses.", "id": 733}
{"pred": "<msg>This is a breaking change. We need to add a new property to the `ModuleDescriptor` interface.", "target": "Please add a default implementation. See `ObjCExportLazy.Configuration.ignoreInterfaceMethodCollisions` comment for details.", "id": 734}
{"pred": "<msg>This is a bit confusing. Why not just pass `context.config.debug` to `FunctionInlining`?", "target": "Please use `generationState.shouldContainDebugInfo` instead", "id": 735}
{"pred": "<msg>This is a bit of a hack. I think we should just use `params.find(SpecialNames.SELF_TYPE) == null` instead.", "target": "Please add a test confirming this check is needed", "id": 736}
{"pred": "<msg>I think this is fine, but I think we should add a TODO here to check laxTypedIntrinsic, or we can access the context from the Ir node.", "target": "Question: how can I access the `LanguageSettings` object here to check for the enabled feature? Is it possible to get that instance from an Ir node, or I will need to propagate the instance up to here?", "id": 737}
{"pred": "<msg>This is not needed.", "target": "Please run \"reformat\" on the whole file", "id": 738}
{"pred": "<msg>This is a bit of a misnomer. It's not actually a value, it's a property.", "target": "I've experimented with toString variants in the debugger, and I think that for this purpose it would be better to keep things consistent with other delegates provided by `Delegates` object.\r\n```suggestion\r\n    public override fun toString(): String = \r\n        \"NotNullProperty(${if (value != null) \"value=$value\" else \"value not initialized yet\"})\"\r\n```", "id": 739}
{"pred": "<msg>This is a bit of a misnomer. It's not a `ThreadLocalDelegate` but a `ThreadLocalMap`.", "target": "When a thread is used as a map key, the result of toString is not nice to read \r\n```suggestion\r\n    override fun toString(): String =\r\n        \"ThreadLocalDelegate(${map.entries.joinToString { \"#${it.key.id}=>${it.value}\" }})\"    \r\n```", "id": 740}
{"pred": "<msg>This is a bit weird. Why not just `push`?", "target": "AFAIK, there was some limitation on how many parameters can be spread using this approach, so it may fail on large `elements` collection", "id": 741}
{"pred": "<msg>This is a bug, it should be `js(\"[]\")`", "target": "Not a very descriptive name, perhaps would be better `jsArrayPrototype` or something like that.", "id": 742}
{"pred": "<msg>I think this is a bug. `elements` is an array, not a `TypedArray`.", "target": "Would be better to expand the array by setting its length and then fill elements manually.", "id": 743}
{"pred": "<msg>I think this is not needed.", "target": "Moving array tail on each element insertion would result in quadratic complexity.", "id": 744}
{"pred": "<msg>This is a breaking change.", "target": "It doesn't seem that jsArrayPrototype is now used anywhere except this function. Does it make sense to extract it then to a variable?", "id": 745}
{"pred": "<msg>I think we should use `Map<String, Int>` here.", "target": "I think `@Transient` shouldn't be here, as delegated property is transient automatically? At least it works without it.", "id": 746}
{"pred": "<msg>I think this is not needed.", "target": "Please remove this comment", "id": 747}
{"pred": "<msg>I think this is not needed.", "target": "Let's use `IGNORE_BACKEND: JVM, JS` instead, so that this test will run for Native.", "id": 748}
{"pred": "<msg>I think this should be `val`", "target": "I would just call it `hasDependencies`. \"Unresolved\" is a special additional property used to indicate that `fun BaseKotlinLibrary.unresolvedDependencies()` returns `UnresolvedLibrary`s that need further resolve.", "id": 749}
{"pred": "", "target": "Nit: could be private", "id": 750}
{"pred": "<msg>This is a bit of a nitpick, but I think it would be better to have the `step` in the sample name, so that it's clear that it's a step number.", "target": "```suggestion\r\n        sample(\"samples.ranges.Ranges.step$primitive\")\r\n```\r\nMinor: calling `name` is redundant because enum's toString simply returns its name.", "id": 751}
{"pred": "<msg>I think this is a mistake.", "target": "GH's source editor is to blame here, I can roll it back if needed.", "id": 752}
{"pred": "<msg>This is a breaking change.", "target": "Please revert this change.", "id": 753}
{"pred": "<msg>This is a breaking change. We should keep the old signature and add a new one.", "target": "Please revert this change.", "id": 754}
{"pred": "<msg>This is a bug fix.", "target": "Please revert this change to keep the style consistent.", "id": 755}
{"pred": "<msg>This is a breaking change.", "target": "Please revert this change.", "id": 756}
{"pred": "<msg>This is a breaking change.", "target": "Please revert this change.", "id": 757}
{"pred": "<msg>This is a breaking change.", "target": "Please revert this change.", "id": 758}
{"pred": "<msg>This is a breaking change.", "target": "Please revert this change.", "id": 759}
{"pred": "<msg>This is a breaking change. Please add a new line after the last comma.", "target": "Please revert this change.", "id": 760}
{"pred": "<msg>This is a breaking change.", "target": "Please revert this change.", "id": 761}
{"pred": "<msg>I think we can remove this line.", "target": "Move the `->` here and below to the line above to keep the style consistent.", "id": 762}