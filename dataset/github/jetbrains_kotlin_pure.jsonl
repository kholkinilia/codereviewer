{"patch": "@@ -164,6 +165,7 @@ class CodeToInlineBuilder(\n             }\n \n             if (expression.getReceiverExpression() == null) {\n+                val targetCallable = (targetCallable as? FunctionImportedFromObject)?.callableFromObject ?: targetCallable", "msg": "Should we use `ImportedFromObjectCallableDescriptor<*>` instead?"}
{"patch": "@@ -33,6 +33,7 @@ import org.jetbrains.kotlin.ir.types.impl.IrUninitializedType\n import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid\n import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid\n import org.jetbrains.kotlin.ir.visitors.acceptVoid\n+import org.jetbrains.kotlin.name.Name", "msg": "Minor: unused import. I'll remove it before pushing."}
{"patch": "@@ -221,7 +221,7 @@ class JvmSymbols(\n                 addValueParameter(\"completion\", continuationType.makeNullable())\n             }\n             klass.addFunction(\"invokeSuspend\", irBuiltIns.anyNType, Modality.ABSTRACT).apply {\n-                addValueParameter(\"result\", resultClassStub.typeWith(irBuiltIns.anyNType))\n+                addValueParameter(\"\\$result\", resultClassStub.typeWith(irBuiltIns.anyNType))", "msg": "I somehow missed it. Thanks!\r\nMinor: there is `SUSPEND_CALL_RESULT_NAME`, which, in fact, I should've used."}
{"patch": "@@ -867,6 +869,20 @@ class Fir2IrVisitor(\n     }\n \n     override fun visitThisReceiverExpression(thisReceiverExpression: FirThisReceiverExpression, data: Any?): IrElement {\n+        val calleeReference = thisReceiverExpression.calleeReference\n+        if (calleeReference.labelName == null && calleeReference.boundSymbol is FirRegularClassSymbol) {\n+            val dispatchReceiver = this.functionStack.lastOrNull()?.dispatchReceiverParameter\n+            if (dispatchReceiver != null) {\n+                // Use the dispatch receiver of the containing function\n+                return IrGetValueImpl(", "msg": "I will change it to `thisReceiverExpression.convertWithOffsets` usage"}
{"patch": "@@ -71,4 +71,14 @@ internal class A {\n         val d4 = Double.NEGATIVE_INFINITY\n         val d5 = Double.NaN\n     }\n+\n+    fun kt35593() {\n+        val number: Number = 1\n+        val b: Byte = number.byteValue()\n+        val d: Double = number.doubleValue()\n+        val f: Float = number.floatValue()\n+        val i: Int = number.intValue()\n+        val l: Long = number.longValue()\n+        val s: Short = number.shortValue()", "msg": "correct one is: \r\n```\r\n   val b = number.toByte()\r\n   val d = number.toDouble()\r\n   val f = number.toFloat()\r\n   val i = number.toInt()\r\n   val l = number.toLong()\r\n   val s = number.toShort()\r\n```"}
{"patch": "@@ -1,4 +1,5 @@\n // IGNORE_BACKEND_FIR: JVM_IR\n+// IGNORE_BACKEND: JVM_IR", "msg": "This test should not have passed. It is checking that no delegate field is created for interface delegation. It is doing so based on the name of the field, and therefore it now correctly fails because we do not have that optimization."}
{"patch": "@@ -0,0 +1,7 @@\n+// COMPILER_ARGUMENTS: -XXLanguage:+MixedNamedArgumentsInTheirOwnPosition\n+\n+fun foo(name1: Int, name2: Int, name3: Int) {}", "msg": "There are also test `namedArgumentsBefore.kt` which might fail now, because by default `MixedNamedArgumentsInTheirOwnPosition` will be enabled in kotlin 1.4\r\n\r\nCan you please explicitly specify there that `MixedNamedArgumentsInTheirOwnPosition` is disabled in this test (by adding `// COMPILER_ARGUMENTS: -XXLanguage:-MixedNamedArgumentsInTheirOwnPosition`), and add additional test with `MixedNamedArgumentsInTheirOwnPosition` enabled (in which the intention should now work for this case)?"}
{"patch": "@@ -0,0 +1,7 @@\n+// COMPILER_ARGUMENTS: -XXLanguage:+MixedNamedArgumentsInTheirOwnPosition\n+\n+fun foo(name1: Int, name2: Int, name3: Int) {}\n+\n+fun usage() {", "msg": "It seems like there are missing test when `MixedNamedArgumentsInTheirOwnPosition` is enabled, but the arguments are not in their own positions, and the intention should be disabled\r\n\r\nWith your code, this case will look like `foo(1, <caret>name3 = 3, name2 = 2)`\r\n"}
{"patch": "@@ -30,7 +32,9 @@ class RemoveArgumentNameIntention : SelfTargetingRangeIntention<KtValueArgument>\n \n         val argumentList = element.parent as? KtValueArgumentList ?: return null\n         val arguments = argumentList.arguments\n-        if (arguments.asSequence().takeWhile { it != element }.any { it.isNamed() }) return null\n+        if (!element.languageVersionSettings.supportsFeature(LanguageFeature.MixedNamedArgumentsInTheirOwnPosition)\n+            && arguments.asSequence().takeWhile { it != element }.any { it.isNamed() }", "msg": "When `MixedNamedArgumentsInTheirOwnPosition` is enabled, you cannot skip this check. Actually you have to check that all of the previous arguments are not named, or are named but in their own positions\r\n\r\nYou can take a look at `NamedArgumentCompletion::isOnlyNamedArgumentExpected` to see how this check looks exactly\r\n\r\nTo check that your implementation is correct, try this test: \r\n\r\n```kt\r\n// COMPILER_ARGUMENTS: -XXLanguage:+MixedNamedArgumentsInTheirOwnPosition\r\n// IS_APPLICABLE: false\r\n\r\nfun foo(name1: Int, name2: Int, name3: Int) {}\r\n\r\nfun usage() {\r\n    foo(name2 = 2, name1 = 1, <caret>name3 = 3)\r\n}\r\n```\r\n\r\nThe intention should not be applicable, because first two arguments are not in their own positions, therefore you cannot remove name from the third argument"}
{"patch": "@@ -30,7 +32,9 @@ class RemoveArgumentNameIntention : SelfTargetingRangeIntention<KtValueArgument>\n \n         val argumentList = element.parent as? KtValueArgumentList ?: return null\n         val arguments = argumentList.arguments\n-        if (arguments.asSequence().takeWhile { it != element }.any { it.isNamed() }) return null\n+        if (!element.languageVersionSettings.supportsFeature(LanguageFeature.MixedNamedArgumentsInTheirOwnPosition)\n+            && arguments.asSequence().takeWhile { it != element }.any { it.isNamed() }\n+        ) return null\n \n         val callExpr = argumentList.parent as? KtCallElement ?: return null\n         val argumentMatch = callExpr.resolveToArgumentMatch(element) ?: return null", "msg": "You are using your own `resolveToArgumentMatch` function here\r\n\r\nPlease, replace it with `org.jetbrains.kotlin.resolve.calls.callUtil.getParameterForArgument`, it is designed specifically for this case"}
{"patch": "@@ -93,3 +94,30 @@ internal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n     1 -> setOf(iterator().next())\n     else -> this\n }\n+\n+/**\n+ * Build a new read-only [Set] with the [elements][E] from the [builderAction].\n+ *\n+ * @sample samples.collections.Builders.Sets.buildSetSample\n+ */\n+@kotlin.internal.InlineOnly\n+@SinceKotlin(\"1.4\")\n+@Suppress(\"NEWER_VERSION_IN_SINCE_KOTLIN\", \"API_NOT_AVAILABLE\" /* See KT-30129 */) // TODO: remove this in 1.4", "msg": "You can use `@SinceKotlin(\"1.3\")` + `@ExperimentalStdlibApi`. This way new functions could be published in 1.3.x release"}
{"patch": "@@ -388,10 +389,12 @@ private fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n \n @PublishedApi\n @SinceKotlin(\"1.3\")\n+@Suppress(\"NO_ACTUAL_FOR_EXPECT\") // JS IR", "msg": "For JS_IR we copy JS sources during build, so this suppress should not be needed."}
{"patch": "@@ -725,35 +724,35 @@ class ExpressionCodegen(\n         }\n     }\n \n-    override fun visitWhileLoop(loop: IrWhileLoop, data: BlockInfo): PromisedValue {\n-        val continueLabel = markNewLabel()\n-        val endLabel = Label()\n-        // Mark stack depth for break\n-        mv.fakeAlwaysFalseIfeq(endLabel)\n-        loop.condition.markLineNumber(true)\n-        loop.condition.accept(this, data).coerceToBoolean().jumpIfFalse(endLabel)\n-        data.withBlock(LoopInfo(loop, continueLabel, endLabel)) {\n-            loop.body?.accept(this, data)?.discard()\n-        }\n-        mv.goTo(continueLabel)\n-        mv.mark(endLabel)\n-        return immaterialUnitValue\n-    }\n-\n-    override fun visitDoWhileLoop(loop: IrDoWhileLoop, data: BlockInfo): PromisedValue {\n+    override fun visitLoop(loop: IrLoop, data: BlockInfo): PromisedValue {\n+        // Spill the stack in case the loop contains inline functions that break/continue", "msg": "I would prefer to keep original separation: visitWhileLoop/visitDoWhileLoop"}
{"patch": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.intentions\n+\n+import com.intellij.openapi.editor.Editor\n+import com.intellij.psi.PsiComment\n+import org.jetbrains.kotlin.idea.refactoring.getLineNumber\n+import org.jetbrains.kotlin.psi.KtLambdaExpression\n+import org.jetbrains.kotlin.psi.KtPsiFactory\n+import org.jetbrains.kotlin.psi.psiUtil.allChildren\n+\n+sealed class ConvertLambdaLineIntention(private val toMultiLine: Boolean) : SelfTargetingIntention<KtLambdaExpression>(\n+    KtLambdaExpression::class.java, \"Convert to ${if (toMultiLine) \"multi\" else \"single\"}-line\"", "msg": "Better add \"lambda\" (e.g,  \"Convert to multi-line lambda\") to the end of the title as it's not quite obvious for the user what should that intension do in case when many intentions are suggested to the user"}
{"patch": "@@ -22,10 +23,12 @@ class DeferredResultUnusedInspection(@JvmField var standardOnly: Boolean = false\n                 (!inspection.standardOnly || expression.calleeExpression?.text in shortNames),\n     callChecker = fun(resolvedCall, inspection): Boolean {\n         if (inspection !is DeferredResultUnusedInspection) return false\n+        val resultingDescriptor = resolvedCall.resultingDescriptor\n+        if (resultingDescriptor.fqNameSafe == FqName(\"kotlin.test.assertNotNull\")) return false", "msg": "But the called function may have an arbitrary name, see https://youtrack.jetbrains.com/issue/KT-33741#focus=streamItem-27-3697460.0-0"}
{"patch": "@@ -85,6 +92,31 @@ interface KotlinGradleSubplugin<in KotlinCompile : AbstractCompile> {\n     fun getNativeCompilerPluginArtifact(): SubpluginArtifact? = null\n }\n \n+/**\n+ * Gradle plugin implementing support for a Kotlin compiler plugin.\n+ * In order to be discovered, it should be applied to the project as an ordinary [Plugin].\n+ * Then its [isApplicable] is checked against compilations of the project, and if it returns true,\n+ * then [applyToCompilation], [getPluginKotlinTasks], and other functions may be called later.\n+ */\n+interface KotlinCompilerPluginSupportPlugin : Plugin<Project> {\n+    override fun apply(project: Project) = Unit\n+\n+    fun isApplicable(kotlinCompilation: KotlinCompilation<*>): Boolean\n+\n+    fun applyToCompilation(\n+        kotlinCompilation: KotlinCompilation<*>,\n+        javaCompile: TaskProvider<out AbstractCompile>?\n+    ): Provider<List<SubpluginOption>>\n+\n+    fun getPluginKotlinTasks(", "msg": "A convention is to distinguish methods returning tasks providers (from methods returning tasks) by suffix them:\r\n`getPluginKotlinTaskProviders` here."}
{"patch": "@@ -973,57 +977,67 @@ abstract class AbstractAndroidProjectHandler(private val kotlinConfigurationTool\n         variantData: BaseVariant,\n         subpluginEnvironment: SubpluginEnvironment\n     ) {\n-        val kotlinTask = project.tasks.getByName(compilation.compileKotlinTaskName) as KotlinCompile\n-        val javaTask = getJavaTask(variantData)\n+        val javaTask = variantData.javaTaskProvider", "msg": "`javaTaskProvider`"}
{"patch": "@@ -947,22 +946,27 @@ abstract class AbstractAndroidProjectHandler(private val kotlinConfigurationTool\n         }\n     }\n \n+    private val BaseVariant.javaTaskProvider: TaskProvider<out AbstractCompile>\n+        get() = getJavaTaskProvider()\n+            // for older versions, get the task instance and wrap it into a TaskProvider\n+            ?: getJavaTask(this).let { it.project.tasks.withType(AbstractCompile::class.java).named(it.name) }", "msg": "you can use `named\u200b(String name, Class<S> type)`"}
{"patch": "@@ -332,28 +334,33 @@ internal fun applyUserDefinedAttributes(target: AbstractKotlinTarget) {\n     }\n }\n \n-internal fun sourcesJarTask(compilation: KotlinCompilation<*>, componentName: String?, artifactNameAppendix: String): Jar =\n+internal fun sourcesJarTask(compilation: KotlinCompilation<*>, componentName: String?, artifactNameAppendix: String): TaskProvider<Jar> =\n     sourcesJarTask(compilation.target.project, lazy { compilation.allKotlinSourceSets }, componentName, artifactNameAppendix)\n \n internal fun sourcesJarTask(\n     project: Project,\n     sourceSets: Lazy<Set<KotlinSourceSet>>,\n     componentName: String?,\n     artifactNameAppendix: String\n-): Jar {\n+): TaskProvider<Jar> {\n     val taskName = lowerCamelCaseName(componentName, \"sourcesJar\")\n \n-    (project.tasks.findByName(taskName) as? Jar)?.let { return it }\n+    project.tasks.withType(Jar::class.java).run {\n+        if (taskName in names)", "msg": "I am not sure to understand why we need the collection here (`withType`). Just for the type ? \r\nWe might want to use named(String, Class) but need to handle the failing cases."}
{"patch": "@@ -102,7 +103,7 @@ abstract class AbstractKotlinCompilation<T : KotlinCommonOptions>(\n             // To configure a task that may have not yet been created at this point, use 'withType-matching-all`:\n             .withType(AbstractKotlinCompile::class.java)\n             .matching { it.name == compileKotlinTaskName }", "msg": "we can use `named(String, Class)` "}
{"patch": "@@ -240,7 +240,7 @@ internal open class GradleCompilerRunner(protected val task: Task) {\n                 ?: return null\n             val sourceSet = javaConvention.sourceSets.findByName(sourceSetName) ?: return null\n             val jarTask = project.tasks.findByName(sourceSet.jarTaskName) as? Jar", "msg": "This will cause the tasks to be realized. You can use named, and also precise the type if the lowest gradle version is bumped to 5.1."}
{"patch": "@@ -307,13 +307,15 @@ internal class Kotlin2JsSourceSetProcessor(\n \n     private fun registerCleanSourceMapTask() {\n         val taskName = kotlinCompilation.composeName(\"clean\", \"sourceMap\")\n-        val registerTask = registerTask(project, taskName, Delete::class.java) {\n+        project.registerTask<Delete>(taskName) {\n             it.onlyIf { kotlinTask.get().kotlinOptions.sourceMap }", "msg": "I am wondering here when the `onlyIf` statement is gonna be evaluated as calling `get()` will realize the task.\r\nTBH, it would be nice to have someone from Gradle having a look at it."}
{"patch": "@@ -433,25 +437,24 @@ internal abstract class AbstractKotlinPlugin(\n         }\n \n         private fun configureClassInspectionForIC(project: Project) {\n-            val classesTask = project.tasks.findByName(JavaPlugin.CLASSES_TASK_NAME)\n-            val jarTask = project.tasks.findByName(JavaPlugin.JAR_TASK_NAME)\n+            val classesTask = project.locateTaskByName(JavaPlugin.CLASSES_TASK_NAME)\n+            val jarTask = project.locateTask<Jar>(JavaPlugin.JAR_TASK_NAME)", "msg": "Can we change all the variable/property names that refer to providers to use the suffix `Provider` (e.g. `jarTaskProvider`). It will help maintenance and the API will be more clear."}
{"patch": "@@ -948,7 +951,7 @@ abstract class AbstractAndroidProjectHandler(private val kotlinConfigurationTool\n \n     private val BaseVariant.javaTaskProvider: TaskProvider<out AbstractCompile>\n         get() = getJavaTaskProvider()\n-            // for older versions, get the task instance and wrap it into a TaskProvider\n+        // for older versions, get the task instance and wrap it into a TaskProvider\n             ?: getJavaTask(this).let { it.project.tasks.withType(AbstractCompile::class.java).named(it.name) }", "msg": "if we use gradle 5.1 apis, this can be shortened to `named(Class, String)`. Or we need to keep using this \"old\" api because this case is a backward compatibility case ?"}
{"patch": "@@ -61,11 +61,11 @@ open class KotlinJvmTarget @Inject constructor(\n \n         javaPluginConvention.sourceSets.all { javaSourceSet ->\n             val compilation = compilations.getByName(javaSourceSet.name)\n-            val compileJavaTask = project.tasks.getByName(javaSourceSet.compileJavaTaskName) as AbstractCompile\n+            val compileJavaTask = project.locateTask<AbstractCompile>(javaSourceSet.compileJavaTaskName)!!", "msg": "sometimes we use `named`, sometimes we use `locateTask!!`. It would be better to stick to one method."}
{"patch": "@@ -61,11 +61,11 @@ open class KotlinJvmTarget @Inject constructor(\n \n         javaPluginConvention.sourceSets.all { javaSourceSet ->\n             val compilation = compilations.getByName(javaSourceSet.name)\n-            val compileJavaTask = project.tasks.getByName(javaSourceSet.compileJavaTaskName) as AbstractCompile\n+            val compileJavaTask = project.locateTask<AbstractCompile>(javaSourceSet.compileJavaTaskName)!!", "msg": "Please rename to `compileJavaTaskProvider`"}
{"patch": "@@ -49,7 +50,9 @@ class KotlinJvmTargetConfigurator(kotlinPluginVersion: String) :\n     ): KotlinJvmTestRun = KotlinJvmTestRun(name, target).apply {\n         val testTaskOrProvider = target.project.registerTask<KotlinJvmTest>(testTaskName) { testTask ->", "msg": "`testTaskProvider`"}
{"patch": "@@ -95,12 +96,12 @@ class KotlinTestsRegistry(val project: Project, val allTestsTaskName: String = \"\n         return \"clean\" + taskName.capitalize()\n     }\n \n-    private val Project.cleanAllTestTask: Task\n+    private val Project.cleanAllTestTask: TaskProvider<*>", "msg": "`cleanAllTest(s)TaskProvider`, I am not sure about the `s`."}
{"patch": "@@ -0,0 +1,14 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+package org.jetbrains.kotlin.gradle.utils\n+\n+import org.gradle.api.logging.Logger\n+\n+const val deprecatedBecauseNoConfigAvoidanceUseProvider = \"Using this brings performance issues. \" +\n+        \"Use the provider instead to benefit from configuration avoidance.\"", "msg": "Use the equivalent provider method to benefit from gradle task configuration avoidance."}
{"patch": "@@ -108,10 +109,11 @@ fun KtExpression.hasSuspendCalls(bindingContext: BindingContext = analyze(BodyRe\n             }\n         }\n         else -> {\n-            val resolvedCall = getResolvedCall(bindingContext)\n-            if ((resolvedCall?.resultingDescriptor as? FunctionDescriptor)?.isSuspend == true) true\n+            val target = (this as? KtParenthesizedExpression)?.getStrictParentOfType<KtCallExpression>() ?: this", "msg": "This is a very hacky way to solve the problem. The root of problem here is the fact that the considered call expression is not a valid candidate (see check at line 88), so I believe this place should be fixed instead."}
{"patch": "@@ -262,3 +267,26 @@ private class UpdateFunctionCallSites(\n         }\n     }\n }\n+\n+private class UpdateConstantFacadePropertyReferences(private val context: JvmBackendContext) : ClassLoweringPass {", "msg": "~~Do you need this as a ClassLoweringPass? You're creating it only to call lower(). It can just be a private method, or merge it with the anonymous IrElementTransformerVoid.~~ Never mind I thought you were passing in an IrClass, didn't notice it was an IrModuleFragment"}
{"patch": "@@ -19,22 +19,47 @@ package org.jetbrains.kotlin.cli.common.messages\n import java.io.Serializable\n \n data class CompilerMessageLocation private constructor(", "msg": "This is a common part used extensively outside of the scripting, so I suggest to make changes less intrusive, i.e. leave `line` and `column` intact, add `endLine` and `endColumn`, and put this change into a separate commit with an explanation \"why\" in the commit message."}
{"patch": "@@ -40,7 +42,9 @@ data class CompiledReplCodeLine(val className: String, val source: ReplCodeLine)\n }\n \n data class CompiledClassData(val path: String, val bytes: ByteArray) : Serializable {\n-    override fun equals(other: Any?): Boolean = (other as? CompiledClassData)?.let { path == it.path && Arrays.equals(bytes, it.bytes) } ?: false", "msg": "Functional changes get lost in the formatting ones. If you really want to submit formatting changes of that magnitude (I'm not against it in general), I would suggest to make it with a separate commit.\r\nOn the other hand, small formatting changes in comparison with the functional ones, in most cases look fine for me."}
{"patch": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.utils;\n+\n+data class KotlinReplError(val loc: Location?, val message: String = \"\", val severity: Severity) {", "msg": "It seems that it could be substituted with ScriptDiagnostic. But the problem is that scripting-common is not accessible from compiler-cli. So it is one more reason to base completion on a new API and relocate it completely to a plugin similar to scripting plugin."}
{"patch": "@@ -0,0 +1,138 @@\n+// IGNORE_BACKEND_FIR: JVM_IR\n+// TARGET_BACKEND: JVM\n+// WITH_RUNTIME\n+\n+// FILE: J.java\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+public class J {\n+    public static String platformStringIsNull() {\n+        return null;\n+    }\n+\n+    @NotNull\n+    public static String notNullStringIsNull() {\n+        return null;\n+    }\n+\n+    @Nullable\n+    public static String nullableStringIsNull() {\n+        return null;\n+    }\n+\n+    @NotNull\n+    public static String notNullStringIsNotNull() {\n+        return \"foo\";\n+    }\n+\n+    public static String platformStringIsNotNull() {\n+        return \"foo\";\n+    }\n+\n+    @Nullable\n+    public static String nullableStringIsNotNull() {\n+        return \"foo\";\n+    }\n+}\n+\n+// FILE: main.kt\n+import kotlin.test.assertEquals\n+\n+fun box(): String {\n+    val n = 123\n+\n+    // Due to KT-36625, certain concatenation calls below (marked with a comment) SHOULD fail a nullability check but do not.", "msg": "Minor: not clear if it's really \"SHOULD\". Language design formalities are not settled in this case.\r\nI'd change this comment to something like \r\n```\r\n// Null check behavior in string concatenation might change depending on language design decision for KT-36625.\r\n```"}
{"patch": "@@ -0,0 +1,138 @@\n+// IGNORE_BACKEND_FIR: JVM_IR\n+// TARGET_BACKEND: JVM\n+// WITH_RUNTIME\n+\n+// FILE: J.java\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+public class J {\n+    public static String platformStringIsNull() {\n+        return null;\n+    }\n+\n+    @NotNull\n+    public static String notNullStringIsNull() {\n+        return null;\n+    }\n+\n+    @Nullable\n+    public static String nullableStringIsNull() {\n+        return null;\n+    }\n+\n+    @NotNull\n+    public static String notNullStringIsNotNull() {\n+        return \"foo\";\n+    }\n+\n+    public static String platformStringIsNotNull() {\n+        return \"foo\";\n+    }\n+\n+    @Nullable\n+    public static String nullableStringIsNotNull() {\n+        return \"foo\";\n+    }\n+}\n+\n+// FILE: main.kt", "msg": "Minor: I usually give the \"main\" file in the multi-file test the same name as the test file (`stringFromJavaPlus.kt` in this case). Enables navigation from stack trace in IDEA."}
{"patch": "@@ -45,19 +45,19 @@ class ReplaceGetOrSetInspection : AbstractApplicabilityBasedInspection<KtDotQual\n         val callExpression = element.callExpression ?: return false\n         val calleeName = (callExpression.calleeExpression as? KtSimpleNameExpression)?.getReferencedNameAsName()\n         if (calleeName !in operatorNames) return false\n+        if (callExpression.typeArgumentList != null) return false\n+        val arguments = callExpression.valueArguments\n+        if (arguments.isEmpty()) return false\n+        if (arguments.any { it.isNamed() }) return false\n+        if (calleeName == OperatorNameConventions.GET && arguments.first().isSpread) return false", "msg": "What if not the first but the second or third argument is spread? "}
{"patch": "@@ -20,6 +20,8 @@ object ErrorsNative {\n     val INCOMPATIBLE_THROWS_OVERRIDE = DiagnosticFactory1.create<KtElement, DeclarationDescriptor>(Severity.ERROR)\n     @JvmField\n     val INCOMPATIBLE_THROWS_INHERITED = DiagnosticFactory1.create<KtDeclaration, Collection<DeclarationDescriptor>>(Severity.ERROR)\n+    @JvmField\n+    val INCOMPATIBLE_SHARED_IMMUTABLE = DiagnosticFactory0.create<KtElement>(Severity.ERROR)", "msg": "Not \"incompatible\". More like \"inapplicable\"."}
{"patch": "@@ -0,0 +1,27 @@\n+// FILE: annotation.kt\n+package kotlin.native.concurrent\n+\n+@Target(AnnotationTarget.PROPERTY)\n+@Retention(AnnotationRetention.BINARY)\n+annotation class SharedImmutable\n+\n+// FILE: test.kt\n+import kotlin.native.concurrent.SharedImmutable\n+data class Point(val x: Double, val y: Double)\n+@SharedImmutable\n+val point1 = Point(1.0, 1.0)\n+\n+<!INAPPLICABLE_SHARED_IMMUTABLE_VAR!>@SharedImmutable<!>\n+var point2 = Point(2.0, 2.0)\n+\n+class Date(<!INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL!>@SharedImmutable<!> val month: Int, <!INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, INAPPLICABLE_SHARED_IMMUTABLE_VAR!>@SharedImmutable<!> var day:Int)\n+class Person(val name: String) {\n+    <!INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, INAPPLICABLE_SHARED_IMMUTABLE_VAR!>@SharedImmutable<!>\n+    var surname: String? = null\n+}\n+\n+class Figure {\n+    @SharedImmutable", "msg": "I guess `@SharedImmutable` on computed properties should be an error too."}
{"patch": "@@ -20,6 +20,8 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             ErrorsNative.INCOMPATIBLE_THROWS_INHERITED, \"Member inherits different @Throws filters from {0}\",\n             Renderers.commaSeparated(Renderers.NAME)\n         )\n+        put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_VAR, \"@SharedImmutable isn't applicable to var\")\n+        put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, \"@SharedImmutable is applicable only to top level entities\")", "msg": "> entities\r\n\r\ndeclarations"}
{"patch": "@@ -0,0 +1,9 @@\n+// FILE: test.kt\n+class AtomicInt(var value: Int)\n+object Foo {\n+    <!VARIABLE_IN_TOP_LEVEL_SINGLETON_WITHOUT_THERAD_LOCAL!>var field1: Int = 10<!>\n+    val backer2 = AtomicInt(0)\n+    var field2: Int\n+        get() = backer2.value\n+        set(value: Int) { backer2.value = value }\n+}", "msg": "No tests for `@ThreadLocal` singletons.\r\nAlso no tests for plain top-level properties."}
{"patch": "@@ -54,6 +57,10 @@ data class CompilerVersionImpl(\n             append('.')\n             append(maintenance)\n         }\n+        if (milestone != 0) {", "msg": "`M0` seems to be a valid version. May be use -1 to indicate that the milestone version is empty?"}
{"patch": "@@ -281,7 +279,16 @@ fun KtExpression.readWriteAccessWithFullExpression(useResolveForReadWrite: Boole\n }\n \n fun KtReference.canBeResolvedViaImport(target: DeclarationDescriptor, bindingContext: BindingContext): Boolean {\n-    if (this is KDocReference) return element.getQualifiedName().size == 1\n+    if (this is KDocReference) {\n+        val qualifier = element.getQualifier() ?: return true\n+        return if (target.isExtension) {\n+            val elementHasFunctionDescriptor = element.resolveMainReferenceToDescriptors().find { it is FunctionDescriptor } != null", "msg": "It would be better to use `any { it is FunctionDescriptor }` rather `find { it is FunctionDescriptor } != null`"}
{"patch": "@@ -281,7 +279,16 @@ fun KtExpression.readWriteAccessWithFullExpression(useResolveForReadWrite: Boole\n }\n \n fun KtReference.canBeResolvedViaImport(target: DeclarationDescriptor, bindingContext: BindingContext): Boolean {\n-    if (this is KDocReference) return element.getQualifiedName().size == 1\n+    if (this is KDocReference) {\n+        val qualifier = element.getQualifier() ?: return true\n+        return if (target.isExtension) {\n+            val elementHasFunctionDescriptor = element.resolveMainReferenceToDescriptors().find { it is FunctionDescriptor } != null\n+            val qualifierHasClassDescriptor = qualifier.resolveMainReferenceToDescriptors().find { it is ClassDescriptor } != null", "msg": "same as line above"}
{"patch": "@@ -661,6 +662,7 @@ class KtPsiFactory @JvmOverloads constructor(private val project: Project, val m\n         }\n \n         enum class State {\n+            ANNOTATIONS,", "msg": "Annotations are modifiers, so changes to this file aren't needed."}
{"patch": "@@ -55,7 +55,13 @@ private fun buildSignature(config: ExtractionGeneratorConfiguration, renderer: D\n         ExtractionTarget.FUNCTION, ExtractionTarget.FAKE_LAMBDALIKE_FUNCTION -> CallableBuilder.Target.FUNCTION\n         else -> CallableBuilder.Target.READ_ONLY_PROPERTY\n     }\n-    return CallableBuilder(builderTarget).apply {\n+\n+    val includesAnnotations = config.descriptor.annotations.isNotEmpty()\n+\n+    return CallableBuilder(builderTarget, includesAnnotations).apply {\n+        if (includesAnnotations) {\n+            annotations(config.descriptor.annotations)\n+        }", "msg": "Given the comment above, annotations should be generated here by `renderer` and added to the `modifier` function call as prefix.\r\n```kotlin\r\nval annotations = config.descriptor.annotations.joinToString(separator = \"\\n\", postfix = \"\\n\") {\r\n    renderer.renderAnnotation(it)\r\n}\r\n```"}
{"patch": "@@ -58,4 +65,16 @@ class CanBePrimaryConstructorPropertyInspection : AbstractKotlinInspection() {\n             )\n         })\n     }\n+\n+    private fun KtClass.isOpen(): Boolean {\n+        return hasModifier(KtTokens.OPEN_KEYWORD) || hasModifier(KtTokens.ABSTRACT_KEYWORD) || hasModifier(KtTokens.SEALED_KEYWORD)\n+    }\n+\n+    private fun KtParameter.isUsedInClassInitializer(containingClass: KtClass): Boolean {\n+        val name = this.name\n+        val classInitializer = containingClass.body?.declarations?.firstIsInstanceOrNull<KtClassInitializer>() ?: return false\n+        return classInitializer.anyDescendantOfType<KtNameReferenceExpression> {\n+            it.text == name && it.mainReference.resolve() == this\n+        }", "msg": "Please reuse the function `hasUsages`. \r\n```suggestion\r\n        val classInitializer = containingClass.body?.declarations?.firstIsInstanceOrNull<KtClassInitializer>() ?: return false\r\n        return hasUsages(classInitializer)\r\n```"}
{"patch": "@@ -20,6 +20,8 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             ErrorsNative.INCOMPATIBLE_THROWS_INHERITED, \"Member inherits different @Throws filters from {0}\",\n             Renderers.commaSeparated(Renderers.NAME)\n         )\n+        put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_PROPERTY, \"@SharedImmutable isn't applicable to current property\")", "msg": "1. Kinda unclear. The message should list exact requirements for `@SharedImmutable`.\r\n2. \"current\" doesn't fit here. Maybe \"this\"?"}
{"patch": "@@ -764,6 +764,16 @@ class Collections {\n         }\n     }\n \n+    class Filtering {\n+        @Sample\n+        fun filter() {\n+            val numbers: List<Int> = listOf(1, 2, 3, 4)\n+            val evenNumbers = numbers.filter { number -> number.rem(2) == 0 }", "msg": "Two notes:\r\n- better to use `%` infix operator instead of its named form `rem`\r\n- short lambdas usually do not introduce name for its parameter and use default `it` instead.\r\n\r\nIt may be beneficial, however, to show both variants, so we can do the following: \r\n- use `it` in `filter` lambda\r\n- write another expression with `filterNot` that uses explicit parameter name\r\n- now this sample can be used for `filterNot` as well :)"}
{"patch": "@@ -548,6 +548,7 @@ object Filtering : TemplateGroupBase() {\n         specialFor(ArraysOfUnsigned) { inlineOnly() }\n \n         doc { \"Returns a ${f.mapResult} containing only ${f.element.pluralize()} matching the given [predicate].\" }\n+        sample(\"samples.collections.Collections.Filtering.filter\")", "msg": "Have you run stdlib code generation after that? It should affect array `filter` extension too. "}
{"patch": "@@ -15,6 +15,7 @@ import org.jetbrains.kotlin.descriptors.commonizer.Target\n import org.jetbrains.kotlin.descriptors.commonizer.utils.ResettableClockMark\n import org.jetbrains.kotlin.konan.library.*\n import org.jetbrains.kotlin.konan.target.KonanTarget\n+import org.jetbrains.kotlin.incremental.components.LookupTracker", "msg": "(minor) unused?"}
{"patch": "@@ -136,12 +136,20 @@ private class CollectionStubMethodLowering(val context: JvmBackendContext) : Cla\n         return mutableClass.typeParameters.map { it.symbol }.zip(readOnlyClassTypeArguments).toMap()\n     }\n \n+    // Preserve old backend's logic to generate stubs for special cases where a mutable method\n+    // have same jvm signature with an immutable method.\n+    private val specialNames = setOf(\"listIterator\", \"subList\")\n+\n     private inner class StubsForCollectionClass(\n         val readOnlyClass: IrClassSymbol,\n         val mutableClass: IrClassSymbol\n     ) {\n         val mutableOnlyMethods: Collection<IrSimpleFunction> by lazy {\n-            val readOnlyMethodSignatures = readOnlyClass.functions.map { it.owner.toSignature() }.toHashSet()\n+            val readOnlyMethodSignatures = readOnlyClass\n+                .functions\n+                .filter { it.owner.name.asString() !in specialNames }", "msg": "Please use the full JVM signature (after the subsequent `.map { it.owner.toSignature() }` call) to filter out these members, instead of only name"}
{"patch": "@@ -24,7 +24,17 @@ import org.jetbrains.kotlin.util.kind\n \n class ConvertSecondaryConstructorToPrimaryInspection : IntentionBasedInspection<KtSecondaryConstructor>(\n     ConvertSecondaryConstructorToPrimaryIntention::class,\n-    { constructor -> constructor.containingClass()?.secondaryConstructors?.size == 1 }\n+    fun(constructor: KtSecondaryConstructor): Boolean {\n+        val containingClass = constructor.containingClass() ?: return false\n+        if (containingClass.secondaryConstructors.size != 1) return false\n+        val parameterToPropertyMap = mutableMapOf<ValueParameterDescriptor, PropertyDescriptor>()\n+        with(ConvertSecondaryConstructorToPrimaryIntention) {\n+            constructor.extractInitializer(parameterToPropertyMap, containingClass.analyzeWithContent(), KtPsiFactory(constructor))", "msg": "It seems the result value of this expression is not used."}
{"patch": "@@ -80,7 +82,12 @@ class ReplaceJavaStaticMethodWithKotlinAnalogInspection : AbstractKotlinInspecti\n                     \"kotlin.primitives.$kotlinPrimitive.toString\",\n                     ToExtensionFunctionWithNullableReceiver\n                 ) {\n-                    it.valueArguments.size == 1\n+                    val valueArguments = it.valueArguments\n+                    valueArguments.size == 1 && if (javaPrimitive == \"Character\") {\n+                        valueArguments.first().getArgumentExpression()?.getType(it.analyze(BodyResolveMode.PARTIAL))?.isChar() == true", "msg": "I would split this line to several, as it's hard to read."}
{"patch": "@@ -35,6 +39,10 @@ class SimplifiableCallChainInspection : AbstractCallChainChecker() {\n                         }\n                     ) return@check false\n                 }\n+                if (!conversion.enableSuspendFunctionCall && firstResolvedCall.call.callElement.anyDescendantOfType<KtCallExpression> {", "msg": "I would do something with the formatting here :)\r\nMaybe, extract the `firstResolvedCall.call.callElement.anyDescendantOfType()` call so the whole `if` condition fit into a single line?"}
{"patch": "@@ -25,6 +25,9 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@SharedImmutable is applicable only to val with backing field or to property with delegation\"\n         )\n         put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, \"@SharedImmutable is applicable only to top level declarations\")\n+        put(ErrorsNative.VARIABLE_IN_TOP_LEVEL_SINGLETON_WITHOUT_THREAD_LOCAL, \"Variable in top level singleton without @ThreadLocal\")", "msg": "\"Top level\" is redundant here (e.g. `companion object`)."}
{"patch": "@@ -25,6 +25,9 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@SharedImmutable is applicable only to val with backing field or to property with delegation\"\n         )\n         put(ErrorsNative.INAPPLICABLE_SHARED_IMMUTABLE_TOP_LEVEL, \"@SharedImmutable is applicable only to top level declarations\")\n+        put(ErrorsNative.VARIABLE_IN_TOP_LEVEL_SINGLETON_WITHOUT_THREAD_LOCAL, \"Variable in top level singleton without @ThreadLocal\")\n+        put(ErrorsNative.ENUM_THREAD_LOCAL_INAPPLICABLE, \"@ThreadLocal isn't applicable to enum classes\")\n+        put(ErrorsNative.VARIABLE_IN_ENUM, \"Variable in enum class can't be changed after initialization\")", "msg": "Enum classes follow the same rules as `object` without `@ThreadLocal`, so I guess messages should probably be very similar in this part."}
{"patch": "@@ -80,10 +81,14 @@ class Equals(val operator: IElementType) : IntrinsicMethod() {\n         val leftType = with(codegen) { a.asmType }\n         val rightType = with(codegen) { b.asmType }\n         val opToken = expression.origin\n+        val aIsEnum = a.type.classOrNull?.owner?.isEnumClass == true\n+        val bIsEnum = b.type.classOrNull?.owner?.isEnumClass != true", "msg": "Not sure if this works, but I guess it should be `== true` here?"}
{"patch": "@@ -136,12 +136,24 @@ private class CollectionStubMethodLowering(val context: JvmBackendContext) : Cla\n         return mutableClass.typeParameters.map { it.symbol }.zip(readOnlyClassTypeArguments).toMap()\n     }\n \n+    // Preserve old backend's logic to generate stubs for special cases where a mutable method\n+    // have same jvm signature with an immutable method.\n+    private val specialSignatures = setOf(", "msg": "Could you please name this variable something more specific and reflecting its purpose?\r\n\r\nFor example, `specialCaseStubSignaturesForOldBackend`.\r\n\r\nAnd also please mention the issue [KT-36724](https://youtrack.jetbrains.com/issue/KT-36724) in the comment. We'd like to fix this issue in the old backend at some point."}
{"patch": "@@ -23,7 +24,8 @@ class IrPluginContext(\n     val symbolTable: SymbolTable,\n     val typeTranslator: TypeTranslator,\n     override val irBuiltIns: IrBuiltIns,\n-    val symbols: BuiltinSymbolsBase = BuiltinSymbolsBase(irBuiltIns.builtIns, symbolTable)\n+    val symbols: BuiltinSymbolsBase = BuiltinSymbolsBase(irBuiltIns.builtIns, symbolTable),\n+    val irProviders: List<IrProvider>", "msg": "I'd suggest to add an ability to provide only one `IrProvider` and pass `CompositeIrProvider` (unexisting yet)."}
{"patch": "@@ -53,6 +65,7 @@ object JvmBackendFacade {\n         val stubGenerator = DeclarationStubGenerator(\n             psi2irContext.moduleDescriptor, psi2irContext.symbolTable, psi2irContext.irBuiltIns.languageVersionSettings, extensions\n         )\n+        stubGenerator.setIrProviders(irProviders)\n         val deserializer = JvmIrLinker(", "msg": "Move to line 47?"}
{"patch": "@@ -53,6 +65,7 @@ object JvmBackendFacade {\n         val stubGenerator = DeclarationStubGenerator(\n             psi2irContext.moduleDescriptor, psi2irContext.symbolTable, psi2irContext.irBuiltIns.languageVersionSettings, extensions\n         )\n+        stubGenerator.setIrProviders(irProviders)\n         val deserializer = JvmIrLinker(", "msg": "Do we need to recreate the `IrProvider` setup here? Why not reuse the one you built earlier?"}
{"patch": "@@ -270,20 +275,33 @@ class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransformer) :\n             return when {\n                 operatorCallReference == null || (!lhsIsVar && !assignIsError) -> resolvedAssignCall.compose()\n                 assignCallReference == null -> {\n-                    val assignment =\n-                        buildVariableAssignment {\n+                    if (leftArgument is FirFunctionCall && leftArgument.calleeReference.source?.psi is KtArrayAccessExpression) {", "msg": "Please avoid checking something in FIR using psi reference. FIR should have enough information itself (if it's not true for the particular case, we should add necessary information). Moreover, when we build FIR using lighter AST mode we do not have this psi reference at all. "}
{"patch": "@@ -270,20 +275,33 @@ class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransformer) :\n             return when {\n                 operatorCallReference == null || (!lhsIsVar && !assignIsError) -> resolvedAssignCall.compose()\n                 assignCallReference == null -> {\n-                    val assignment =\n-                        buildVariableAssignment {\n+                    if (leftArgument is FirFunctionCall && leftArgument.calleeReference.source?.psi is KtArrayAccessExpression) {\n+                        val setCall = buildFunctionCall {", "msg": "I'm not quite sure here, but may be in this case we should create function call from the beginning (I mean, in raw FIR)?"}
{"patch": "@@ -0,0 +1,116 @@\n+/*", "msg": "Seem like another copy-pasted file. Hopefully will go as well, when the compiler will be moved to the appropriate module."}
{"patch": "@@ -0,0 +1,152 @@\n+/*", "msg": "Another unnecessary copy-paste."}
{"patch": "@@ -0,0 +1,33 @@\n+/*", "msg": "And this is, imho, unnecessary copy-paste too."}
{"patch": "@@ -0,0 +1,216 @@\n+/*", "msg": "And this is, imho, unnecessary copy-paste too."}
{"patch": "@@ -0,0 +1,36 @@\n+// IGNORE_BACKEND_MULTI_MODULE: JVM_IR\n+// FILE: 1.kt\n+package test\n+\n+@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n+@kotlin.internal.InlineOnly\n+inline fun <T, R> T.myLet(block: (T) -> R) = block(this)\n+\n+// FILE: 2.kt\n+import test.*\n+\n+fun box(): String {\n+    // should not have a line number for 1.kt:7; *should* have one for the lambda\n+    // in order to let the debugger break on it (KT-23064)\n+    return \"O\".myLet { it + \"K\" }", "msg": "Please test also \r\n     return \"O\".myLet(fun (it: String) : String {return it +  \"K\"})"}
{"patch": "@@ -328,7 +331,18 @@ internal class CallGenerator(\n             is IrFieldExpressionBase -> {", "msg": "Hm, github doesn't allow me to leave comments outside of changes. :\\\r\n\r\nAnyhow, I saw that applying the same idea to `IrCallImpl` case above, in particular, `dispatchReceiver` for call expression without selector could also unmute 17 cases, but broke many others. :p It may require more careful accessibility check I guess. I'll dig into that as well, if this approach looks good."}
{"patch": "@@ -328,7 +331,18 @@ internal class CallGenerator(\n             is IrFieldExpressionBase -> {\n                 val ownerField = symbol.owner\n                 if (!ownerField.isStatic) {\n-                    receiver = qualifiedAccess.findIrDispatchReceiver()\n+                    // Qualified access with a selector: use the bound dispatch receiver.\n+                    if (qualifiedAccess.explicitReceiver != null) {\n+                        receiver = qualifiedAccess.findIrDispatchReceiver()\n+                    } else {\n+                        // Otherwise, find the dispatch receiver from the scope with a condition:\n+                        //   the function in the scope has access to the field of interest.\n+                        conversionScope.lastDispatchReceiverParameter { function ->", "msg": "IMHO this logic looks a bit hacky. I will think about alternative variants and write you."}
{"patch": "@@ -73,7 +72,7 @@ abstract class BaseFirBuilder<T>(val baseSession: FirSession, val context: Conte\n         when {\n             local -> CallableId(name)\n             context.className == FqName.ROOT -> CallableId(context.packageFqName, name)\n-            context.className.shortName() === ANONYMOUS_OBJECT_NAME -> CallableId(FqName.ROOT, FqName(\"anonymous\"), name)\n+            context.className.shortName() === ANONYMOUS_OBJECT_NAME -> CallableId(ANONYMOUS_CLASS_ID, name)\n             else -> CallableId(context.packageFqName, context.className, name)", "msg": "I guess this default case could be potentially `CallableId(context.currentClassId, name)` so that we can propagate the correct `ClassId`, but broke a couple cases. :\\ In particular, some lookup, which returns class-like symbol, expects the lookup target should never be a local. It has been local, but this may disclose a hidden issue."}
{"patch": "@@ -39,12 +38,12 @@ class SamConversionToAnonymousObjectIntention : SelfTargetingRangeIntention<KtCa\n         val callee = element.calleeExpression ?: return null\n         val lambda = getLambdaExpression(element) ?: return null\n         val functionLiteral = lambda.functionLiteral\n-        val descriptor = (functionLiteral.descriptor as? FunctionDescriptor) ?: return null\n         val bindingContext = functionLiteral.analyze()\n         val sam = element.getSingleAbstractMethod(bindingContext) ?: return null\n \n         val samValueParameters = sam.valueParameters\n         val samValueParameterSize = samValueParameters.size\n+        val descriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, functionLiteral] as? FunctionDescriptor ?: return null", "msg": "You are reusing `bindingContext` here, but in the `applyTo` you are still using `descriptor` extension. What is the reason for that"}
{"patch": "@@ -228,6 +228,34 @@ class Sequences {\n             val result = sequenceA.zip(sequenceB) { a, b -> \"$a/$b\" }\n             assertPrints(result.take(4).toList(), \"[a/1, b/3, c/7, d/15]\")\n         }\n+\n+        @Sample\n+        fun flattenSequenceOfSequences() {\n+            val sequence = generateSequence(1) { it + 1 }\n+            val sequenceOfSequences = sequence.map { num ->\n+                generateSequence { num }.take(num)\n+            }\n+\n+            assertPrints(sequenceOfSequences.flatten().take(10).toList(), \"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\")\n+        }\n+\n+        @Sample\n+        fun flattenSequenceOfLists() {\n+            val sequence = generateSequence(1) { it + 1 }\n+            val sequenceOfLists = sequence.map { num ->\n+                generateSequence { num }.take(num).toList()", "msg": "It might be quite confusing that the sample for flattening a sequence of _lists_ is too similar to the one for sequence of _sequences_.\r\nCould you instantiate the inner list without using sequences? "}
{"patch": "@@ -570,11 +672,11 @@ open class WrappedClassDescriptor(\n \n     override fun getSource() = sourceElement\n \n-    override fun getConstructors() = owner.declarations.asSequence().filterIsInstance<IrConstructor>().map { it.descriptor }.toList()\n+    override fun getConstructors() =\n+        owner.declarations.filterIsInstance<IrConstructor>().filter { !it.origin.isSynthetic }.map { it.descriptor }.toList()", "msg": "There are 10+ cases that failed with visibility conversion error: package-private (which should be normalized in general) doesn't have a counter part. By comparing `psi2ir` path, I noticed that all those cases have private constructor with default values, which is lowered by adding a synthetic constructor with package-private visibility.\r\n\r\nThe difference is, during serialization, `LazyClassDescriptor#getConstructors` returns constructors that literally appear in the PSI, which means we need to filter out synthetic ones here."}
{"patch": "@@ -1,3 +1,5 @@\n+// IGNORE_BACKEND_FIR: JVM_IR\n+", "msg": "This is the only one regression, though. After having a correct metadata, proper serialization started, and found that, when serializing the extension receiver of `tableView` below, type parameter `T` for `Table<T>` didn't have a counter part, type argument in the converted IrType. This means that type arguments for generic types are missing in general. I left a TODO/comment about this on our doc."}
{"patch": "@@ -62,8 +67,9 @@ internal class AnnotationEntryReplacementPerformer(\n         assert(range.first == range.last)\n         assert(range.first is KtAnnotationEntry)\n         val annotationEntry = range.first as KtAnnotationEntry\n-        val text = annotationEntry.valueArguments.single().getArgumentExpression()!!.text\n-        return annotationEntry.replaced(psiFactory.createAnnotationEntry(\"@$text\"))\n+        val text = \"@${useSiteTargetText}${annotationEntry.valueArguments.single().getArgumentExpression()!!.text}\"\n+        val newAnnotationEntry = if (isFileUseSiteTarget) psiFactory.createFileAnnotation(text) else psiFactory.createAnnotationEntry(text)\n+        return annotationEntry.replaced(newAnnotationEntry)", "msg": "```suggestion\r\n        val text = annotationEntry.valueArguments.single().getArgumentExpression()!!.text\r\n        val newAnnotationEntry = if (isFileUseSiteTarget)\r\n            psiFactory.createFileAnnotation(text)\r\n        else\r\n            psiFactory.createAnnotationEntry(\"@$useSiteTargetText$text\")\r\n        return annotationEntry.replaced(newAnnotationEntry)\r\n```"}
{"patch": "@@ -6,14 +6,14 @@ package p\n private fun foo(a: Int) = run {\n     object {\n         inner class A\n-        fun foo() = A()\n+        <!EXPOSED_FUNCTION_RETURN_TYPE!>fun foo() = A()<!>", "msg": "Probably it's the same problem with local visibility. We should not have errors here."}
{"patch": "@@ -216,10 +213,21 @@ fun IrDeclaration.isInCurrentModule(): Boolean =\n // This is needed to pinpoint exceptional treatment of IEEE754 floating point comparisons, where proper IEEE\n // comparisons are used \"if values are statically known to be of primitive numeric types\", taken to mean as\n // \"not learned through smartcasting\".\n-fun IrExpression.isSmartcastFromHigherThanNullable(context: JvmBackendContext) =\n-    this is IrTypeOperatorCall &&\n-            operator == IrTypeOperator.IMPLICIT_CAST &&\n-            !this.argument.type.isSubtypeOf(type.makeNullable(), context.irBuiltIns)\n+fun IrExpression.isSmartcastFromHigherThanNullable(context: JvmBackendContext): Boolean {\n+    return when (this) {\n+        is IrTypeOperatorCall -> operator == IrTypeOperator.IMPLICIT_CAST && !argument.type.isSubtypeOf(", "msg": "Nit: I'd break this differently.\r\n```kotlin\r\nis IrTypeOperatorCall -> operator == IrTypeOperator.IMPLICIT_CAST &&\r\n    !argument.type.isSubtypeOf(type.makeNullable(), context.irBuiltIns)\r\n```"}
{"patch": "@@ -305,51 +309,33 @@ class MethodInliner(\n                     inlineOnlySmapSkipper?.markCallSiteLineNumber(remappingMethodAdapter)\n                 } else if (isAnonymousConstructorCall(owner, name)) { //TODO add method\n                     //TODO add proper message\n-                    assert(transformationInfo is AnonymousObjectTransformationInfo) {\n+                    var info = transformationInfo as? AnonymousObjectTransformationInfo ?: throw AssertionError(\n                         \"<init> call doesn't correspond to object transformation info for '$owner.$name': $transformationInfo\"\n+                    )\n+                    val ownerIsParentClass = inlineCallSiteInfo.ownerClassName == info.oldClassName", "msg": "maybe smth like `isRecreatesItself`?"}
{"patch": "@@ -64,6 +64,12 @@ open class BuiltinSymbolsBase(protected val builtIns: KotlinBuiltIns, private va\n             builtInsPackage(*packageNameSegments).getContributedClassifier(name, NoLookupLocation.FROM_BACKEND) as ClassDescriptor\n         )\n \n+    private fun getClassOrNull(name: Name, vararg packageNameSegments: String = arrayOf(\"kotlin\")): IrClassSymbol? =", "msg": "I'd rewrite `getClass` above now with something like\r\n```\r\ngetClassOrNull(name, *packageNameSegments) ?: error(\"Class $name is not found in ${packageNameSegments.toList()}\")\r\n```"}
{"patch": "@@ -262,13 +318,17 @@ internal abstract class HeaderInfoBuilder(context: CommonBackendContext, private\n     private val symbols = context.ir.symbols\n \n     // TODO: Include unsigned types\n-    private val progressionElementTypes = listOf(\n-        context.irBuiltIns.byteType,\n-        context.irBuiltIns.shortType,\n-        context.irBuiltIns.intType,\n-        context.irBuiltIns.longType,\n-        context.irBuiltIns.charType\n-    )\n+    private val progressionElementTypes = listOfNotNull(", "msg": "I suppose the TODO above is fixed"}
{"patch": "@@ -89,6 +91,32 @@ class Fir2IrClassifierStorage(\n                     ?: createIrTypeParameterWithoutBounds(original, index, context)\n             }\n         }\n+        if (owner is FirCallableDeclaration<*>) {\n+            val typeParameterInReturnType = owner.returnTypeRef.retrieveTypeParameter()\n+            if (typeParameterInReturnType != null) {\n+                getCachedIrTypeParameter(typeParameterInReturnType)\n+                    ?: createIrTypeParameterWithoutBounds(typeParameterInReturnType, index = 0)", "msg": "This is strange place, as well as the next one. Normally we should not create type parameter when we don't know its index. This will anyway work incorrectly if a corresponding declaration has more than one type parameter."}
{"patch": "@@ -87,7 +84,19 @@ class ObjectUsageLowering(\n                 val initInstanceField = context.createIrBuilder(container.symbol).buildStatement(UNDEFINED_OFFSET, UNDEFINED_OFFSET) {\n                     irSetField(null, instanceField, irGet(irClass.thisReceiver!!))\n                 }\n-                (irBody as IrBlockBody).statements.add(0, initInstanceField)\n+                if (context.es6mode) {\n+                    //find super and put after\n+                    val index = (irBody as IrBlockBody).statements\n+                        .indexOfFirst { it is IrDelegatingConstructorCall || it is IrVariable && it.origin === ES6_THIS_VARIABLE_ORIGIN }", "msg": "`IrElementTransformer`?"}
{"patch": "@@ -24,7 +24,7 @@ class ThrowableLowering(val context: JsIrBackendContext) : BodyLoweringPass {\n \n     private val throwableConstructors = context.throwableConstructors\n     private val newThrowableFunction = context.newThrowableSymbol\n-    private val extendThrowableFunction = context.extendThrowableSymbol\n+    private val extendThrowableFunction = with(context) { if (es6mode) setPropertiesToThrowableInstanceSymbol else extendThrowableSymbol }", "msg": "Let pass it to constructor"}
{"patch": "@@ -111,18 +139,40 @@ class JsClassGenerator(private val irClass: IrClass, val context: JsGenerationCo\n     }\n \n     private fun generateMemberFunction(declaration: IrSimpleFunction): JsStatement? {\n-\n         val memberName = context.getNameForMemberFunction(declaration.realOverrideTarget)\n         val memberRef = JsNameRef(memberName, classPrototypeRef)\n \n         if (declaration.isReal && declaration.body != null) {\n             val translatedFunction = declaration.accept(IrFunctionToJsTransformer(), context)\n-\n             assert(!declaration.isStaticMethodOfClass)\n \n             return jsAssignment(memberRef, translatedFunction.apply { name = null }).makeStmt()\n         }\n \n+        generateOverrides(declaration)\n+\n+        return null\n+    }\n+\n+    private fun generateMemberFunctionES6(declaration: IrSimpleFunction): JsFunction? {", "msg": "Seems like both functions could be merged"}
{"patch": "@@ -141,4 +176,22 @@ object FirExposedVisibilityChecker : FirDeclarationChecker<FirMemberDeclaration>\n             identifier?.toFirLightSourceElement(this.tree.getStartOffset(identifier), this.tree.getEndOffset(identifier), this.tree)\n         }\n     }\n+\n+    private fun FirRegularClass.getSupertypeSources(): List<FirSourceElement>? {\n+        when (val source = this.source) {", "msg": "All this code is too nightmarish to leave it. I took source just from `superTypeRef`. It contradicts with old front-end at some point, e.g. reports on `Base` instead of `Base()`, but at this point it looks even more correct."}
{"patch": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.core.formatter\n+\n+import org.jetbrains.kotlin.resolve.ImportPath\n+\n+class KotlinPackageEntry(\n+    packageName: String,\n+    val withSubpackages: Boolean\n+) {\n+    val packageName = packageName.removeSuffix(\".*\")\n+\n+    companion object {\n+        @JvmField\n+        val ALL_OTHER_IMPORTS_ENTRY = KotlinPackageEntry(\"<all other imports>\", withSubpackages = true)\n+\n+        @JvmField\n+        val ALL_OTHER_ALIAS_IMPORTS_ENTRY = KotlinPackageEntry(\"<all other alias imports>\", withSubpackages = true)\n+    }\n+\n+    fun matchesPackageName(otherPackageName: String): Boolean {\n+        if (this == ALL_OTHER_IMPORTS_ENTRY || this == ALL_OTHER_ALIAS_IMPORTS_ENTRY) return true", "msg": "`isSpecial` can be used here, I guess"}
{"patch": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.core.formatter\n+\n+import com.intellij.openapi.util.InvalidDataException\n+import com.intellij.openapi.util.JDOMExternalizable\n+import org.jdom.Element\n+\n+class KotlinPackageEntryTable: JDOMExternalizable, Cloneable {\n+    private val entries = mutableListOf<KotlinPackageEntry>()\n+\n+    override fun equals(other: Any?): Boolean {\n+        if (other !is KotlinPackageEntryTable) return false\n+        if (other.entries.size != entries.size) return false\n+\n+        return entries.zip(other.entries).any { (entry, otherEntry) -> entry != otherEntry }", "msg": "This looks like a regular `==` for lists\r\n\r\nAlso, it seems strange that when any package is not equals, `equals` returns `true`"}
{"patch": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.core.formatter\n+\n+import com.intellij.openapi.util.InvalidDataException\n+import com.intellij.openapi.util.JDOMExternalizable\n+import org.jdom.Element\n+\n+class KotlinPackageEntryTable: JDOMExternalizable, Cloneable {\n+    private val entries = mutableListOf<KotlinPackageEntry>()\n+\n+    override fun equals(other: Any?): Boolean {", "msg": "I do not see any usage of `equals` on this class; do we actually need it? Same goes to the `hashCode`"}
{"patch": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.core.formatter\n+\n+import org.jetbrains.kotlin.resolve.ImportPath\n+\n+class KotlinPackageEntry(\n+    packageName: String,\n+    val withSubpackages: Boolean\n+) {\n+    val packageName = packageName.removeSuffix(\".*\")\n+\n+    companion object {\n+        @JvmField\n+        val ALL_OTHER_IMPORTS_ENTRY = KotlinPackageEntry(\"<all other imports>\", withSubpackages = true)\n+\n+        @JvmField\n+        val ALL_OTHER_ALIAS_IMPORTS_ENTRY = KotlinPackageEntry(\"<all other alias imports>\", withSubpackages = true)\n+    }\n+\n+    fun matchesPackageName(otherPackageName: String): Boolean {", "msg": "This function can be private"}
{"patch": "@@ -133,12 +145,12 @@ class ImportSettingsPanel(private val commonSettings: CodeStyleSettings) : JPane\n             return checkBox.isSelected != value\n         }\n \n-        private fun isModified(list: PackageEntryTable, table: PackageEntryTable): Boolean {\n-            if (list.entryCount != table.entryCount) {\n+        private fun isModified(list: KotlinPackageEntryTable, table: KotlinPackageEntryTable): Boolean {\n+            if (list.getEntryCount() != table.getEntryCount()) {", "msg": "You can convert this to property to avoid code change here"}
{"patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.util\n+\n+import org.jetbrains.kotlin.idea.core.formatter.KotlinPackageEntry\n+import org.jetbrains.kotlin.idea.core.formatter.KotlinPackageEntryTable\n+import org.jetbrains.kotlin.resolve.ImportPath\n+import java.util.Comparator\n+\n+class ImportPathComparator(\n+    private val packageTable: KotlinPackageEntryTable\n+) : Comparator<ImportPath> {\n+    override fun compare(import1: ImportPath, import2: ImportPath): Int {", "msg": "I would rewrite it like this: \r\n\r\n```kt\r\n    private val comparator = compareBy<ImportPath>(\r\n        { import -> bestMatchIndex(import) },\r\n        { import -> import.toString() }\r\n    )\r\n\r\n    override fun compare(import1: ImportPath, import2: ImportPath): Int = \r\n        comparator.compare(import1, import2)\r\n```\r\n\r\nIMO it is clearer and leaves less room for error"}
{"patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.js.test.es6.semantics\n+\n+import org.jetbrains.kotlin.js.test.BasicIrBoxES6Test\n+import org.jetbrains.kotlin.js.test.ir.semantics.AbstractIrJsTypeScriptExportTest\n+import org.jetbrains.kotlin.test.TargetBackend\n+\n+abstract class AbstractIrBoxJsES6Test : BasicIrBoxES6Test(TEST_DATA_DIR_PATH + \"box/\", \"irBox/\")\n+\n+abstract class AbstractIrJsCodegenBoxES6Test : BasicIrBoxES6Test(\n+    \"compiler/testData/codegen/box/\",\n+    \"codegen/irBox/\"\n+)\n+\n+abstract class AbstractIrWasmBoxJsES6Test : BasicIrBoxES6Test(", "msg": "This is not actually needed "}
{"patch": "@@ -362,7 +362,12 @@ class EnumEntryInstancesBodyLowering(val context: JsIrBackendContext) : BodyLowe\n             val enum = entryClass.parentAsClass\n             if (enum.goodEnum) {\n                 val entry = enum.declarations.filterIsInstance<IrEnumEntry>().find { it.correspondingClass === entryClass }!!\n-                (irBody as IrBlockBody).statements.add(0, context.createIrBuilder(container.symbol).run {\n+", "msg": "This code worth some explanation. "}
{"patch": "@@ -320,6 +325,13 @@ fun usefulDeclarations(roots: Iterable<IrDeclaration>, context: JsIrBackendConte\n                                 toStringMethod.enqueue(\"intrinsic: jsPlus\")\n                             }\n                         }\n+                        context.intrinsics.jsConstruct -> {\n+                            val arg = expression.getValueArgument(0)!!\n+                            val jsClassCall = (arg as? IrCall) ?: ((arg as IrGetValue).symbol.owner as IrVariable).initializer", "msg": "Unclear "}
{"patch": "@@ -296,6 +295,12 @@ fun usefulDeclarations(roots: Iterable<IrDeclaration>, context: JsIrBackendConte\n                             val ref = expression.getTypeArgument(0)!!.classifierOrFail.owner as IrDeclaration\n                             ref.enqueue(\"intrinsic: jsClass\")\n                             referencedJsClasses += ref\n+\n+                            //HACK: es6 result type - construct class in case of\n+                            //`val currResultType = resultType || klass`\n+                            val arg = expression.getTypeArgument(0)!!", "msg": "I would suggest to introduce an additional intrinsic and track it separately "}
{"patch": "@@ -228,7 +228,16 @@ private val removeInlineFunctionsWithReifiedTypeParametersLoweringPhase = makeDe\n )\n \n private val throwableSuccessorsLoweringPhase = makeBodyLoweringPhase(\n-    ::ThrowableLowering,\n+    { context ->\n+        val extendThrowableSymbol = with(context) {", "msg": "`context.run { .. }`"}
{"patch": "@@ -1,4 +1,7 @@\n // EXPECTED_REACHABLE_NODES: 1371\n+// IGNORE_BACKEND: JS_IR_ES6\n+// IGNORE_BACKEND: JS_IR_ES6\n+", "msg": "x2"}
{"patch": "@@ -64,6 +64,18 @@ interface KotlinDependencyHandler {\n         message = \"Use npm(name, version) instead. Name like in package.json\"\n     )\n     fun npm(org: String? = null, packageName: String, version: String = \"*\"): Dependency\n+\n+    fun devNpm(name: String, version: String = \"*\"): Dependency\n+\n+    fun devNpm(name: String, directory: File): Dependency\n+\n+    fun devNpm(directory: File): Dependency\n+\n+    fun peerNpm(name: String, version: String = \"*\"): Dependency\n+\n+    fun peerNpm(name: String, directory: File): Dependency", "msg": "Is peer dependencies support directory notation?\r\nSeems that only\r\n`fun peerNpm(name: String, version: String = \"*\"): Dependency`\r\nehough"}
{"patch": "@@ -107,4 +107,52 @@ class DefaultKotlinDependencyHandler(\n \n     override fun npm(org: String?, packageName: String, version: String) =\n         npm(\"${if (org != null) \"@$org/\" else \"\"}$packageName\", version)\n+\n+    override fun devNpm(name: String, version: String): NpmDependency =\n+        NpmDependency(\n+            project = project,\n+            name = name,\n+            version = version,\n+            scope = NpmDependency.Scope.DEV\n+        )\n+\n+    override fun devNpm(name: String, directory: File): NpmDependency {\n+        check(directory.isDirectory) {", "msg": "This check is duplicated with `npm` function\r\nCan be extracted to separate function `directoryNpmDependency` which do this check and return `NpmDependency` with appropriate scope"}
{"patch": "@@ -19,82 +19,102 @@ interface NpmDependencyExtension {\n     operator fun invoke(directory: File): NpmDependency\n }\n \n-fun Project.addNpmDependencyExtension() {\n-    val dependencies = this.dependencies as ExtensionAware\n-\n-    val npmDependencyExtension: NpmDependencyExtension = object : NpmDependencyExtension, Closure<NpmDependency>(dependencies) {\n-        override operator fun invoke(name: String, version: String): NpmDependency =\n-            NpmDependency(\n-                project = this@addNpmDependencyExtension,\n-                name = name,\n-                version = version\n-            )\n+private abstract class AbstractNpmDependencyExtension(\n+    dependencies: ExtensionAware,", "msg": "Seems that `dependencies` is not needed in constructor, it can been calculated from `project`"}
{"patch": "@@ -64,6 +64,18 @@ interface KotlinDependencyHandler {\n         message = \"Use npm(name, version) instead. Name like in package.json\"\n     )\n     fun npm(org: String? = null, packageName: String, version: String = \"*\"): Dependency\n+\n+    fun devNpm(name: String, version: String = \"*\"): Dependency\n+\n+    fun devNpm(name: String, directory: File): Dependency\n+\n+    fun devNpm(directory: File): Dependency\n+", "msg": "Minor: if you want, you can cover `optionalDependencies`\r\nIts semantic is similar with normal dependencies \r\nAnd JFYI, I started to solve this issue right before you send PR :) \r\nNow I paused it, but you can take a look, can be a bit useful\r\nhttps://github.com/JetBrains/kotlin/tree/rr/gradle/ilgonmic/npm-scopes"}
{"patch": "@@ -13,9 +11,19 @@ fun less4(a: Byte?, b: Byte?) = if (a is Byte && b is Byte) a < b else true\n \n fun less5(a: Any?, b: Any?) = if (a is Byte && b is Byte) a < b else true\n \n+// JVM_TEMPLATES\n // 3 Intrinsics\\.areEqual\n // 0 Intrinsics\\.compare\n // 4 INVOKEVIRTUAL java/lang/Byte\\.byteValue \\(\\)B\n // 2 INVOKEVIRTUAL java/lang/Number\\.intValue \\(\\)I\n // 0 IFGE\n // 3 IF_ICMPGE\n+\n+// JVM_IR_TEMPLATES", "msg": "The change here is that instead of `Number.intValue`, `Number.byteValue` is used when known to be a byte. Additionally, the IR backend actually generates 3 `areEqual` calls, but the asm optimization method visitor then ends up unboxing and using `Number.byteValue` on the arguments."}
{"patch": "@@ -43,6 +43,8 @@ class Fir2IrClassifierStorage(\n \n     private val localStorage = Fir2IrLocalStorage()\n \n+    var converter: Fir2IrConverter? = null", "msg": "`lateinit` should be better here"}
{"patch": "@@ -145,6 +147,15 @@ class Fir2IrClassifierStorage(\n         val origin = regularClass.irOrigin(firProvider)\n         val irClass = registerIrClass(regularClass, parent, origin)\n         processClassHeader(regularClass, irClass)\n+        // TODO: queue-based logic?\n+        // Force loading Java methods in Java SAM stub, since FunctionReferenceLowering relies on it.\n+        if (converter != null && regularClass.origin == FirDeclarationOrigin.Java) {\n+            regularClass.getSamIfAny()?.let { sam ->", "msg": "I think this logic should be in `addDeclarationsToExternalClass` and not here. `createIrClass` should just create a class."}
{"patch": "@@ -54,6 +55,7 @@ class Fir2IrTypeConverter(\n \n     fun FirTypeRef.toIrType(typeContext: ConversionTypeContext = ConversionTypeContext.DEFAULT): IrType {\n         return when (this) {\n+            is FirJavaTypeRef -> coneType?.toIrType(typeContext) ?: createErrorType()", "msg": "Yet it's Ok but I should investigate this place. As I understand we should not have `FirJavaTypeRef` at this point, and if we do, it points to some FIR resolve error."}
{"patch": "@@ -80,9 +82,23 @@ internal fun FirTypeRef.toConeKotlinTypeProbablyFlexible(\n \n internal fun JavaType.toFirJavaTypeRef(session: FirSession, javaTypeParameterStack: JavaTypeParameterStack): FirJavaTypeRef {\n     val annotations = (this as? JavaClassifierType)?.annotations.orEmpty()\n+    val type = this\n     return buildJavaTypeRef {\n         annotations.mapTo(this.annotations) { it.toFirAnnotationCall(session, javaTypeParameterStack) }\n-        type = this@toFirJavaTypeRef\n+        this.type = type", "msg": "I think this code is not needed at all. I'll investigate why `FirJavaTypeRef` remains in resolved FIR."}
{"patch": "@@ -77,13 +77,28 @@ class IntegerLiteralTypeApproximationTransformer(\n         // e.g. Byte doesn't have `and` in member scope. It's an extension\n         if (resultSymbol == null) return functionCall.compose()", "msg": "I found that the original `calleeReference.resolvedSymbol` (after resolution) is of `FirIntegerOperator` from `FirJAvaModuleBasedSession`, while this, kind of reloaded, result symbol is `FirSimpleFunctionImpl` from `FirLibrarySession`. I'm not sure 1) why the latter was not found as a resolution candidate; and 2) why the former was not reloaded again from the member scope lookup."}
{"patch": "@@ -456,7 +457,12 @@ fun FirPropertyBuilder.generateAccessorsByDelegate(\n fun FirTypeRef.convertToArrayType(): FirUserTypeRef = buildUserTypeRef {\n     source = this@convertToArrayType.source\n     isMarkedNullable = false\n-    qualifier += FirQualifierPartImpl(StandardClassIds.Array.shortClassName).apply {\n+    val elementType = this@convertToArrayType as? FirUserTypeRef\n+    val arrayQualifier =\n+        if (elementType != null && elementType.qualifier.size == 1)", "msg": "I would say that this change might be not enough.\r\nFor example, it's not gonna work in case it has a form of `vararg x: kotlin.Int` or `vararg x: MyTypeAliasToInt`.\r\nMaybe it's worth trying to move this logic to `org.jetbrains.kotlin.fir.resolve.transformers.FirTypeResolveTransformer#transformValueParameter` when the type is already resolved properly and we can just use it without guessing\r\n\r\nBTW, something similar is already happening there at `result.transformVarargTypeToArrayType()`.\r\nLooks like we have similar logic in two different places and I would say it's worth investigating which one should work for all cases."}
{"patch": "@@ -113,22 +114,12 @@ class AnonymousObjectTransformer(\n             override fun visitEnd() {}\n         }, ClassReader.SKIP_FRAMES)\n \n-        if (!inliningContext.isInliningLambda) {\n-            sourceMapper = if (debugInfo != null && !debugInfo!!.isEmpty()) {\n-                SourceMapper.createFromSmap(SMAPParser.parse(debugInfo!!))\n-            } else {\n-                //seems we can't do any clever mapping cause we don't know any about original class name\n-                IdenticalSourceMapper\n-            }\n-            if (sourceInfo != null && !GENERATE_SMAP) {\n-                classBuilder.visitSource(sourceInfo!!, debugInfo)\n-            }\n-        } else {\n-            if (sourceInfo != null) {\n-                classBuilder.visitSource(sourceInfo!!, debugInfo)\n-            }\n-            sourceMapper = IdenticalSourceMapper\n-        }\n+        // When regenerating objects in lambdas, keep the old SMAP and don't remap the line numbers to save time.", "msg": "lambdas -> inline lambdas"}
{"patch": "@@ -318,6 +318,20 @@ class Maps {\n             assertPrints(map2, \"{beverage=2.7$, meal=12.4$}\")\n         }\n \n+        @Sample\n+        fun mapNotNull() {\n+            val map1 = mapOf(\"foo\" to 1, \"bar\" to 2, \"baz\" to 3)\n+            val map2 = map1.mapNotNull {", "msg": "There are several problems with this example:\r\n- it doesn't seem to be referenced in code\r\n- `component1` and `equals` are functions to satisfy operator conventions (destructuring and ==), they are rarely called directly in real code. So if you want to compare map entry key with \"bar\", it would be more idiomatic to write `it.key == \"bar\"`\r\n- for `if (predicate(it)) it else null` we have `takeIf` and `takeUnless` functions: \r\n`it.takeUnless { it.key == \"bar\" }`\r\n- the example overall looks like a contrived way to filter map based on keys, so `Map.filterKeys` would probably do fine in this case. On the other hand, the advantage of `mapNotNull` is that is can additionally transform an element, for example, with it we can filter by keys, but return the corresponding values:\r\n`map1.mapNotNull { entry -> entry.takeUnless { it.key == \"bar\" }?.value }` \r\nor using the entry destructuring \r\n`map1.mapNotNull { (key, value) -> value.takeUnless { key == \"bar\" } }`"}
{"patch": "@@ -773,6 +773,27 @@ class Collections {\n             val emptyList = emptyList<Int>()\n             assertPrints(emptyList.elementAtOrElse(0) { \"no int\" }, \"no int\")\n         }\n+\n+        @Sample\n+        fun find() {\n+            val list = listOf(1, 2, 3, 1, 2, 3)\n+            assertPrints(list.find { it == 1 }, \"0\")", "msg": "`find` returns the found element and not its index in the list. Please, ensure that samples really pass by running `:kotlin-stdlib:samples:check` gradle task. \r\n\r\nHere, having the first and the last elements indistinguishable, it's hard to tell which one is actually returned.\r\n\r\nSo, I propose to use slightly less trivial predicate, that could return the same result for different elements, for example `it % 2 == 0` that checks number parity.\r\n```\r\nval numbers = listOf(1, 2, 3, 4, 5, 6, 7)\r\nval firstOdd = numbers.find { it % 2 != 0 }\r\nval lastEven = numbers.findLast { it % 2 == 0 }\r\n...\r\n```"}
{"patch": "@@ -390,4 +390,19 @@ class Strings {\n         assertPrints(matchDetails(inputString, toFind, 2), \"Searching for 'ever' in 'Never ever give up' starting at position 2: Found at 6\")\n         assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n     }\n+\n+    @Sample\n+    fun compareTo() {\n+        val stringA = \"abcd\"\n+        val stringB = \"abcd\"\n+        assertTrue(stringA.compareTo(stringB) == 0)", "msg": "This is not a typical usage of `compareTo`, here `equals` or `==` can be used instead of it."}
{"patch": "@@ -390,4 +390,19 @@ class Strings {\n         assertPrints(matchDetails(inputString, toFind, 2), \"Searching for 'ever' in 'Never ever give up' starting at position 2: Found at 6\")\n         assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n     }\n+\n+    @Sample\n+    fun compareTo() {", "msg": "The sample should be referenced in the docs of the function, otherwise it won't get to the site."}
{"patch": "@@ -61,9 +61,12 @@ class ConeIntegerLiteralTypeImpl : ConeIntegerLiteralType {\n     }\n \n     override fun getApproximatedType(expectedType: ConeKotlinType?): ConeClassLikeType {\n-        val approximatedType = when (expectedType) {\n+        val expectedTypeForApproximation = if (expectedType is ConeFlexibleType) {\n+            expectedType.lowerBound\n+        } else expectedType", "msg": "You may use expectedType.lowerBoundIfFlexible()"}
{"patch": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.inspections.collections\n+\n+import com.intellij.codeInspection.LocalQuickFix\n+import com.intellij.codeInspection.ProblemDescriptor\n+import com.intellij.openapi.project.Project\n+import org.jetbrains.kotlin.idea.KotlinBundle\n+import org.jetbrains.kotlin.psi.KtPsiFactory\n+import org.jetbrains.kotlin.psi.KtQualifiedExpression\n+import org.jetbrains.kotlin.psi.createExpressionByPattern\n+\n+class ReplaceUselessCallWithToListFix : LocalQuickFix {", "msg": "I'd generalize this quick fix and call it `ReplaceSelectorOfQualifiedExpressionFix` and put it to `org.jetbrains.kotlin.idea.quickfix` package. Then first line of class would look like:\r\n```\r\nclass ReplaceSelectorOfQualifiedExpressionFix(val newSelector: String) : LocalQuickFix\r\n```\r\nI think you get the idea"}
{"patch": "@@ -77,7 +78,7 @@ class UselessCallOnCollectionInspection : AbstractUselessCallInspection() {\n                 KotlinBundle.message(\"useless.call.on.collection.type\"),\n                 ProblemHighlightType.LIKE_UNUSED_SYMBOL,\n                 isOnTheFly,\n-                RemoveUselessCallFix()\n+                if (KotlinBuiltIns.isArray(receiverType)) ReplaceUselessCallWithToListFix() else RemoveUselessCallFix()", "msg": "That's wrong logic. You should use `ReplaceUselessCallWithToListFix` in case when type of whole expression is `List` and when receiver type isn't `List` at the same time. E.g. consider such example:\r\n```\r\nval arr: List<Int> = setOf(1, 2, 3).filterNotNull()\r\n```\r\nYour quick fix will remove `filterNotNull` but it's expected to be replaced with `toList` just like with `arrayOf`"}
{"patch": "@@ -68,6 +71,11 @@ class UselessCallOnCollectionInspection : AbstractUselessCallInspection() {\n             )\n             holder.registerProblem(descriptor)\n         } else {\n+            val fix = if (receiverType.constructor.declarationDescriptor?.fqNameSafe == KotlinBuiltIns.FQ_NAMES.list) {", "msg": "You need to check for both conditions. You should replace selector with `toList()` when `whole exp` == `List` && `receiver` != `List`. Now you only check for `receiver` != `List`. So your code doesn't work for `sequenceOf` (because whole expression has type Sequence, not List):\r\n```\r\nval arr: Sequence<Int> = sequenceOf(1, 2, 3).filterNotNull()\r\n```\r\nYes, we don't yet have \"Useless call\" check for sequences but your code will broke when we add it.\r\n\r\nSo I suggest to invert your if for improving readability and add full check."}
{"patch": "@@ -49,7 +49,7 @@ import org.jetbrains.org.objectweb.asm.*\n import java.lang.annotation.RetentionPolicy\n \n abstract class AnnotationCodegen(\n-    private val innerClassConsumer: InnerClassConsumer,\n+    private val innerClassConsumer: ClassCodegen,", "msg": "Maybe rename it to `classCodegen` then?"}
{"patch": "@@ -40,8 +40,7 @@ fun getPropertiesToUseInGeneratedMember(classOrObject: KtClassOrObject): List<Kt\n         classOrObject.declarations.asSequence().filterIsInstance<KtProperty>().filterTo(this) {\n             val descriptor = it.unsafeResolveToDescriptor()\n             when (descriptor) {\n-                is ValueParameterDescriptor -> true\n-                is PropertyDescriptor -> descriptor.getter?.isDefault ?: true\n+                is ValueParameterDescriptor, is PropertyDescriptor -> true", "msg": "This done intentionally. User custom getter may contain complex computations or side effects. It's not safe to suggest custom getters in toString/hashCode default generator.\r\n\r\nYou can suggest pull request where custom getters are suggested but are disabled by default in this dialog:\r\n![image](https://user-images.githubusercontent.com/20517828/82453716-8b01ce00-9ab9-11ea-965a-1ca70f0ff93e.png)\r\n "}
{"patch": "@@ -47,18 +49,26 @@ fun PsiElement.getLineCount(): Int {\n     if (doc != null) {\n         val spaceRange = textRange ?: TextRange.EMPTY_RANGE\n \n-        if (spaceRange.endOffset <= doc.textLength) {\n+        if (spaceRange.endOffset <= doc.textLength && spaceRange.startOffset < spaceRange.endOffset) {\n             val startLine = doc.getLineNumber(spaceRange.startOffset)\n             val endLine = doc.getLineNumber(spaceRange.endOffset)", "msg": "BTW, `getLineNumber` JavaDoc is incorrect. It accepts ints from range [0, textLength]. I fixed JavaDoc in community: https://github.com/JetBrains/intellij-community/commit/9e4198f84cdbd3f67f6a8fb94bb3f46a4e9dbb45"}
{"patch": "@@ -47,42 +66,96 @@ class SwitchGenerator(private val expression: IrWhen, private val data: BlockInf\n         if (!areConstComparisons(calls))\n             return null\n \n-        // Subject should be the same for all conditions. Let's pick the first.\n-        val subject = callToLabels[0].call.getValueArgument(0)!! as IrGetValue\n+        return when {\n+            areConstUIntComparisons(calls) -> {\n+                val subject = callToLabels[0].call.getValueArgumentThroughCoercion(0)!!.asThroughCoercion<IrGetValue>()", "msg": "It would help to describe what the expected IR looks like for the call."}
{"patch": "@@ -220,13 +220,21 @@ open class ConvertLambdaToReferenceIntention(textGetter: () -> String) : SelfTar\n \n     companion object {\n         private fun KtLambdaExpression.lambdaParameterType(context: BindingContext? = null): KotlinType? {\n-            val argument = parent as? KtValueArgument ?: return null\n+            val argument = parentValueArgument() ?: return null\n             val callExpression = argument.getStrictParentOfType<KtCallExpression>() ?: return null\n             return callExpression\n                 .getResolvedCall(context ?: analyze(BodyResolveMode.PARTIAL))\n                 ?.getParameterForArgument(argument)?.type\n         }\n \n+        private fun KtLambdaExpression.parentValueArgument(): KtValueArgument? {", "msg": "There's an existing `unwrapIfLabeled()` utility function for this:\r\nhttps://github.com/JetBrains/kotlin/blob/master/idea/src/org/jetbrains/kotlin/idea/intentions/loopToCallChain/commonUtils.kt#L151"}
{"patch": "@@ -227,9 +229,16 @@ class TowerResolver {\n             }\n \n             // extension for implicit receiver\n-            for (nonLocalLevel in nonLocalLevels) {\n-                TowerData.BothTowerLevelAndImplicitReceiver(nonLocalLevel, implicitReceiver).process()?.let { return it }\n-            }\n+            val receiverValue = implicitReceiver.receiverValue\n+            val resolveExtensions = receiverValue !is ImplicitClassReceiver ||", "msg": "The intentions will look much cleaner if you'll reverse the flag meaning, i.e. name it `skipResolveExtensions` and rewrite the code accordingly."}
{"patch": "@@ -138,7 +138,7 @@ class CodeConformanceTest : TestCase() {\n         for (sourceFile in FileUtil.findFilesByMask(SOURCES_BUNCH_FILE_PATTERN, root)) {\n             if (EXCLUDED_FILES_AND_DIRS.any { FileUtil.isAncestor(it, sourceFile, false) }) continue\n \n-            val matches = Regex(\"BUNCH (\\\\w+)\").findAll(sourceFile.readText())\n+            val matches = Regex(\"\"\"BUNCH (\\d+)\"\"\").findAll(sourceFile.readText())", "msg": "Actually it can be even better: \"\"\"BUNCH (\\d\\d\\d)\"\"\". But for some reason I left older behavior"}
{"patch": "@@ -45,6 +46,7 @@ interface SourceCode {\n      */\n     data class Range(val start: Position, val end: Position) : Serializable\n \n+    // TODO: Consider adding an extra property that refers to the file. i.e. locationId", "msg": "I would add this to the same change, you know how difficult it is to change the API with a data class"}
{"patch": "@@ -135,6 +135,27 @@ open class LazyClassMemberScope(\n     override fun getVariableNames() = _variableNames\n     override fun getFunctionNames() = _functionNames\n \n+    override fun definitelyDoesNotContainName(name: Name): Boolean {\n+        if (getVariableNames().contains(name) || getFunctionNames().contains(name))\n+            return false\n+\n+        with(c.syntheticResolveExtension) {\n+            if (getSyntheticCompanionObjectNameIfNeeded(thisDescriptor) == name)\n+                return false\n+            if (getSyntheticFunctionNames(thisDescriptor).contains(name))\n+                return false\n+            if (getSyntheticNestedClassNames(thisDescriptor).contains(name))", "msg": "Also, I'm concerned we don't handle usual nested classifiers' names here"}
{"patch": "@@ -47,18 +49,26 @@ fun PsiElement.getLineCount(): Int {\n     if (doc != null) {\n         val spaceRange = textRange ?: TextRange.EMPTY_RANGE\n \n-        if (spaceRange.endOffset <= doc.textLength) {\n+        if (spaceRange.endOffset <= doc.textLength && spaceRange.startOffset < spaceRange.endOffset) {\n             val startLine = doc.getLineNumber(spaceRange.startOffset)\n             val endLine = doc.getLineNumber(spaceRange.endOffset)\n \n-            return endLine - startLine\n+            return endLine - startLine + 1\n         }\n     }\n \n     return (text ?: \"\").count { it == '\\n' } + 1\n }\n \n-fun PsiElement.isMultiLine(): Boolean = getLineCount() > 1\n+fun PsiElement.isMultiLine(): ThreeState {\n+    val i = getLineCount().takeIf { it >= 0 } ?: return ThreeState.UNSURE\n+    return ThreeState.fromBoolean(i > 1)\n+}\n+\n+fun PsiElement.isOneLiner(): ThreeState {", "msg": "Same as above"}
{"patch": "@@ -21,9 +21,21 @@ interface MessageCollector {\n \n     fun report(severity: CompilerMessageSeverity, message: String, location: CompilerMessageLocation? = null)\n \n+    fun reportExt(severity: CompilerMessageSeverity, message: String, location: CompilerMessageExtendedLocation? = null) {", "msg": "I do not like `...Ext` naming - remind me of bad MS APIs habits. I'd rather use `@JvmName` to resolve java ambiguity`."}
{"patch": "@@ -50,6 +51,37 @@ class ScriptDiagnosticsMessageCollector(private val parentMessageCollector: Mess\n     }\n }\n \n+class ScriptDiagnosticsMessageExtendedCollector(parentMessageCollector: MessageCollector?) :", "msg": "`Extended` part of the name sounds weird to me. It seems that there is no good reason to have a separate \"extended\" variant, and you can simply add this functionality to the `ScriptDiagnosticsMessageCollector`."}
{"patch": "@@ -71,6 +71,19 @@ inline fun <T> withMessageCollector(\n     }\n }\n \n+inline fun <T> withMessageExtendedCollector(", "msg": "And here too, it seems that we don't need non-extended variant in scripting, so you can just update the `withMessageCollector` function instead."}
{"patch": "@@ -76,6 +76,17 @@ public fun <K, V> Map<out K, V>.toSortedMap(comparator: Comparator<in K>): Sorte\n public fun <K : Comparable<K>, V> sortedMapOf(vararg pairs: Pair<K, V>): SortedMap<K, V> =\n     TreeMap<K, V>().apply { putAll(pairs) }\n \n+/**\n+ * Returns a new [SortedMap] with the specified contents, given as a list of pairs\n+ * where the first value is the key and the second is the value.\n+ *\n+ * The resulting [SortedMap] determines the equality and order of keys according to the sorting order provided by the given [comparator].\n+ *\n+ * @sample samples.collections.Maps.Instantiation.sortedMapWithComparatorFromPairs\n+ */\n+public fun <K, V> sortedMapOf(comparator: Comparator<in K>, vararg pairs: Pair<K, V>): SortedMap<K, V> =", "msg": "Needs to be annotated with `@SinceKotlin(\"1.4\")`"}
{"patch": "@@ -139,7 +139,7 @@ abstract class KotlinLibrarySearchPathResolver<L : KotlinLibrary>(\n             val matching = fileSequence\n                 .filterOutPre_1_4_libraries()\n                 .flatMap { libraryComponentBuilder(it, isDefaultLink).asSequence() }\n-                .map { it.takeIf { libraryMatch(it, unresolved) } }\n+                //.map { it.takeIf { libraryMatch(it, unresolved) } }", "msg": "I need atomicfu klib as the compile dependency for the plugin tests. This dependency is provided in the [atomicfuClasspath](https://github.com/JetBrains/kotlin/blob/19610be7c35dcf39b3db4a076bad6891c30fc043/plugins/atomicfu/atomicfu-compiler/build.gradle.kts#L48) - the atomicfu-js version `0.14.3-1.4-M1`, that is built with `1.4-M1`. The problem here is that kotlin abi version  of this dependency is 1.4.0 while the CURRENT KotlinAbiVersion is 1.4.1, so here I get mismatch and the dependency is not used.\r\n\r\nHow is the abi version provided for the library?"}
{"patch": "@@ -43,6 +43,13 @@ class Maps {\n             assertPrints(map.values, \"[2, 3, 1]\")\n         }\n \n+        @Sample\n+        fun sortedMapWithComparatorFromPairs() {\n+            val map = sortedMapOf(compareBy<String> { it.length }.thenBy { it }, Pair(\"abc\", 1), Pair(\"c\", 3), Pair(\"bd\", 4), Pair(\"bc\", 2))\n+            assertPrints(map.keys, \"[c, bc, bd, abc]\")\n+            assertPrints(map.values, \"[c, bc, bd, abc]\")", "msg": "`values` collection should contain integers"}
{"patch": "@@ -0,0 +1,14 @@\n+fun foo(vararg args: String): String? = null\n+\n+fun test(): Int {", "msg": "It seems that here we have wrong test data with redundant tab's.\r\nThis test is not green.\r\nMaybe it is machine specific behavior that align test results in different ways from yours:\r\n```\r\ncom.intellij.rt.execution.junit.FileComparisonFailure: Actual data differs from file content: \r\nMultiLineInitializer.kt.after expected:<... foo = foo(\r\n        [    \"1111111111\",\r\n            \"2222222222\",\r\n            \"3333333333\",\r\n            \"4444444444\",\r\n    ]        \"5555555555\"...> but was:<... foo = foo(\r\n        [\"1111111111\",\r\n        \"2222222222\",\r\n        \"3333333333\",\r\n        \"4444444444\",\r\n]        \"5555555555\"...>\r\n```"}
{"patch": "@@ -199,8 +198,8 @@ class FirElementSerializer private constructor(\n         var hasGetter = false\n         var hasSetter = false\n \n-        //val compileTimeConstant = property.compileTimeInitializer", "msg": "@mglukhikh It looks like FE 1.0 actually has a field in property descriptor and initializes it during field value resolution if the property has a constant. I think I found a counter part in `fir`, but I'm not sure we want to add `compileTimeInitializer` (of `ConstantValue` type perhaps) to `FirProperty` or just determining whether it has constant or not during serialization like this. "}
{"patch": "@@ -126,6 +128,37 @@ open class LazyClassMemberScope(\n                 }\n             }\n \n+    private val _classifierNames: Set<Name>?\n+            by lazy(LazyThreadSafetyMode.PUBLICATION) {\n+                mutableSetOf<Name>().run {\n+                    supertypes.flatMapToNullable(this) {\n+                        it.memberScope.getClassifierNames()\n+                    } ?: return@run null\n+\n+                    addAll(declarationProvider.getDeclarationNames())\n+                    addSyntheticClassifiers()\n+\n+                    this\n+                }\n+            }\n+\n+    private val _allKnownNames: Set<Name>", "msg": "This whole set should be nullable in case it's impossible to compute classifiers names"}
{"patch": "@@ -126,6 +128,37 @@ open class LazyClassMemberScope(\n                 }\n             }\n \n+    private val _classifierNames: Set<Name>?\n+            by lazy(LazyThreadSafetyMode.PUBLICATION) {\n+                mutableSetOf<Name>().run {\n+                    supertypes.flatMapToNullable(this) {\n+                        it.memberScope.getClassifierNames()\n+                    } ?: return@run null\n+\n+                    addAll(declarationProvider.getDeclarationNames())\n+                    addSyntheticClassifiers()\n+\n+                    this\n+                }\n+            }\n+\n+    private val _allKnownNames: Set<Name>\n+            by lazy(LazyThreadSafetyMode.PUBLICATION) {\n+                mutableSetOf<Name>().apply {\n+                    addAll(declarationProvider.getDeclarationNames())", "msg": "You may just use `getClassifierNames()`"}
{"patch": "@@ -126,6 +128,37 @@ open class LazyClassMemberScope(\n                 }\n             }\n \n+    private val _classifierNames: Set<Name>?\n+            by lazy(LazyThreadSafetyMode.PUBLICATION) {\n+                mutableSetOf<Name>().run {\n+                    supertypes.flatMapToNullable(this) {\n+                        it.memberScope.getClassifierNames()\n+                    } ?: return@run null\n+\n+                    addAll(declarationProvider.getDeclarationNames())\n+                    addSyntheticClassifiers()\n+\n+                    this\n+                }\n+            }\n+\n+    private val _allKnownNames: Set<Name>\n+            by lazy(LazyThreadSafetyMode.PUBLICATION) {\n+                mutableSetOf<Name>().apply {\n+                    addAll(declarationProvider.getDeclarationNames())\n+                    addAll(getVariableNames())\n+                    addAll(getFunctionNames())\n+                    getClassifierNames()?.also { addAll(it) } ?: addSyntheticClassifiers()", "msg": "And here `addSyntheticClassifiers()` is not necessary: `getClassifierNames()` is either possible to compute or all other parts are meaningless"}
{"patch": "@@ -134,6 +167,20 @@ open class LazyClassMemberScope(\n \n     override fun getVariableNames() = _variableNames\n     override fun getFunctionNames() = _functionNames\n+    override fun getClassifierNames() = _classifierNames\n+\n+    override fun definitelyDoesNotContainName(name: Name): Boolean {\n+        if (name in _allKnownNames) {\n+            return false\n+        }\n+\n+        if (thisDescriptor.isData && name.identifier.matches(DATA_CLASS_COMPONENT_REGEX)) {", "msg": "BTW, as far as I can see `getFunctionNames` already contains data-class-related `componentN` functions"}
{"patch": "@@ -84,6 +84,19 @@ val ScriptCompilationConfigurationKeys.filePathPattern by PropertiesCollection.k\n  */\n val ScriptCompilationConfigurationKeys.baseClass by PropertiesCollection.key<KotlinType>(KotlinType(Any::class)) // script base class\n \n+/**", "msg": "These two options look as quite scary implementation details, so I'd move it to some other place. Or maybe redesigned the way how we control it in general. Let's discuss it offline."}
{"patch": "@@ -136,6 +136,11 @@ class Fir2IrClassifierStorage(\n         }\n     }\n \n+    internal fun findFirClass(irClass: IrClass): FirClass<*>? {", "msg": "This is very nasty function, I recommend to get rid of it"}
{"patch": "@@ -95,14 +95,21 @@ class Fir2IrConverter(\n         return irClass\n     }\n \n+    // Sort declarations so that all non-synthetic declarations are before synthetic ones.\n+    // This is needed because converting synthetic fields for implementation delegation needs to know\n+    // existing declarations in the class to avoid adding redundant delegated members.\n+    private fun putSyntheticLast(declarations: List<FirDeclaration>) : Iterable<FirDeclaration> {", "msg": "I don't like name, `put` is associated with adding something into container. Consider something like `deprioritizeSynthetics` or `sortedBySynthetic`"}
{"patch": "@@ -136,6 +144,13 @@ interface SyntheticResolveExtension {\n \n     fun getSyntheticNestedClassNames(thisDescriptor: ClassDescriptor): List<Name> = emptyList()\n \n+    /**\n+     * This method should return either superset of what [getSyntheticNestedClassNames] returns,\n+     * or null in case it needs to run resolution and inference and/or it is very costly.\n+     * Override this method if resolution started to fail with recursion.\n+     */\n+    fun maybeGetSyntheticNestedClassNames(thisDescriptor: ClassDescriptor): List<Name>? = getSyntheticNestedClassNames(thisDescriptor)", "msg": "imo, `getPossibleSyntheticNestedClassNames` is a slightly better name for this method"}
{"patch": "@@ -61,6 +61,7 @@ class RemoveRedundantQualifierNameInspection : AbstractKotlinInspection(), Clean\n                 val expressionParent = expression.parent\n                 if (expressionParent is KtDotQualifiedExpression || expressionParent is KtPackageDirective || expressionParent is KtImportDirective) return\n                 val expressionForAnalyze = expression.firstExpressionWithoutReceiver() ?: return\n+                if (expressionForAnalyze.selectorExpression?.text == expressionParent.safeAs<KtProperty>()?.name) return", "msg": "This doesn't work for code:\r\n```kotlin\r\nsealed class Foo {\r\n    object BAR : Foo()\r\n\r\n    companion object {\r\n        val BAR: Foo by lazy { Foo.BAR }\r\n    }\r\n}\r\n```"}
{"patch": "@@ -80,7 +84,11 @@ open class ConvertLambdaToReferenceIntention(textGetter: () -> String) : SelfTar\n \n         val lambdaParameterIsSuspend = lambdaParameterType?.isSuspendFunctionType == true\n         val calleeFunctionIsSuspend = (calleeDescriptor as? FunctionDescriptor)?.isSuspend == true\n-        if (lambdaParameterIsSuspend && !calleeFunctionIsSuspend || !lambdaParameterIsSuspend && calleeFunctionIsSuspend) return false\n+        if (languageVersion >= LanguageVersion.KOTLIN_1_4) {\n+            if (!lambdaParameterIsSuspend && calleeFunctionIsSuspend) return false\n+        } else {\n+            if (lambdaParameterIsSuspend && !calleeFunctionIsSuspend || !lambdaParameterIsSuspend && calleeFunctionIsSuspend) return false\n+        }", "msg": "This is not the correct check, since this feature (passing reference to non-suspend method as suspend function parameter) can be enabled and disabled independently from the language version. You probably should rewrite the code like this:\r\n\r\n```suggestion\r\n        if (!lambdaParameterIsSuspend && calleeFunctionIsSuspend) return false\r\n        if (!languageVersionSettings.supportsFeature(LanguageFeature.SuspendConversion)) {\r\n            if (lambdaParameterIsSuspend && !calleeFunctionIsSuspend) return false\r\n        }\r\n```"}
{"patch": "@@ -137,6 +151,7 @@ open class ConvertLambdaToReferenceIntention(textGetter: () -> String) : SelfTar\n             if (lambdaValueParameterDescriptors.size < explicitReceiverShift + callableExpression.valueArguments.size) return false\n             val resolvedCall = callableExpression.getResolvedCall(context) ?: return false\n             resolvedCall.valueArguments.entries.forEach { (valueParameter, resolvedArgument) ->\n+                if (resolvedArgument is DefaultValueArgument && languageVersion >= LanguageVersion.KOTLIN_1_4) return@forEach", "msg": "This too should be replaced with the `LanguageFeature.FunctionReferenceWithDefaultValueAsOtherType` flag check. I would advise to extract the flag check to some variable and reuse it twice"}
{"patch": "@@ -0,0 +1,7 @@\n+fun foo(a: suspend () -> Unit) {}", "msg": "By default this conversion will lead to red code, because currently it is disabled\r\n\r\nPlease enable it with this\r\n\r\n```suggestion\r\n// COMPILER_ARGUMENTS: -XXLanguage:+SuspendConversion\r\nfun foo(a: suspend () -> Unit) {}\r\n```"}
{"patch": "@@ -31,6 +35,16 @@ class RemoveRedundantSpreadOperatorInspection : AbstractKotlinInspection() {\n                 when (argumentExpression) {\n                     is KtCallExpression -> {\n                         if (!argumentExpression.isArrayOfMethod()) return\n+                        if (argumentExpression.valueArguments.isEmpty()) {\n+                            val call = argument.getStrictParentOfType<KtCallExpression>()\n+                            if (call != null) {\n+                                val index = call.valueArguments.indexOfFirst { it == argument }\n+                                val newCall = call.copy() as KtCallExpression\n+                                newCall.valueArgumentList?.removeArgument(index)\n+                                val newContext = newCall.analyzeAsReplacement(call, call.analyze(BodyResolveMode.PARTIAL))\n+                                if (newCall.getResolvedCall(newContext)?.resultingDescriptor == null) return", "msg": "This check doesn't work for:\r\n```kotlin\r\nfun foo(vararg args: Int) = println(1)\r\nfun foo() = println(2)\r\nfun test() {\r\n    foo(*intArrayOf())\r\n} \r\n```\r\nI think you should compare result descriptor with previous value."}
{"patch": "@@ -845,19 +864,6 @@ class ExpressionCodegen(\n         }\n     }\n \n-    private fun IrExpression.markEndOfStatementIfNeeded() {", "msg": "These generate line numbers for the closing brace of `when`, `try`, `if`. However, this does not ensure that there is an instruction for that line number. Therefore, these line numbers will be there in the line number table, but will often not have instructions and can therefore not be observed. With the old backend, these are also emitted and typically cannot be observed. I opted for removing them entirely as I do not find it useful to be able to step and set breakpoints on the closing brace. The alternative is to go the other way and always emit a `nop` so that you will always get a step here (and the posibility of setting a breakpoint)."}
{"patch": "@@ -44,7 +44,7 @@ internal open class AbstractKotlinCompileArgumentsContributor<T : CommonCompiler\n \n     protected val logger by taskProvider.map { it.logger }\n \n-    private val isMultiplatform by taskProvider.map { it.isMultiplatform }\n+    private val isMultiplatform = taskProvider.map { it.isMultiplatform }.get()", "msg": "\ud83d\udc84 Don't `.get()` the provider for uniformity with the other fields in this class"}
{"patch": "@@ -69,6 +69,9 @@ open class KaptGenerateStubsTask : KotlinCompile() {\n             error(\"KaptGenerateStubsTask.useModuleDetection setter should not be called!\")\n         }\n \n+    @get:Input\n+    val verbose = (project.hasProperty(\"kapt.verbose\") && project.property(\"kapt.verbose\").toString().toBoolean() == true)", "msg": ":o: This could be modelled as a `Provider` to account for later changes to that property:\r\n\r\n```kotlin\r\nproject.providers.gradleProperty(\"kapt.verbose\").map { it.toBoolean() }.orElse(false)\r\n```"}
{"patch": "@@ -44,10 +45,9 @@ open class KotlinWithJavaTarget<KotlinOptionsType : KotlinCommonOptions>(\n             KotlinWithJavaCompilationFactory(project, this, kotlinOptionsFactory)\n         )\n \n-    internal val defaultArtifactClassesListFile: File\n-        get() {\n+    internal val defaultArtifactClassesListFile: Provider<File> = project.provider {\n             val jarTask = project.tasks.getByName(artifactsTaskName) as Jar\n-            return File(File(project.buildDir, KOTLIN_BUILD_DIR_NAME), \"${sanitizeFileName(jarTask.archiveFileName.get())}-classes.txt\")\n+            File(File(project.buildDir, KOTLIN_BUILD_DIR_NAME), \"${sanitizeFileName(jarTask.archiveFileName.get())}-classes.txt\")\n         }", "msg": "\u2753 I'm not sure where this `val` is wired, but the above code is losing task dependency and reference to `jar.archiveFileName` and could cause ordering problems.\r\n\r\nAnother way to write this would be:\r\n\r\n```kotlin\r\nproject.tasks.named(\"artifactsTaskName\", Jar::class).flatMap { jar ->\r\n    project.layout.buildDirectory.file(\"$KOTLIN_BUILD_DIR_NAME/${sanitizeFileName(jar.archiveFileName.get())}-classes.txt\")\r\n}\r\n```\r\nThis would return a `Provider<RegularFile>`. If you need it to be a `Provider<File>` just chain with `.map { it.asFile }`\r\n\r\nAgain, I'm not sure where this gets used and if my comment is relevant."}
{"patch": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.gradle\n+\n+import org.jetbrains.kotlin.gradle.util.AGPVersion\n+import org.jetbrains.kotlin.gradle.util.findFileByName\n+import org.jetbrains.kotlin.test.KotlinTestUtils\n+import org.junit.Test\n+import java.io.File\n+import java.net.URI\n+import kotlin.test.fail\n+\n+class ConfigurationCacheForAndroidIT : BaseGradleIT() {\n+    private val androidGradlePluginVersion: AGPVersion\n+        get() = AGPVersion.v4_1_0", "msg": "I recommend using latest AGP 4.2 alphas, as those has more configuration caching issues fixed."}
{"patch": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.gradle.plugin\n+\n+import org.gradle.tooling.events.FinishEvent\n+import org.gradle.tooling.events.OperationCompletionListener\n+\n+//Available since Gradle 6.1\n+class KotlinGradleBuildListener(", "msg": "This can be a `BuildService` and if you make it `AutoCloseable` you can implement clean-up logic in `close()` method."}
{"patch": "@@ -72,57 +103,11 @@ internal class KotlinGradleBuildServices private constructor(\n     }\n \n     override fun buildFinished(result: BuildResult) {", "msg": "It looks like configuration cached runs still rely on this method being invoked (please correct me if I'm wrong). If you'd like to be notified when build finished, build services provide you with such lifecycle (see my comment on `KotlinGradleBuildListener`)."}
{"patch": "@@ -23,9 +23,13 @@ import java.util.zip.ZipOutputStream\n import javax.xml.parsers.DocumentBuilderFactory\n \n internal sealed class MetadataDependencyResolution(\n+    @field:Transient // can't be used with Gradle Instant Execution, but fortunately not needed when deserialized\n     val dependency: ResolvedComponentResult,\n     val projectDependency: Project?", "msg": "Project is not serializable either, so probably needs `@Transient` as well."}
{"patch": "@@ -15,22 +15,28 @@ import org.jetbrains.kotlin.gradle.plugin.sources.KotlinDependencyScope.*\n import org.jetbrains.kotlin.gradle.plugin.sources.getSourceSetHierarchy\n import org.jetbrains.kotlin.gradle.targets.metadata.ALL_COMPILE_METADATA_CONFIGURATION_NAME\n import org.jetbrains.kotlin.gradle.targets.metadata.KotlinMetadataTargetConfigurator\n+import org.jetbrains.kotlin.gradle.utils.getValue\n import java.io.File\n import javax.inject.Inject\n \n open class TransformKotlinGranularMetadata\n @Inject constructor(\n     @get:Internal\n+    @field:Transient\n     val kotlinSourceSet: KotlinSourceSet\n ) : DefaultTask() {\n \n     @get:OutputDirectory\n-    val outputsDir: File = project.buildDir.resolve(\"kotlinSourceSetMetadata/${kotlinSourceSet.name}\")\n+    val outputsDir: File by project.provider {\n+        project.buildDir.resolve(\"kotlinSourceSetMetadata/${kotlinSourceSet.name}\")", "msg": "Use `ProjectLayout` methods to compute this. E.g. this will not detect changes if buildDir changes."}
{"patch": "@@ -88,12 +89,14 @@ abstract class AbstractKotlinNativeTargetPreset<T : KotlinNativeTarget>(\n \n         createTargetConfigurator().configureTarget(result)\n \n-        SingleActionPerProject.run(project, \"setUpKotlinNativePlatformDependencies\") {\n-            project.gradle.addListener(object : BuildAdapter() {\n-                override fun projectsEvaluated(gradle: Gradle) {\n-                    project.setUpKotlinNativePlatformDependencies()\n-                }\n-            })\n+        if (!isConfigurationCacheAvailable(project.gradle)) {\n+            SingleActionPerProject.run(project, \"setUpKotlinNativePlatformDependencies\") {\n+                project.gradle.addListener(object : BuildAdapter() {", "msg": "You can't use `gradle.addListener(BuildListener)` but in that case you only need to react to `projectsEvaluated` and that can be done using `gradle.projectsEvaluated(action)`."}
{"patch": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */", "msg": "wrong commit"}
{"patch": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */", "msg": "wrong commit"}
{"patch": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */", "msg": "The approach here looks strange to me, especially in the lack of the usages to chack the intentions. Let's discuss it online."}
{"patch": "@@ -1,4 +1,5 @@\n // TARGET_BACKEND: JVM\n+// IGNORE_BACKEND_FIR: JVM_IR", "msg": "I'm not sure why this test was passing. The generated IR is not correct, e.g., the fake override for `IntervalTreeMap.get` takes an argument of type `Any?` instead of `String`."}
{"patch": "@@ -164,7 +164,9 @@ abstract class AbstractIrTextTestCase : AbstractIrGeneratorTestCase() {\n             private val elements = HashSet<IrElement>()\n \n             override fun visitElement(element: IrElement) {\n-                require(elements.add(element)) { \"Non-unique element: ${element.render()}\" }\n+                require(elements.add(element) || element is IrConst<*>) {", "msg": "I've tracked down where this was added, and it's for checking if there is a duplicate array access (represented as `IrGetVariable`). I strongly believe having same const should not matter. Actually, \"constant canonicalization\" (so that the local function can avoid loading the same constants again) is well-known optimization."}
{"patch": "@@ -56,4 +57,12 @@ internal data class ParsedGradleVersion(val major: Int, val minor: Int) : Compar\n \n fun isGradleVersionAtLeast(major: Int, minor: Int) =\n     ParsedGradleVersion.parse(GradleVersion.current().version)\n-        ?.let { it >= ParsedGradleVersion(major, minor) } ?: false\n\\ No newline at end of file\n+        ?.let { it >= ParsedGradleVersion(major, minor) } ?: false\n+\n+fun isConfigurationCacheAvailable(gradle: Gradle) =\n+    try {\n+        val startParameters = gradle.startParameter\n+        startParameters.javaClass.getMethod(\"isConfigurationCache\").invoke(startParameters) as? Boolean", "msg": ":x: that check is using reflection on internal API and exceptions for control flow and doesn't cache the result. This could have a bad effect on performance."}
{"patch": "@@ -653,12 +653,12 @@ class RawFirBuilder(\n                     isExpect = containingClassOrObject?.hasExpectModifier() == true\n                 }\n                 symbol = FirVariableSymbol(callableIdForName(nameAsSafeName))\n-                // NB: not sure should annotations be on enum entry itself, or on its corresponding object", "msg": "Well, actually annotations should be on \"both\" places. :)\r\n\r\nAn example IR dump for the unmuted test (with old FE):\r\n```\r\n  CLASS ENUM_CLASS name:E modality:OPEN visibility:public superTypes:[kotlin.Enum<<root>.E>]\r\n    $this: VALUE_PARAMETER INSTANCE_RECEIVER name:<this> type:<root>.E\r\n    CONSTRUCTOR visibility:private <> () returnType:<root>.E [primary]\r\n      BLOCK_BODY\r\n        ENUM_CONSTRUCTOR_CALL 'public constructor <init> (name: kotlin.String, ordinal: kotlin.Int) [primary] declared in kotlin.Enum'\r\n          <E>: <root>.E\r\n        INSTANCE_INITIALIZER_CALL classDescriptor='CLASS ENUM_CLASS name:E modality:OPEN visibility:public superTypes:[kotlin.Enum<<root>.E>]'\r\n    ENUM_ENTRY name:E1\r\n      annotations:\r\n        First\r\n      init: EXPRESSION_BODY\r\n        ENUM_CONSTRUCTOR_CALL 'private constructor <init> () [primary] declared in <root>.E.E1'\r\n      class: CLASS ENUM_ENTRY name:E1 modality:FINAL visibility:private superTypes:[<root>.E]\r\n        annotations:\r\n          First\r\n        $this: VALUE_PARAMETER INSTANCE_RECEIVER name:<this> type:<root>.E.E1\r\n        CONSTRUCTOR visibility:private <> () returnType:<root>.E.E1 [primary]\r\n        \r\n    ENUM_ENTRY name:E2\r\n      annotations:\r\n        Second(value = 'OK')\r\n      init: EXPRESSION_BODY\r\n        ENUM_CONSTRUCTOR_CALL 'private constructor <init> () [primary] declared in <root>.E'\r\n\r\n    ...\r\n```"}
{"patch": "@@ -72,14 +82,15 @@ class InstantExecutionIT : BaseGradleIT() {\n         }\n \n         // Then run a build where tasks states are deserialized to check that they work correctly in this mode\n-        instantExecutionOf(*taskNames, buildOptions = buildOptions) {\n+        build(*taskNames, options = buildOptions) {\n             assertSuccessful()\n-            assertTasksExecuted(*taskNames)\n+            assertTasksExecuted(executedTask)\n+            assertContains(\"Reusing configuration cache.\")\n         }\n \n-        instantExecutionOf(*taskNames, buildOptions = buildOptions) {\n+        build(*taskNames, options = buildOptions) {\n             assertSuccessful()\n-            assertTasksUpToDate(*taskNames)\n+            assertTasksUpToDate(executedTask)", "msg": ":o: Asserting that the configuration cache is reused again wouldn't harm\r\n```suggestion\r\n            assertTasksUpToDate(executedTask)\r\n            assertContains(\"Reusing configuration cache.\")\r\n```"}
{"patch": "@@ -112,8 +116,8 @@ class InstantExecutionIT : BaseGradleIT() {\n      * found while caching the task graph.\n      */\n     private fun Project.instantExecutionReportFile() = projectDir\n-        .resolve(\".instant-execution-state\")\n-        .findFileByName(\"instant-execution-report.html\")\n+        .resolve(\"configuration-cache\")", "msg": "\u274c This path is still wrong. See my comments in the other PR at https://github.com/JetBrains/kotlin/pull/3521/files#r449659042\r\n\r\n\u2753 Is this function still used? With its current implementation it will always return `null` anyway"}
{"patch": "@@ -50,9 +51,21 @@ const val COULD_NOT_CONNECT_TO_DAEMON_MESSAGE = \"Could not connect to Kotlin com\n internal fun kotlinCompilerExecutionStrategy(): String =\n     System.getProperty(KOTLIN_COMPILER_EXECUTION_STRATEGY_PROPERTY) ?: DAEMON_EXECUTION_STRATEGY\n \n-internal open class GradleCompilerRunner(protected val task: Task) {\n-    protected val project: Project\n-        get() = task.project\n+/*\n+Using real taskProvider cause \"field 'taskProvider' from type 'org.jetbrains.kotlin.compilerRunner.GradleCompilerRunner':\n+value 'fixed(class org.jetbrains.kotlin.gradle.tasks.KotlinCompile_Decorated, task ':compileKotlin')'\n+is not assignable to 'org.gradle.api.tasks.TaskProvider'\" exception", "msg": "\ud83d\udc84 This comment isn't necessary I think. See comments in the previous PR at https://github.com/JetBrains/kotlin/pull/3521/files#r450239208"}
{"patch": "@@ -69,6 +69,9 @@ open class KaptGenerateStubsTask : KotlinCompile() {\n             error(\"KaptGenerateStubsTask.useModuleDetection setter should not be called!\")\n         }\n \n+    @get:Input\n+    val verbose = (project.hasProperty(\"kapt.verbose\") && project.property(\"kapt.verbose\").toString().toBoolean() == true)", "msg": ":o: This could be modelled as a `Provider` to account for later changes to that property:\r\n\r\n```kotlin\r\nproject.providers.gradleProperty(\"kapt.verbose\").map { it.toBoolean() }.orElse(false)\r\n```"}
{"patch": "@@ -23,9 +23,13 @@ import java.util.zip.ZipOutputStream\n import javax.xml.parsers.DocumentBuilderFactory\n \n internal sealed class MetadataDependencyResolution(\n+    @field:Transient // can't be used with Gradle Instant Execution, but fortunately not needed when deserialized\n     val dependency: ResolvedComponentResult,\n     val projectDependency: Project?", "msg": ":x: Project is not serializable either, so probably needs `@Transient` as well.\r\n\r\n"}
{"patch": "@@ -106,13 +106,21 @@ internal abstract class KotlinBuildStatsService internal constructor() : BuildAd\n                             )\n                             instance = JMXKotlinBuildStatsService(mbs, beanName)\n                         } else {\n+                            val kotlinBuildStatProvider = project.provider{ KotlinBuildStatListener(beanName) }\n                             val newInstance = DefaultKotlinBuildStatsService(gradle, beanName)\n+\n+                            if (isConfigurationCacheAvailable(gradle)) {\n+                                listenerRegistryHolder.listenerRegistry!!.onTaskCompletion(kotlinBuildStatProvider)", "msg": "\u274c This registration isn't valid and won't do anything. I would simply remove it for now.\r\n\r\nSee https://github.com/JetBrains/kotlin/pull/3521/files#r452728632"}
{"patch": "@@ -44,10 +45,9 @@ open class KotlinWithJavaTarget<KotlinOptionsType : KotlinCommonOptions>(\n             KotlinWithJavaCompilationFactory(project, this, kotlinOptionsFactory)\n         )\n \n-    internal val defaultArtifactClassesListFile: File\n-        get() {\n+    internal val defaultArtifactClassesListFile: Provider<File> = project.provider {\n             val jarTask = project.tasks.getByName(artifactsTaskName) as Jar\n-            return File(File(project.buildDir, KOTLIN_BUILD_DIR_NAME), \"${sanitizeFileName(jarTask.archiveFileName.get())}-classes.txt\")\n+            File(File(project.buildDir, KOTLIN_BUILD_DIR_NAME), \"${sanitizeFileName(jarTask.archiveFileName.get())}-classes.txt\")", "msg": "\u2753 I'm not sure where this `val` is wired, but the above code is losing task dependency and reference to `jar.archiveFileName` and could cause ordering problems.\r\n\r\nAnother way to write this would be:\r\n\r\n```kotlin\r\nprivate val layout = project.layout\r\n\r\ninternal val defaultArtifactClassesListFile: Provider<RegularFile> =\r\n    project.tasks.named(\"artifactsTaskName\", Jar::class).flatMap { jar ->\r\n        layout.buildDirectory.file(\"$KOTLIN_BUILD_DIR_NAME/${sanitizeFileName(jar.archiveFileName.get())}-classes.txt\")\r\n    }\r\n```\r\nThis would return a `Provider<RegularFile>`. If you need it to be a `Provider<File>` just chain with `.map { it.asFile }`\r\n\r\nAgain, I'm not sure where this gets used and if my comment is relevant."}
{"patch": "@@ -89,11 +90,9 @@ abstract class AbstractKotlinNativeTargetPreset<T : KotlinNativeTarget>(\n         createTargetConfigurator().configureTarget(result)\n \n         SingleActionPerProject.run(project, \"setUpKotlinNativePlatformDependencies\") {\n-            project.gradle.addListener(object : BuildAdapter() {\n-                override fun projectsEvaluated(gradle: Gradle) {\n-                    project.setUpKotlinNativePlatformDependencies()\n-                }\n-            })\n+            project.gradle.projectsEvaluated {", "msg": "\ud83d\udc4d "}
{"patch": "@@ -56,4 +57,12 @@ internal data class ParsedGradleVersion(val major: Int, val minor: Int) : Compar\n \n fun isGradleVersionAtLeast(major: Int, minor: Int) =\n     ParsedGradleVersion.parse(GradleVersion.current().version)\n-        ?.let { it >= ParsedGradleVersion(major, minor) } ?: false\n\\ No newline at end of file\n+        ?.let { it >= ParsedGradleVersion(major, minor) } ?: false\n+\n+fun isConfigurationCacheAvailable(gradle: Gradle) =\n+    try {\n+        val startParameters = gradle.startParameter\n+        startParameters.javaClass.getMethod(\"isConfigurationCache\").invoke(startParameters) as? Boolean", "msg": "\u2757  that check is using reflection on internal API and exceptions for control flow and doesn't cache the result. This could have a bad effect on performance."}
{"patch": "@@ -71,8 +72,19 @@ object RedundantExplicitTypeChecker : FirMemberDeclarationChecker() {\n                 if (typeReference.text != initializer.name.identifier) return\n             }\n             is FirFunctionCall -> {\n-                if (typeReference.text != initializer.calleeReference.name.identifier) return\n+                if (typeReference.text != initializer.calleeReference.name.asString()) return\n             }\n+            is FirGetClassCall -> {\n+                return\n+                //if (!type.isSame(initializer.typeRef.coneType.type.classId)) return\n+            }\n+            is FirResolvedQualifier -> {\n+                //return", "msg": "Please check here the case like\r\n```\r\nobject SomeObj\r\nfun foo() {\r\n    val x: Any /* NOT redundant */ = SomeObj \r\n}\r\n```"}
{"patch": "@@ -42,27 +43,27 @@ object RedundantExplicitTypeChecker : FirMemberDeclarationChecker() {\n             is FirConstExpression<*> -> {\n                 when (initializer.source?.elementType) {\n                     KtNodeTypes.BOOLEAN_CONSTANT -> {\n-                        if (type.classId != StandardClassIds.Boolean) return\n+                        if (!type.isSame(StandardClassIds.Boolean)) return", "msg": "Please take into account (here and below) that redundant type should not be annoteted. Example:\r\n\r\n```\r\n@Target(AnnotationTarget.TYPE)\r\nannotation class A\r\n\r\nfun foo() {\r\n    val x: @A Int /* NOT redundant */ = 1\r\n}\r\n\r\n```\r\n"}
{"patch": "@@ -1,3 +1,27 @@\n+// Interface\n+interface Interface {\n+    // Redundant\n+    <!REDUNDANT_MODALITY_MODIFIER!>open<!> val gav: Int\n+        get() = 42\n+    // Redundant\n+    <!REDUNDANT_MODALITY_MODIFIER!>abstract<!> fun foo()\n+    // Redundant\n+    private <!REDUNDANT_MODALITY_MODIFIER!>final<!> fun bar() {}", "msg": "Please don't report `REDUNDANT_MODALITY_MODIFIER` for `final` in `interface`, because this is an error."}
{"patch": "@@ -1,3 +1,27 @@\n+// Interface\n+interface Interface {\n+    // Redundant\n+    <!REDUNDANT_MODALITY_MODIFIER!>open<!> val gav: Int", "msg": "Please leave here a comment that `REDUNDANT_MODALITY_MODIFIER` is questionable here (in FE 1.0, compiler reports a warning here, and inspection doesn't report anything)."}
{"patch": "@@ -14,15 +14,16 @@ import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\n import org.jetbrains.kotlin.fir.declarations.FirMemberDeclaration\n import org.jetbrains.kotlin.fir.declarations.FirProperty\n import org.jetbrains.kotlin.fir.declarations.FirTypeAlias\n-import org.jetbrains.kotlin.fir.expressions.FirConstExpression\n-import org.jetbrains.kotlin.fir.expressions.FirExpression\n-import org.jetbrains.kotlin.fir.expressions.FirFunctionCall\n+import org.jetbrains.kotlin.fir.expressions.*\n import org.jetbrains.kotlin.fir.psi\n import org.jetbrains.kotlin.fir.references.FirNamedReference\n import org.jetbrains.kotlin.fir.symbols.StandardClassIds\n+import org.jetbrains.kotlin.fir.types.ConeKotlinType\n import org.jetbrains.kotlin.fir.types.FirTypeRef\n import org.jetbrains.kotlin.fir.types.classId\n import org.jetbrains.kotlin.fir.types.coneType\n+import org.jetbrains.kotlin.fir.types.impl.FirResolvedTypeRefImpl", "msg": "Unused import"}
{"patch": "@@ -16,6 +16,7 @@ import org.jetbrains.kotlin.fir.declarations.FirMemberDeclaration\n import org.jetbrains.kotlin.fir.psi\n import org.jetbrains.kotlin.fir.toFirPsiSourceElement\n import org.jetbrains.kotlin.lexer.KtModifierKeywordToken\n+import org.jetbrains.kotlin.lexer.KtTokens", "msg": "Redundant import"}
{"patch": "@@ -100,16 +106,22 @@ object RedundantVisibilityModifierChecker : FirBasicDeclarationChecker() {\n         (symbol.fir as? FirMemberDeclaration)?.visibility?.let {\n             return it\n         }\n+\n         (symbol.fir as? FirPropertyAccessor)?.visibility?.let {\n             return it\n         }\n+\n         return null\n     }\n \n-    private val FirDeclaration.visibilityForDeclarationAndPropertyAccessor\n+    private val FirMemberDeclaration.isLocalMember: Boolean\n         get() = when (this) {\n-            is FirMemberDeclaration -> status.visibility\n-            is FirPropertyAccessor -> status.visibility\n-            else -> null\n+            is FirProperty -> this.isLocal\n+            is FirRegularClass -> this.isLocal\n+            is FirSimpleFunction -> this.isLocal\n+            else -> false\n         }\n+\n+    private val CheckerContext.lastInContainingDeclarationsVisibility", "msg": "Please rename it to `containingPropertyVisibility` or something like. Current name is very unclear."}
{"patch": "@@ -0,0 +1,135 @@\n+// WITH_RUNTIME\n+\n+import kotlin.properties.Delegates\n+\n+fun withAnnotation(p: List<Any>) {\n+    @Suppress(\"UNCHECKED_CAST\")\n+    <!CAN_BE_VAL!>var<!> v = p as <!REDUNDANT_EXPLICIT_TYPE!>List<String><!>", "msg": "Why do we have `REDUNDANT_EXPLICIT_TYPE` here?"}
{"patch": "@@ -89,6 +89,7 @@ object FirErrors {\n     val REDUNDANT_EXPLICIT_TYPE by warning0<FirSourceElement, PsiElement>()\n     val CAN_BE_VAL by warning0<FirSourceElement, PsiElement>()\n     val UNINITIALIZED_VARIABLE_EXTENDED by warning0<FirSourceElement, PsiElement>()\n+    val UNUSED_VARIABLE by warning0<FirSourceElement, PsiElement>() // we need it?", "msg": "Yes, but probably not in this commit"}
{"patch": "@@ -0,0 +1,10 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis.checkers", "msg": "This file should be deleted"}
{"patch": "@@ -87,12 +98,18 @@ class CallAndReferenceGenerator(\n                 }\n                 is IrFunctionSymbol -> {\n                     val function = symbol.owner\n-                    IrFunctionReferenceImpl(\n-                        startOffset, endOffset, type, symbol,\n-                        typeArgumentsCount = function.typeParameters.size,\n-                        valueArgumentsCount = function.valueParameters.size,\n-                        reflectionTarget = symbol\n-                    )\n+                    // TODO: should refer to LanguageVersionSettings.SuspendConversion", "msg": "@mglukhikh I think both resolution and conversion should refer to feature flags, but didn't so far. Any recommended place to add it? E.g., `FirSession` or some other context?"}
{"patch": "@@ -11,7 +11,7 @@ object Test1 {\n \n         fun test() {\n             val result = foo(::bar)\n-            <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Int\")!>result<!>\n+            <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String\")!>result<!>", "msg": "Note that test changes under `...Disabled*` are regression, since they should not be converted. Once we add feature flag look-up, these can be reverted."}
{"patch": "@@ -41,4 +41,8 @@ class KotlinCleanupInspectionTest() : KotlinLightCodeInsightFixtureTestCase() {\n     fun testCleanup() {\n         doTest(\"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")", "msg": "Because the you create directory for `testKt33594` test then please create directory for this `testCleanup` test"}
{"patch": "@@ -41,4 +41,8 @@ class KotlinCleanupInspectionTest() : KotlinLightCodeInsightFixtureTestCase() {\n     fun testCleanup() {\n         doTest(\"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")\n     }\n+\n+    fun testKt33594() {", "msg": "Bad test name"}
{"patch": "@@ -41,4 +41,8 @@ class KotlinCleanupInspectionTest() : KotlinLightCodeInsightFixtureTestCase() {\n     fun testCleanup() {\n         doTest(\"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")\n     }\n+\n+    fun testKt33594() {\n+        doTest(\"kt33594/foo.kt.after\", \"kt33594/foo.kt\", \"kt33594/bar.kt\")", "msg": "Just in case you will miss it: directory also should be renamed along with test name"}
{"patch": "@@ -49,11 +53,13 @@ class KotlinCleanupInspection : LocalInspectionTool(), CleanupLocalInspectionToo\n \n         val problemDescriptors = arrayListOf<ProblemDescriptor>()\n \n-        val importsToRemove = file.importDirectives.filter { DeprecatedSymbolUsageFix.isImportToBeRemoved(it) }\n-        for (import in importsToRemove) {\n-            val removeImportFix = RemoveImportFix(import)\n-            val problemDescriptor = createProblemDescriptor(import, removeImportFix.text, listOf(removeImportFix), file, manager)\n-            problemDescriptors.add(problemDescriptor)\n+        if (!file.hasSuppressDeprecationAnnotation()) {", "msg": "This `if` check should logically belong to `DeprecatedSymbolUsageFix.isImportToBeRemoved`"}
{"patch": "@@ -70,6 +76,17 @@ class KotlinCleanupInspection : LocalInspectionTool(), CleanupLocalInspectionToo\n         return problemDescriptors.toTypedArray()\n     }\n \n+    private fun KtFile.hasSuppressDeprecationAnnotation(): Boolean {\n+        val suppressAnnotationEntry = annotationEntries.firstOrNull {\n+            it.shortName?.asString() == \"Suppress\"\n+                    && it.resolveToCall()?.resultingDescriptor?.containingDeclaration?.fqNameSafe == KotlinBuiltIns.FQ_NAMES.suppress\n+        } ?: return false\n+        return suppressAnnotationEntry.valueArguments.any {\n+            val text = (it.getArgumentExpression() as? KtStringTemplateExpression)?.entries?.firstOrNull()?.text ?: return@any false", "msg": "> firstOrNull()\r\n\r\n\"singeOrNull\" seems safer option for me"}
{"patch": "@@ -65,6 +66,9 @@ class RedundantCompanionReferenceInspection : AbstractKotlinInspection() {\n \n             val containingClass = objectDeclaration.containingClass() ?: return false\n             if (reference.containingClass() != containingClass && reference == parent.receiverExpression) return false\n+            val calleeText = ((selectorExpression as? KtCallExpression) ?: (grandParent as? KtQualifiedExpression)?.callExpression)", "msg": "First: this function is already too long, you can't add more logic into it. You should extract 3 lines of code you added into separate function + split code of existing `isRedundantCompanionReference` into subfunctions\r\n\r\nSecond: `values` and `valueOf` are hardcoded strings. There are already present in the project. At least you can find them in `RemoveRedundantQualifierNameInspection` and `UnusedSymbolInspection`. Please, extract those hardcoded strings into util class/file and reuse them"}
{"patch": "@@ -14,7 +14,7 @@ object CommonExpressionCheckers : ExpressionCheckers() {\n         FirAbstractSuperCallChecker,\n         FirQualifiedSupertypeExtendedByOtherSupertypeChecker,\n         FirProjectionsOnNonClassTypeArgumentChecker,\n-        FirUpperBoundViolatedChecker,\n+        FirUpperBoundViolatedChecker", "msg": "Please do not edit side files without a reason, especially when you are not the person who mostly works with this side file."}
{"patch": "@@ -6,9 +6,17 @@\n package org.jetbrains.kotlin.fir.analysis.checkers.expression\n \n import org.jetbrains.kotlin.fir.analysis.checkers.extended.CanBeReplacedWithOperatorAssignmentChecker\n+import org.jetbrains.kotlin.fir.analysis.checkers.extended.RedundantCallOfConversionMethod\n+import org.jetbrains.kotlin.fir.analysis.checkers.extended.RedundantSingleExpressionStringTemplateChecker\n \n object ExtendedExpressionCheckers : ExpressionCheckers() {\n+    override val expressionCheckers: List<FirBasicExpresionChecker> = listOf(\n+        RedundantSingleExpressionStringTemplateChecker", "msg": "This change is already in master and should not be in this commit"}
{"patch": "@@ -35,10 +35,14 @@ class KotlinCleanupInspectionTest() : KotlinLightCodeInsightFixtureTestCase() {\n         val profile = InspectionProjectProfileManager.getInstance(project).currentProfile\n         globalContext.codeCleanup(analysisScope, profile, \"Cleanup\", null, true)\n \n-        myFixture.checkResultByFile(result)\n+        myFixture.checkResultByFile(\"$dir/$result\")\n     }\n \n-    fun testCleanup() {\n-        doTest(\"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")\n+    fun testBasic() {", "msg": "You renamed `testCleanup` to `testBasic` but left `cleanup.kt` and `cleanup.kt.after` names. I guess they should be renamed to `basic.kt` and `basic.kt.after` as well"}
{"patch": "@@ -35,10 +35,14 @@ class KotlinCleanupInspectionTest() : KotlinLightCodeInsightFixtureTestCase() {\n         val profile = InspectionProjectProfileManager.getInstance(project).currentProfile\n         globalContext.codeCleanup(analysisScope, profile, \"Cleanup\", null, true)\n \n-        myFixture.checkResultByFile(result)\n+        myFixture.checkResultByFile(\"$dir/$result\")\n     }\n \n-    fun testCleanup() {\n-        doTest(\"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")\n+    fun testBasic() {\n+        doTest(\"basic\", \"cleanup.kt.after\", \"cleanup.kt\", \"JavaAnn.java\", \"deprecatedSymbols.kt\")\n+    }\n+\n+    fun testFileWithAnnotationToSuppressDeprecation() {\n+        doTest(\"fileWithAnnotationToSuppressDeprecation\", \"foo.kt.after\", \"foo.kt\", \"bar.kt\")", "msg": "Same here. `foo.kt` and `foo.kt.after` better to rename to something meaningful"}
{"patch": "@@ -68,5 +69,10 @@ object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVari\n \n     private fun KtBinaryExpression.isCommutative() = this.operationToken == KtTokens.PLUS || this.operationToken == KtTokens.MUL\n \n+    private fun KtBinaryExpression.isArithmetic() = this.operationToken == KtTokens.PLUS\n+            || this.operationToken == KtTokens.MUL\n+            || this.operationToken == KtTokens.MINUS\n+            || this.operationToken == KtTokens.DIV", "msg": "You forgot about `%`"}
{"patch": "@@ -68,5 +69,10 @@ object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVari\n \n     private fun KtBinaryExpression.isCommutative() = this.operationToken == KtTokens.PLUS || this.operationToken == KtTokens.MUL\n \n+    private fun KtBinaryExpression.isArithmetic() = this.operationToken == KtTokens.PLUS", "msg": "I'd change the name to `canBeAugmented` or something like."}
{"patch": "@@ -197,8 +198,10 @@ object KotlinToJVMBytecodeCompiler {\n         }\n \n         val projectConfiguration = environment.configuration\n+        val extendedAnalysisMode = projectConfiguration.getBoolean(CommonConfigurationKeys.USE_FIR_EXTENDED_CHECKERS)", "msg": "It's better to calculate it under the following `if`"}
{"patch": "@@ -1,3 +1,6 @@\n+// IGNORE_BACKEND_FIR: JVM_IR", "msg": "@demiurg906 Hope you aware about this problem"}
{"patch": "@@ -1,4 +1,5 @@\n // \"Remove redundant 'if' statement\" \"false\"\n+// ACTION: Add braces to 'if' all statements", "msg": "Same thing above."}
{"patch": "@@ -22,16 +22,19 @@ import org.jetbrains.kotlin.fir.types.coneType\n import org.jetbrains.kotlin.lexer.KtTokens\n import org.jetbrains.kotlin.psi.KtBinaryExpression\n import org.jetbrains.kotlin.psi.KtNameReferenceExpression\n+import org.jetbrains.kotlin.psi.KtOperationReferenceExpression\n \n object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVariableAssignment>() {\n-    override fun check(functionCall: FirVariableAssignment, context: CheckerContext, reporter: DiagnosticReporter) {\n-        val lValue = functionCall.lValue\n+    override fun check(assignment: FirVariableAssignment, context: CheckerContext, reporter: DiagnosticReporter) {", "msg": "You should name value parameters of overriden function same as they named in original function (or you can get errors with function calls with named arguments)\r\n\r\nIt's better to rename `functionCall` in `FirExpressionChecker` to `expression`"}
{"patch": "@@ -22,16 +22,19 @@ import org.jetbrains.kotlin.fir.types.coneType\n import org.jetbrains.kotlin.lexer.KtTokens\n import org.jetbrains.kotlin.psi.KtBinaryExpression\n import org.jetbrains.kotlin.psi.KtNameReferenceExpression\n+import org.jetbrains.kotlin.psi.KtOperationReferenceExpression\n \n object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVariableAssignment>() {", "msg": "Also it's better to inherit from `FirVariableAssignmentChecker` alias"}
{"patch": "@@ -56,9 +59,12 @@ object CanBeReplacedWithOperatorAssignmentChecker : FirExpressionChecker<FirVari\n \n             val isLeftMatch = isHierarchicallyTrue(operationToken, leftExpression?.operationToken)\n                     && leftExpression?.matcher(variable) == true\n+            if (isLeftMatch) return true\n             val isRightMatch = isHierarchicallyTrue(operationToken, rightExpression?.operationToken)\n                     && rightExpression?.matcher(variable) == true\n-            isLeftMatch or isRightMatch\n+            if (isRightMatch) return true", "msg": "Just return `isRightMatch`"}
{"patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis\n+\n+import com.intellij.lang.LighterASTNode\n+import com.intellij.openapi.util.Ref\n+import com.intellij.psi.tree.IElementType\n+import com.intellij.util.diff.FlyweightCapableTreeStructure\n+\n+class LighterTreeElementFinderByType(", "msg": "Please rename the containing file to class name"}
{"patch": "@@ -339,6 +343,10 @@ class FirDefaultErrorMessages : DefaultErrorMessages.Extension {\n             map.put(ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_EQUALS, \"Replace '==' with 'Arrays.equals'\")\n             map.put(EMPTY_RANGE, \"Range is empty\")\n             map.put(REDUNDANT_SETTER_PARAMETER_TYPE, \"Redundant setter parameter type\")\n+            map.put(UNUSED_VARIABLE, \"Unused variable\")\n+            map.put(ASSIGNED_VALUE_IS_NEVER_READ, \"Assigned value is never read\")\n+            map.put(VARIABLE_INITIALIZER_IS_REDUNDANT, \"Initialized is redundant\")\n+            map.put(VARIABLE_NEVER_READ, \"Variable never read\")", "msg": "Variable is never read?"}
{"patch": "@@ -339,6 +343,10 @@ class FirDefaultErrorMessages : DefaultErrorMessages.Extension {\n             map.put(ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_EQUALS, \"Replace '==' with 'Arrays.equals'\")\n             map.put(EMPTY_RANGE, \"Range is empty\")\n             map.put(REDUNDANT_SETTER_PARAMETER_TYPE, \"Redundant setter parameter type\")\n+            map.put(UNUSED_VARIABLE, \"Unused variable\")\n+            map.put(ASSIGNED_VALUE_IS_NEVER_READ, \"Assigned value is never read\")\n+            map.put(VARIABLE_INITIALIZER_IS_REDUNDANT, \"Initialized is redundant\")", "msg": "Initializer is redundant (typo)"}
{"patch": "@@ -11,12 +11,12 @@ import org.jetbrains.kotlin.contracts.description.EventOccurrencesRange\n import org.jetbrains.kotlin.fir.FirSession", "msg": "General note: please change `[FIR] ControlFlowAnalyserCheckers support` to some more specific message. The most valuable point here is context which was added to CFA checkers (IMHO)."}
{"patch": "@@ -36,7 +37,7 @@ object RedundantModalityModifierChecker : FirMemberDeclarationChecker() {\n \n         if (modality != implicitModality) return\n \n-        val modalityModifierSource = declaration.source.getModifierList()?.modifiers?.modalitySource()\n+        val modalityModifierSource = declaration.source?.getChildren(modality.toToken(), depth = 2)\n         reporter.report(modalityModifierSource, REDUNDANT_MODALITY_MODIFIER)\n     }\n ", "msg": "`modalitySource` below is now unused, please remove it."}
{"patch": "@@ -125,15 +127,6 @@ object RedundantVisibilityModifierChecker : FirBasicDeclarationChecker() {\n     private val CheckerContext.containingPropertyVisibility\n         get() = (this.containingDeclarations.last() as? FirProperty)?.visibility\n \n-    private val FirSourceElement?.modifierSource: FirSourceElement?\n-        get() = when (this) {\n-            null -> null\n-            is FirPsiSourceElement<*> -> (psi as? KtModifierListOwner)?.modifierList?.visibilityModifier()?.toFirPsiSourceElement()\n-            is FirLightSourceElement -> {\n-                val modifier = this.getModifierList()?.modifiers?.firstOrNull { it.isVisibilityModifier }\n-                modifier?.source\n-            }\n-        }\n \n     private val FirModifier<*>.isVisibilityModifier", "msg": "`isVisiblityModifier` is also unused now"}
{"patch": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis\n+\n+import com.intellij.psi.tree.IElementType\n+import com.intellij.psi.tree.TokenSet\n+import org.jetbrains.kotlin.fir.*\n+\n+fun FirSourceElement.getChildren(type: IElementType, index: Int = 0, depth: Int = -1): FirSourceElement? {", "msg": "As I can see, all these functions return a child, not a set of children. Please rename them accordingly."}
{"patch": "@@ -1,10 +1,3 @@\n-<!REDECLARATION!><!REDUNDANT_VISIBILITY_MODIFIER!>public<!> class C {", "msg": "General note: this is not a refactoring of tests, but minor test data changes."}
{"patch": "@@ -57,6 +57,13 @@ abstract class AbstractVariableRemapper : IrElementTransformerVoid() {\n         remapVariable(expression.symbol.owner)?.let {\n             IrGetValueImpl(expression.startOffset, expression.endOffset, it.type, it.symbol, expression.origin)\n         } ?: expression\n+\n+    override fun visitSetValue(expression: IrSetValue): IrExpression {", "msg": "Actual change: when remapping parameter symbols, we now need to look at SetValue as well as GetValue."}
{"patch": "@@ -118,11 +118,11 @@ class SharedVariablesLowering(val context: BackendContext) : BodyLoweringPass {\n                     }\n                 }\n \n-                override fun visitSetVariable(expression: IrSetVariable, data: IrDeclarationParent?) {\n-                    super.visitSetVariable(expression, data)\n+                override fun visitSetValue(expression: IrSetValue, data: IrDeclarationParent?) {\n+                    super.visitSetValue(expression, data)\n \n                     val variable = expression.symbol.owner\n-                    if (variable.initializer == null && getRealParent(variable) != data && variable in relevantVals) {\n+                    if (variable is IrVariable && variable.initializer == null && getRealParent(variable) != data && variable in relevantVals) {", "msg": "Actual change: adapt code to have same behavior as before."}
{"patch": "@@ -711,22 +711,22 @@ class ExpressionCodegen(\n         return false\n     }\n \n-    override fun visitSetVariable(expression: IrSetVariable, data: BlockInfo): PromisedValue {\n+    override fun visitSetValue(expression: IrSetValue, data: BlockInfo): PromisedValue {\n         if (!handleIntVariableSpecialCases(expression)) {\n             expression.value.markLineNumber(startOffset = true)\n             expression.value.accept(this, data).materializeAt(expression.symbol.owner.type)\n-            expression.markLineNumber(startOffset = true)\n+            // We set the value of parameters only for default values. The inliner accepts only", "msg": "Real change: be careful with the bytecode patterns for default arguments. This is a little too indirect for my taste. If we start setting parameters for some other reason the store will not have line numbers."}
{"patch": "@@ -162,6 +163,13 @@ private class EnumClassLowering(val context: JvmBackendContext) : ClassLoweringP\n                     IrGetValueImpl(expression.startOffset, expression.endOffset, it.type, it.symbol, expression.origin)\n                 } ?: expression\n \n+            override fun visitSetValue(expression: IrSetValue): IrExpression {", "msg": "Real change: when remapping parameter symbols we now need to look at SetValue as well as GetValue."}
{"patch": "@@ -39,11 +38,7 @@ class JvmDefaultArgumentStubGenerator(override val context: JvmBackendContext) :\n         //\n         // This control flow limits us to an if-then (without an else), and this together with the\n         // restriction on loading the parameter in the default case means we cannot create any temporaries.\n-        +irIfThen(defaultFlag, irCall(this@JvmDefaultArgumentStubGenerator.context.ir.symbols.reassignParameterIntrinsic).apply {\n-            putTypeArgument(0, parameter.type)\n-            putValueArgument(0, irGet(parameter))\n-            putValueArgument(1, default)\n-        })\n+        +irIfThen(defaultFlag, irSet(parameter.symbol, default))", "msg": "Real change: remove the JVM-specific intrinsic and use the IR structure instead."}
{"patch": "@@ -0,0 +1,10 @@\n+fun test() = 42\n+\n+fun foo() {\n+    val <caret>a =", "msg": "I think this is incorrect behavior. Inspection should be available in cases:\r\n* this is one-line property\r\n* this is property with one-line initializer and action == INLINE"}
{"patch": "@@ -234,7 +243,7 @@ abstract class IncrementalCompilerRunner<\n \n             args.reportOutputFiles = true\n             val outputItemsCollector = OutputItemsCollectorImpl()\n-            val temporaryMessageCollector = TemporaryMessageCollector(messageCollector)\n+            val temporaryMessageCollector = BufferingMessageCollector()", "msg": "nit: Rename to bufferingMessageCollector?"}
{"patch": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\", \"RedundantVisibilityModifier\")\n+@file:JvmMultifileClass\n+@file:JvmName(\"PathsKt\")\n+@file:kotlin.jvm.JvmPackageName(\"kotlin.io.jdk7\")\n+\n+package kotlin.io\n+\n+import java.io.File\n+import java.io.IOException\n+import java.nio.channels.FileChannel\n+import java.nio.file.*\n+import java.nio.file.FileAlreadyExistsException\n+import java.nio.file.NoSuchFileException\n+\n+/**\n+ * Returns the extension of this file (not including the dot), or an empty string if it doesn't have one.\n+ */\n+@SinceKotlin(\"1.3\")\n+@ExperimentalStdlibApi\n+public val Path.extension: String\n+    get() = fileName.toString().substringAfterLast('.', \"\")\n+\n+/**\n+ * Returns [path][File.path] of this File using the invariant separator '/' to", "msg": "`File.path` - looks like an incorrect reference.\r\nIn general, we need to revise docs of these functions and use \"file\" only there where it refers to a physical file."}
{"patch": "@@ -398,32 +399,35 @@ internal class AdapterGenerator(\n         }\n     }\n \n-    // TODO: refactor to share some logic with suspend conversion for callable reference", "msg": "Because of this addition, now I feel like they diverge..."}
{"patch": "@@ -791,7 +791,6 @@ class Fir2IrDeclarationStorage(\n                     isExternal = false,\n                     isStatic = field.isStatic\n                 ).apply {\n-                    metadata = FirMetadataSource.Variable(field)", "msg": "Not 100% sure about this one, though it looks like it only affects imported Java fields and delegated \"synthetic\" fields, whatever that means, so it should not have any effect on emitted metadata.\r\n\r\nThat said, the fact that FIR fields, unlike descriptor fields, are not properties is slightly concerning, because e.g. they currently cannot be referenced. The IR simply doesn't allow it - it *requires* a property symbol for an `IrPropertyReferenceImpl`. FIR-imported Java fields can't have one."}
{"patch": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\", \"RedundantVisibilityModifier\")\n+@file:JvmMultifileClass\n+@file:JvmName(\"PathsKt\")\n+@file:kotlin.jvm.JvmPackageName(\"kotlin.io.jdk7\")\n+\n+package kotlin.io\n+\n+import java.io.File\n+import java.io.IOException\n+import java.nio.channels.FileChannel\n+import java.nio.file.*\n+import java.nio.file.FileAlreadyExistsException\n+import java.nio.file.NoSuchFileException\n+\n+/**\n+ * Returns the extension of this file (not including the dot), or an empty string if it doesn't have one.\n+ */\n+@SinceKotlin(\"1.3\")", "msg": "Let's change all `@SinceKotlin(1.3)` to `@SinceKotlin(1.4)`"}
{"patch": "@@ -74,6 +78,7 @@ fun mapArguments(\n                 name = function.valueParameters.last().name\n             }\n             argumentsInParenthesis = argumentsInParenthesis.dropLast(1) + listOf(namedV)\n+            oldToNewArgumentMap[v] = namedV", "msg": "This is used to replace the set argument in the call's argument list (see changes in `FirCallCompletionResultsWriterTransformer.kt`). Otherwise `remapArgumentsWithVararg` in `BodyResolveUtils.kt` simply loses the argument (it remaps based on the call argument list). I'm open to other suggestions on how to solve this."}
{"patch": "@@ -328,42 +318,30 @@ private val KOTLIN_MARKER_INTERFACES: Map<FqName, String> = run {\n     kotlinMarkerInterfaces\n }\n \n-internal class IrSuperClassInfo(val type: Type, val irType: IrType?)\n-\n-internal fun getSignature(\n-    irClass: IrClass,\n-    classAsmType: Type,\n-    superClassInfo: IrSuperClassInfo,\n-    typeMapper: IrTypeMapper\n-): JvmClassSignature {\n+internal fun IrTypeMapper.mapClassSignature(irClass: IrClass, type: Type): JvmClassSignature {\n     val sw = BothSignatureWriter(BothSignatureWriter.Mode.CLASS)\n-\n-    typeMapper.writeFormalTypeParameters(irClass.typeParameters, sw)\n+    writeFormalTypeParameters(irClass.typeParameters, sw)\n \n     sw.writeSuperclass()\n-    val irType = superClassInfo.irType\n-    if (irType == null) {\n-        sw.writeClassBegin(superClassInfo.type)\n+    val superClassType = irClass.superTypes.find { it is IrSimpleType && (it.classifier as? IrClassSymbol)?.owner?.isJvmInterface == false }", "msg": "```suggestion\r\n    val superClassType = irClass.superTypes.find { it.getClass()?.isJvmInterface == false }\r\n```"}
{"patch": "@@ -78,8 +80,9 @@ class MaterialValue(codegen: ExpressionCodegen, type: Type, irType: IrType) : Pr\n \n // A value that can be branched on. JVM has certain branching instructions which can be used\n // to optimize these.\n-abstract class BooleanValue(codegen: ExpressionCodegen) :\n-    PromisedValue(codegen, Type.BOOLEAN_TYPE, codegen.context.irBuiltIns.booleanType) {\n+abstract class BooleanValue(codegen: ExpressionCodegen, type: Type, irType: IrType) : PromisedValue(codegen, type, irType) {", "msg": "Maybe rename to BranchedValue (similar to one in old backend)?"}
{"patch": "@@ -27,6 +27,7 @@ data class ArgumentMapping(\n     //      foo(b = bar(), a = qux())\n     // parameterToCallArgumentMap.values() should be [ 'bar()', 'foo()' ]\n     val parameterToCallArgumentMap: Map<FirValueParameter, ResolvedCallArgument>,\n+    val oldToNewArgumentMap: Map<FirExpression, FirExpression>,", "msg": "Same for nullability and name"}
{"patch": "@@ -623,6 +636,147 @@ abstract class BaseFirBuilder<T>(val baseSession: FirSession, val context: Conte\n         }\n     }\n \n+    /**\n+     * given:\n+     * a[b, c]++\n+     *\n+     * result:\n+     * {\n+     *     val <array> = a\n+     *     val <index0> = b\n+     *     val <index1> = c\n+     *     val <unary> = <array>.get(b, c)\n+     *     <array>.set(b, c, <unary>.inc())\n+     *     ^<unary>\n+     * }\n+     *\n+     * given:\n+     * ++a[b, c]\n+     *\n+     * result:\n+     * {\n+     *     val <array> = a\n+     *     val <index0> = b\n+     *     val <index1> = c\n+     *     val <unary-result> = <array>.get(b, c).inc()\n+     *     <array>.set(b, c, <unary-result>)\n+     *     ^<unary-result>\n+     * }\n+     *\n+     */\n+    private fun generateIncrementOrDecrementBlockForArrayAccess(", "msg": "Very important change, thanks for it"}
{"patch": "@@ -199,8 +199,12 @@ val IrClass.primaryConstructor: IrConstructor?\n val IrDeclarationContainer.properties: Sequence<IrProperty>\n     get() = declarations.asSequence().filterIsInstance<IrProperty>()\n \n-val IrFunction.explicitParameters: List<IrValueParameter>\n-    get() = (listOfNotNull(dispatchReceiverParameter, extensionReceiverParameter) + valueParameters)\n+val IrFunction.explicitParameters: MutableList<IrValueParameter>", "msg": "Please avoid making return type `MutableList`.\r\nConsider declaring `IrFunction.addExplicitParametersTo(MutableList)` and using it here and in `allParameters` instead."}
{"patch": "@@ -199,8 +199,16 @@ val IrClass.primaryConstructor: IrConstructor?\n val IrDeclarationContainer.properties: Sequence<IrProperty>\n     get() = declarations.asSequence().filterIsInstance<IrProperty>()\n \n+fun IrFunction.addExplicitParametersTo(parametersList: MutableList<IrValueParameter>) {\n+    dispatchReceiverParameter?.let { parametersList.add(it) }", "msg": "`parametersList.addIfNotNull(dispatchReceiverParameter)`?\r\nSame below."}
{"patch": "@@ -206,6 +206,12 @@ fun IrFunction.addExplicitParametersTo(parametersList: MutableList<IrValueParame\n     parametersList.addAll(valueParameters)\n }\n \n+internal fun Boolean.toInt(): Int = if (this) 1 else 0", "msg": "Isn't `private` enough here?"}
{"patch": "@@ -199,8 +200,22 @@ val IrClass.primaryConstructor: IrConstructor?\n val IrDeclarationContainer.properties: Sequence<IrProperty>\n     get() = declarations.asSequence().filterIsInstance<IrProperty>()\n \n+fun IrFunction.addExplicitParametersTo(parametersList: MutableList<IrValueParameter>) {\n+    parametersList.addIfNotNull(dispatchReceiverParameter)\n+    parametersList.addIfNotNull(extensionReceiverParameter)\n+    parametersList.addAll(valueParameters)\n+}\n+\n+internal fun Boolean.toInt(): Int = if (this) 1 else 0\n+\n+val IrFunction.explicitParametersNumber: Int", "msg": "Maybe `explicitParametersCount`? Same for `allParametersNumber`."}
{"patch": "@@ -199,8 +200,22 @@ val IrClass.primaryConstructor: IrConstructor?\n val IrDeclarationContainer.properties: Sequence<IrProperty>\n     get() = declarations.asSequence().filterIsInstance<IrProperty>()\n \n+fun IrFunction.addExplicitParametersTo(parametersList: MutableList<IrValueParameter>) {\n+    parametersList.addIfNotNull(dispatchReceiverParameter)\n+    parametersList.addIfNotNull(extensionReceiverParameter)\n+    parametersList.addAll(valueParameters)\n+}\n+\n+internal fun Boolean.toInt(): Int = if (this) 1 else 0\n+\n+val IrFunction.explicitParametersNumber: Int\n+    get() = (dispatchReceiverParameter != null).toInt() + (extensionReceiverParameter != null).toInt() +\n+            valueParameters.size\n+\n val IrFunction.explicitParameters: List<IrValueParameter>\n-    get() = (listOfNotNull(dispatchReceiverParameter, extensionReceiverParameter) + valueParameters)\n+    get() = ArrayList<IrValueParameter>(valueParameters.size + 2).also {", "msg": "(Not sure if it makes sense but) now it is easy to use exact size here. Same for `allParameters`."}
{"patch": "@@ -432,14 +431,20 @@ fun IrFunction.createDispatchReceiverParameter(origin: IrDeclarationOrigin? = nu\n \n val IrFunction.allParameters: List<IrValueParameter>\n     get() = if (this is IrConstructor) {\n-        listOf(\n-            this.constructedClass.thisReceiver\n-                ?: error(this.render())\n-        ) + explicitParameters\n+        ArrayList<IrValueParameter>(valueParameters.size + 3).also {", "msg": "```suggestion\r\n        ArrayList<IrValueParameter>(allParametersCount).also {\r\n```"}
{"patch": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package samples.streams\n+\n+import samples.Sample\n+import samples.assertPrints\n+import java.util.stream.DoubleStream\n+import java.util.stream.IntStream\n+import java.util.stream.LongStream\n+import java.util.stream.Stream\n+import kotlin.streams.asSequence\n+import kotlin.streams.asStream\n+import kotlin.streams.toList\n+\n+class Streams {\n+\n+    @Sample\n+    fun streamAsSequence() {\n+        val stringStream = Stream.of(\"Never\", \"gonna\", \"give\", \"you\", \"up\")\n+        val stringSequence = stringStream.asSequence()\n+        assertPrints(stringSequence.joinToString(\" \"), \"Never gonna give you up\")", "msg": "\ud83d\ude01"}
{"patch": "@@ -105,9 +105,9 @@ fun foo() {\n     <!CAN_BE_VAL!>var<!> <!VARIABLE_NEVER_READ!>a<!>: Int\n     val bool = true\n     if (bool) <!ASSIGNED_VALUE_IS_NEVER_READ!>a<!> = 4 else <!ASSIGNED_VALUE_IS_NEVER_READ!>a<!> = 42\n-    val <!UNUSED_VARIABLE!>b<!>: String\n+    val <!VARIABLE_NEVER_READ!>b<!>: String\n \n-    <!ASSIGNED_VALUE_IS_NEVER_READ!>bool<!> = false", "msg": "`bool` has been read above, so I'm pretty much sure the intention was `b`, not `bool`."}
{"patch": "@@ -33,12 +33,12 @@ fun test() {\n                 // Loop executed exectly once, initializing x\n                 myRun { x.inc() }\n \n-                myRun { x = 42 }\n+                myRun { <!VAL_REASSIGNMENT!>x<!> = 42 }\n                 break\n             }\n             // x is I?D here because loop could've been execited\n             // VAL_REASSIGNMENT isn't reported because of repeating diagnostic\n-            x = 42\n+            <!VAL_REASSIGNMENT!>x<!> = 42", "msg": "Aha, very clear evidence here. According to the comment, the repeating diagnostic error is not reported. So, this one is `VAL_REASSIGNMENT`, but old FE somehow collects and reports an error per error kind maybe."}
{"patch": "@@ -111,6 +111,11 @@ class Fir2IrConversionScope {\n     fun dispatchReceiverParameter(irClass: IrClass): IrValueParameter? {\n         for (function in functionStack.asReversed()) {\n             if (function.parentClassOrNull == irClass) {\n+                // An inner class's constructor needs an instance of the outer class as a dispatch receiver.\n+                // However, if we are converting `this` receiver inside that constructor, now we should point to the inner class instance.\n+                if (function is IrConstructor && irClass.isInner) {\n+                    irClass.thisReceiver?.let { return it }", "msg": "I realized `irClass.thisReceiver` is returned as a default-ish dispatch receiver at the end, so we may just skip here if `function is IrConstructor` in general. But, it's better to return early I think."}
{"patch": "@@ -67,6 +67,8 @@ abstract class FirVisibilityChecker : FirSessionComponent {\n                     } else {\n                         // Member: visible inside parent class, including all its member classes\n                         canSeePrivateMemberOf(containingDeclarations, ownerId, session)\n+                                // Handle enum entries, as they are represented as anonymous objects (KT-42351)\n+                                || containingDeclarations.any { it is FirAnonymousObject && it.declarations.contains(declaration) }", "msg": "This check looks like ad-hock hack"}
{"patch": "@@ -69,8 +69,8 @@ private fun IrBody.move(\n     override fun visitBlock(expression: IrBlock): IrExpression {\n         // Might be an inline lambda argument; if the function has already been moved out, visit it explicitly.\n         if (expression.origin == IrStatementOrigin.LAMBDA || expression.origin == IrStatementOrigin.ANONYMOUS_FUNCTION)\n-            if (expression.statements[0] !is IrFunction && expression.statements[1] is IrFunctionReference)\n-                (expression.statements[1] as IrFunctionReference).symbol.owner.transformChildrenVoid()\n+            if (expression.statements.lastOrNull() is IrFunctionReference && !expression.statements.any { it is IrFunction })", "msg": "`!any` -> `none`"}
{"patch": "@@ -85,11 +85,21 @@ fun IrSimpleFunction.overrides(other: IrSimpleFunction): Boolean {\n private val IrConstructorCall.annotationClass\n     get() = this.symbol.owner.constructedClass\n \n+val IrClass.packageFqName", "msg": "Maybe use explicit return type? Otherwise one needs to check the implementation to see if it's FqName or String"}
{"patch": "@@ -80,7 +80,10 @@ abstract class AbstractSuspendFunctionsLowering<C : CommonBackendContext>(val co\n     // Suppress since it is used in native\n     @Suppress(\"MemberVisibilityCanBePrivate\")\n     protected fun IrCall.isReturnIfSuspendedCall() =\n-        symbol.owner.run { fqNameWhenAvailable == context.internalPackageFqn.child(Name.identifier(\"returnIfSuspended\")) }\n+        symbol.owner.run {\n+            parent.getPackageFragment()?.fqName == context.internalPackageFqn &&\n+                    name.asString() == \"returnIfSuspended\"", "msg": "Looks like the simple name check can come first now, since it's cheaper"}
{"patch": "@@ -0,0 +1,32 @@\n+fun castInTry(s: Any) {\n+    try {\n+        s as String // Potential cast exception\n+    } catch (e: Exception) {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    } finally {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    }\n+    s.<!UNRESOLVED_REFERENCE!>length<!>", "msg": "Should be smartcast"}
{"patch": "@@ -0,0 +1,32 @@\n+fun castInTry(s: Any) {\n+    try {\n+        s as String // Potential cast exception\n+    } catch (e: Exception) {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    } finally {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    }\n+    s.<!UNRESOLVED_REFERENCE!>length<!>\n+}\n+\n+fun castInTryAndCatch(s: Any) {\n+    try {\n+        s as String // Potential cast exception\n+    } catch (e: Exception) {\n+        s as String // Potential cast exception\n+    } finally {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    }\n+    s.<!UNRESOLVED_REFERENCE!>length<!>", "msg": "Should be smartcast"}
{"patch": "@@ -0,0 +1,17 @@\n+fun castInTry(s: Any) {\n+    try {\n+        s as String // Potential cast exception\n+    } finally {\n+        s.<!UNRESOLVED_REFERENCE!>length<!>\n+    }\n+    s.<!UNRESOLVED_REFERENCE!>length<!>", "msg": "Should be smartcast"}
{"patch": "@@ -52,17 +53,91 @@ class LocalPropertyCollector private constructor() : ControlFlowGraphVisitorVoid\n     }\n }\n \n+class PathAwarePropertyInitializationInfo(\n+    map: PersistentMap<String?, PropertyInitializationInfo> = persistentMapOf()\n+) : ControlFlowInfo<PathAwarePropertyInitializationInfo, String?, PropertyInitializationInfo>(map) {\n+    companion object {\n+        val INIT = PathAwarePropertyInitializationInfo(persistentMapOf(null to PropertyInitializationInfo.EMPTY))", "msg": "Please rename it to `EMPTY`"}
{"patch": "@@ -80,9 +80,10 @@ abstract class AbstractSuspendFunctionsLowering<C : CommonBackendContext>(val co\n     // Suppress since it is used in native\n     @Suppress(\"MemberVisibilityCanBePrivate\")\n     protected fun IrCall.isReturnIfSuspendedCall() =\n-        symbol.owner.run { fqNameWhenAvailable == context.internalPackageFqn.child(Name.identifier(\"returnIfSuspended\")) }\n+        symbol.isPublicApi && context.returnIfSuspendedSignature.equalsWithNames(symbol.signature)", "msg": "Sorry, I didn't notice the first time that there's already `returnIfSuspended` in `Symbols`. Maybe do something like this instead then: `context.ir.symbols.returnIfSuspended.signature == symbol.signature`?"}
{"patch": "@@ -5,20 +5,59 @@\n \n package org.jetbrains.kotlin.ir.types\n \n+import org.jetbrains.kotlin.builtins.PrimitiveType\n import org.jetbrains.kotlin.builtins.StandardNames\n import org.jetbrains.kotlin.ir.declarations.IrClass\n import org.jetbrains.kotlin.ir.symbols.IrClassSymbol\n import org.jetbrains.kotlin.ir.symbols.IrClassifierSymbol\n+import org.jetbrains.kotlin.ir.util.IdSignature\n import org.jetbrains.kotlin.ir.util.fqNameWhenAvailable\n+import org.jetbrains.kotlin.ir.util.hasEqualFqName\n+import org.jetbrains.kotlin.name.FqName\n import org.jetbrains.kotlin.name.FqNameUnsafe\n+import org.jetbrains.kotlin.name.Name\n+import org.jetbrains.kotlin.utils.newHashMapWithExpectedSize\n+\n+object IdSignatureValues {", "msg": "Please add `@Suppress(\"ObjectPropertyName\")`"}
{"patch": "@@ -38,4 +38,65 @@ class Randoms {\n         // random with another seed produce another sequence\n         assertPrints(randomValues3, \"[14, 48, 57, 67, 82, 7, 61, 27, 14, 59]\")\n     }\n-}\n\\ No newline at end of file\n+\n+    @Sample\n+    fun nextBits() {\n+        // always generates a 0\n+        println(Random.nextBits(0))\n+        // get a random 1 bit value\n+        println(Random.nextBits(1))\n+        // get a random 8 bit value\n+        println(Random.nextBits(8))\n+        // get a random 16 bit value\n+        println(Random.nextBits(16))\n+        // get a random 32 bit value\n+        println(Random.nextBits(32))\n+    }\n+\n+    @Sample\n+    fun nextBoolean() {\n+        // get a random Boolean value\n+        println(Random.nextBoolean())", "msg": "Samples are meant to clarify function behavior and provide usage examples for documentation readers. This sample do not seem to comply the criteria.\r\n\r\nConsider writing more or less realistic use cases. For example:\r\n```\r\nval isAliceFirst = Random.nextBoolean()\r\nif (isAliceFirst) {\r\n    println(\"Alice goes first.\")\r\n} else {\r\n    println(\"Bob goes first.\")\r\n}\r\n```"}
{"patch": "@@ -1,4 +1,5 @@\n // !LANGUAGE: +StrictJavaNullabilityAssertions\n+// IGNORE_BACKEND_FIR: JVM_IR", "msg": "I'll take a look at this regression. This fails at line 36, which seems correct to me in the sense that a function that said `@NotNull` actually returns `null`. But I guess this is related to this change: https://github.com/JetBrains/kotlin/commit/ee020ef2903ca25154973ff7d9f93a1213068bf2\r\n\r\nThat is, if the expected type has `@EnhancedNullability` (in this case, I guess so), according to that change, we shouldn't add implicit cast, and that's why it worked so far (since we've never added implicit `NOT_NULL` cast). However, since the expected type is involved in, I wonder it would be way deeper in the resolution, and instead of `fir2ir`, we may need implicit cast during the resolution?"}
{"patch": "@@ -1,4 +1,7 @@\n // FILE: test/CallableDescriptor.java\n+// IGNORE_BACKEND_FIR: JVM_IR\n+// Here FIR adds implicit NOT_NULL cast for `origin`, resulting in an assertion being added,\n+// which is the correct (yet mismatching) behavior, according to https://youtrack.jetbrains.com/issue/KT-35656", "msg": "According to the comment below about `JVM_IR` behavior, I guess this is also related to expected type checking. One thing I'm confused is, as mentioned in TODO below, \"there should be an assertion,\" but it will be a breaking change?"}
{"patch": "@@ -57,8 +57,7 @@ fun getPublicSignature(packageFqName: FqName, name: String) =\n private fun IrType.isClassType(signature: IdSignature.PublicSignature, hasQuestionMark: Boolean? = null): Boolean {\n     if (this !is IrSimpleType) return false\n     if (hasQuestionMark != null && this.hasQuestionMark != hasQuestionMark) return false\n-    if (!classifier.isPublicApi || !classifier.signature.isPublic) return false\n-    return signature == classifier.signature\n+    return classifier.signature?.let { signature == it } ?: false", "msg": "```suggestion\r\n    return signature == classifier.signature\r\n```"}
{"patch": "@@ -37,9 +37,9 @@ abstract class IrModuleDeserializer(val moduleDescriptor: ModuleDescriptor) {\n     abstract fun deserializeIrSymbol(idSig: IdSignature, symbolKind: BinarySymbolData.SymbolKind): IrSymbol\n \n     open fun declareIrSymbol(symbol: IrSymbol) {\n-        assert(symbol.isPublicApi) { \"Symbol is not public API: ${symbol.descriptor}\" }\n+        assert(symbol.signature != null && symbol.isPublicApi) { \"Symbol is not public API: ${symbol.descriptor}\" }", "msg": "Here and below, please extract `symbol.signature` to a variable. Also, replace `assert`s  with `require` here, to make use of smart casts to avoid extra `!!`"}
{"patch": "@@ -347,7 +347,7 @@ interface IrTypeSystemContext : TypeSystemContext, TypeSystemCommonSuperTypesCon\n     override fun TypeConstructorMarker.getPrimitiveType(): PrimitiveType? {\n         if (this !is IrClassSymbol || !isPublicApi) return null\n \n-        val signature = signature.asPublic()\n+        val signature = signature?.asPublic()", "msg": "The call to `isPublicApi` above is no longer needed here and in `getPrimitiveArrayType`"}
{"patch": "@@ -166,8 +167,9 @@ class IrModuleDeserializerWithBuiltIns(\n     }\n \n     override fun declareIrSymbol(symbol: IrSymbol) {\n-        if (symbol.isPublicApi && checkIsFunctionInterface(symbol.signature))\n-            resolveFunctionalInterface(symbol.signature, symbol.kind())\n+        val signature = symbol.signature\n+        if (signature != null && checkIsFunctionInterface(symbol.signature!!))", "msg": "Could you please fix the usage of `symbol.signature!!` with `signature`"}
{"patch": "@@ -76,8 +76,8 @@ class DeclarationStubGenerator(\n         if (symbol is IrFieldSymbol && (symbol.descriptor as? WrappedPropertyDescriptor)?.isBound() == true) {\n             return generateStubBySymbol(symbol, symbol.descriptor)\n         }\n-        val descriptor = if (symbol.descriptor is WrappedDeclarationDescriptor<*>)\n-            findDescriptorBySignature(symbol.signature)\n+        val descriptor = if (symbol.descriptor is WrappedDeclarationDescriptor<*> && symbol.signature != null)\n+            findDescriptorBySignature(symbol.signature!!)", "msg": "It would good if you put `symbol.signature` into a separate variable and use it without null-assertion"}
{"patch": "@@ -76,8 +76,10 @@ class DeclarationStubGenerator(\n         if (symbol is IrFieldSymbol && (symbol.descriptor as? WrappedPropertyDescriptor)?.isBound() == true) {\n             return generateStubBySymbol(symbol, symbol.descriptor)\n         }\n-        val descriptor = if (symbol.descriptor is WrappedDeclarationDescriptor<*> && symbol.signature != null)\n-            findDescriptorBySignature(symbol.signature!!)\n+        val signature = symbol.signature\n+        signature ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")", "msg": "```suggestion\r\n            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")\r\n```"}
{"patch": "@@ -76,8 +76,10 @@ class DeclarationStubGenerator(\n         if (symbol is IrFieldSymbol && (symbol.descriptor as? WrappedPropertyDescriptor)?.isBound() == true) {\n             return generateStubBySymbol(symbol, symbol.descriptor)\n         }\n+        val signature = symbol.signature\n+            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")", "msg": "I mean \r\n`findDescriptorBySignature(symbol.signature\r\n            ?: error(\"Symbol is not public API. Expected signature for symbol: ${symbol.descriptor}\")`"}
{"patch": "@@ -143,6 +143,7 @@ internal fun IrFunction.shouldContainSuspendMarkers(): Boolean = !isInvokeSuspen\n         // These are tail-call bridges and do not require any bytecode modifications.\n         origin != IrDeclarationOrigin.FUNCTION_FOR_DEFAULT_PARAMETER &&\n         origin != JvmLoweredDeclarationOrigin.JVM_OVERLOADS_WRAPPER &&\n+        origin != JvmLoweredDeclarationOrigin.JVM_STATIC_WRAPPER &&", "msg": "Something tells me it might be a good time to introduce a `Set` of origins here"}
{"patch": "@@ -109,12 +109,16 @@ fun InstructionAdapter.genKOutputMethodCall(\n }\n \n internal fun InstructionAdapter.buildInternalConstructorDesc(\n+    descVar: Int,\n     propsStartVar: Int,\n     bitMaskBase: Int,\n     codegen: ClassBodyCodegen,\n     args: List<SerializableProperty>\n ): String {\n     val constructorDesc = StringBuilder(\"(\")\n+    load(descVar, descType)\n+    constructorDesc.append(\"Lkotlinx/serialization/descriptors/$SERIAL_DESCRIPTOR_CLASS;\")", "msg": "It's better to use `descType.descriptor` here instead of hardcoded string"}
{"patch": "@@ -31,10 +31,17 @@ import org.jetbrains.kotlin.resolve.descriptorUtil.module\n import org.jetbrains.kotlinx.serialization.compiler.backend.common.*\n import org.jetbrains.kotlinx.serialization.compiler.diagnostic.serializableAnnotationIsUseless\n import org.jetbrains.kotlinx.serialization.compiler.resolve.*\n+import org.jetbrains.kotlinx.serialization.compiler.resolve.SerialEntityNames.SERIAL_DESCRIPTOR_CLASS\n import org.jetbrains.org.objectweb.asm.Label\n import org.jetbrains.org.objectweb.asm.Type\n import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n \n+\n+internal const val USE_CHECK_OPTIMIZATION = false", "msg": "Am I right that this is just a stub for future runtime version loading?"}
{"patch": "@@ -31,10 +31,17 @@ import org.jetbrains.kotlin.resolve.descriptorUtil.module\n import org.jetbrains.kotlinx.serialization.compiler.backend.common.*\n import org.jetbrains.kotlinx.serialization.compiler.diagnostic.serializableAnnotationIsUseless\n import org.jetbrains.kotlinx.serialization.compiler.resolve.*\n+import org.jetbrains.kotlinx.serialization.compiler.resolve.SerialEntityNames.SERIAL_DESCRIPTOR_CLASS\n import org.jetbrains.org.objectweb.asm.Label\n import org.jetbrains.org.objectweb.asm.Type\n import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n \n+\n+internal const val USE_CHECK_OPTIMIZATION = false\n+\n+internal const val PLUGIN_UTILS_LIBRARY_CLASS = \"PluginUtilsKt\"", "msg": "Better move it to file with calling conventions then (you're likely going to reuse them in ir plugin)"}
{"patch": "@@ -68,8 +68,8 @@ fun case_4(x: String?) {\n             break\n         }\n     }\n-    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String & kotlin.String?\")!>x<!>\n-    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String & kotlin.String?\")!>x<!>.length\n+    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>x<!>\n+    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>x<!>.<!INAPPLICABLE_CANDIDATE!>length<!>", "msg": "Ah, but this and below ones look like good refinements, i.e., can be part of 4th commit."}
{"patch": "@@ -515,14 +517,26 @@ class Kapt3GradleSubplugin @Inject internal constructor(private val registry: To\n \n     private fun maybeRegisterTransform(project: Project) {\n         if (!project.extensions.extraProperties.has(\"KaptStructureTransformAdded\")) {\n-            project.dependencies.registerTransform(StructureTransformAction::class.java) { transformSpec ->", "msg": "You can simplify this as:\r\n```\r\n   project.dependencies.registerTransform(if (...) StructureTransformAction::class.java else StructureTransformAction::class.java) { ... }\r\n```"}
{"patch": "@@ -19,6 +21,35 @@ const val CLASS_STRUCTURE_ARTIFACT_TYPE = \"class-structure\"\n private const val MODULE_INFO = \"module-info.class\"\n \n abstract class StructureTransformAction : TransformAction<TransformParameters.None> {\n+    @get:InputArtifact\n+    abstract val inputArtifact: Provider<FileSystemLocation>\n+\n+    override fun transform(outputs: TransformOutputs) {\n+        try {\n+            val input = inputArtifact.get().asFile\n+\n+            val data = if (input.isDirectory) {\n+                visitDirectory(input)\n+            } else {\n+                visitJar(input)\n+            }\n+\n+            val dataFile = outputs.file(\"output.bin\")\n+            data.saveTo(dataFile)", "msg": "Extract this to a method to share between 2 transforms."}
{"patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.gradle.fixtures\n+\n+import org.gradle.api.Transformer\n+import org.gradle.api.provider.Provider\n+import java.util.function.BiFunction\n+\n+class FakeGradleProvider<T>(private val v: (()-> T)?): Provider<T> {", "msg": "Maintaining this may be painful, I'd rather use Gradle `ProjectBuilder` to create `Project` instance and then to create providers. WDYT?"}
{"patch": "@@ -152,9 +183,10 @@ abstract class BasicWasmBoxTest(\n \n     private fun createPsiFiles(fileNames: List<String>): List<KtFile> = fileNames.map(this::createPsiFile)", "msg": "Some common things could be extracted from this class and BasicBoxTest, like createPsiFile and TestFileFactoryImpl"}
{"patch": "@@ -28,18 +29,25 @@ import org.jetbrains.kotlin.resolve.BindingContext\n import org.jetbrains.kotlin.resolve.DescriptorUtils\n import org.jetbrains.kotlin.resolve.descriptorUtil.getSuperClassOrAny\n import org.jetbrains.kotlin.resolve.descriptorUtil.module\n+import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin\n import org.jetbrains.kotlinx.serialization.compiler.backend.common.*\n+import org.jetbrains.kotlinx.serialization.compiler.diagnostic.VersionReader\n import org.jetbrains.kotlinx.serialization.compiler.diagnostic.serializableAnnotationIsUseless\n import org.jetbrains.kotlinx.serialization.compiler.resolve.*\n import org.jetbrains.org.objectweb.asm.Label\n+import org.jetbrains.org.objectweb.asm.Opcodes\n import org.jetbrains.org.objectweb.asm.Type\n import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter\n \n+val fieldMissingOptimizationVersion = ApiVersion.parse(\"1.1\")!!", "msg": "This val can also be a member of `SerializableCodegenImpl`, no need to be top-level for it"}
{"patch": "@@ -68,6 +68,8 @@ object SerialEntityNames {\n     const val SERIAL_DESCRIPTOR_CLASS_IMPL = \"PluginGeneratedSerialDescriptor\"\n     const val SERIAL_DESCRIPTOR_FOR_ENUM = \"EnumDescriptor\"\n \n+    const val PLUGIN_UTILS_FILE = \"PluginUtils\"", "msg": "Sorry for late notice, but that just came into my mind: by calling this file 'utils', we risk ending up with long file with a lot of unrelated stuff. I'd suggest avoid such technique and name files using logical groups, e.g. 'PluginExceptions'"}
{"patch": "@@ -408,4 +408,18 @@ class Strings {\n         assertPrints(matchDetails(inputString, toFind, 2), \"Searching for 'ever' in 'Never ever give up' starting at position 2: Found at 6\")\n         assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n     }\n+\n+    @Sample\n+    fun last() {\n+        val str0 = \"Sample String 0\"\n+        val str1 = \"\"\n+        assertEquals('0', str0.last())\n+        assertEquals('g', str0.last( {it.isLetter()} ))", "msg": "- Use `assertPrints(actualValue, expectedString)` instead of `assertEquals`\r\n- The trailing lambda should be formatted as `str0.last { it.isLetter() }`"}
{"patch": "@@ -408,4 +408,18 @@ class Strings {\n         assertPrints(matchDetails(inputString, toFind, 2), \"Searching for 'ever' in 'Never ever give up' starting at position 2: Found at 6\")\n         assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n     }\n+\n+    @Sample\n+    fun last() {\n+        val str0 = \"Sample String 0\"\n+        val str1 = \"\"\n+        assertEquals('0', str0.last())\n+        assertEquals('g', str0.last( {it.isLetter()} ))\n+        assertFailsWith<NoSuchElementException>{\n+            str1.last()\n+        }\n+        assertFailsWith<NoSuchElementException>{\n+            str0.last( {it > 'z'} )\n+        }", "msg": "Please place the entire `assertFailsWith` call on the single line, otherwise it won't be correctly formatted after a conversion to a runnable sample."}
{"patch": "@@ -123,5 +123,4 @@ class Chars {\n         assertFalse('a'.equals('A', false))\n         assertTrue('a'.equals('A', true))\n     }\n-\n-}\n\\ No newline at end of file\n+}", "msg": "Better to revert unrelated changes"}
{"patch": "@@ -777,6 +777,26 @@ public inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>\n     this.keys.removeAll(keys)\n }\n \n+/**\n+ * Returns a map containing the keys of `this` map and the [other] map. Where there are values for a certain key the transform function is\n+ * applied. If there is a value for only key in a map then the value of the corresponding entry is taken.\n+ */\n+public inline fun <K, V>Map<out K, V>.merge(other: Map<out K, V>, transform: (a: V, b: V) -> V): Map<K, V> {", "msg": "The name has to be discussed. Currently, when you use JDK8 or higher, there's already [MutableMap.merge](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-) function available coming from JDK. It has the similar signature, but applies the merge operation in-place.\r\nIt would be very confusing to have two `merge` operations on a mutable map, where one merges in-place and the other returns a new map."}
{"patch": "@@ -1,5 +1,3 @@\n-// IGNORE_BACKEND_FIR: JVM_IR\n-", "msg": "@mglukhikh Just in case, improving type info around `try` expression can unmute a bb test."}
{"patch": "@@ -167,9 +167,14 @@ class ClasspathAnalyzerTest {\n         return writer.toByteArray()\n     }\n }\n+class ProvideInput<FileSystemLocation>(val input: File) : Callable<FileSystemLocation> {\n+    override fun call(): FileSystemLocation {\n+        return FakeGradleRegularFile(input) as FileSystemLocation\n+    }\n+}\n \n class StructureTransformTestAction(val input: File) : StructureTransformAction() {\n-    override val inputArtifact: File = input\n+    override val inputArtifact: Provider<FileSystemLocation> = ProjectBuilder.builder().build().provider(ProvideInput(input))", "msg": "Why not create Provider<RegularFile> directly?"}
{"patch": "@@ -408,4 +408,17 @@ class Strings {\n         assertPrints(matchDetails(inputString, toFind, 2), \"Searching for 'ever' in 'Never ever give up' starting at position 2: Found at 6\")\n         assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n     }\n+\n+    @Sample\n+    fun last() {\n+        val string = \"Kotlin 1.4.0\"\n+        assertPrints(string.last(), \"0\")\n+        assertPrints(string.last { it.isLetter() }, \"n\")\n+        assertFails { string.last { it > 'z' } }\n+        assertPrints(string.lastOrNull { it > 'z' }, \"null\")", "msg": "Better to swap `assertFais` and `assertPrints`, because the former will be commented out."}
{"patch": "@@ -382,7 +382,9 @@ internal class IndexedGetLoopHeader(\n         with(builder) {\n             // loopVariable = objectVariable[inductionVariable]\n             val indexedGetFun = with(headerInfo.expressionHandler) { headerInfo.objectVariable.type.getFunction }\n-            val get = irCall(indexedGetFun.symbol).apply {\n+            // Making sure that expression type has type of the variable when it exists.\n+            // Return type of get function can be a type parameter (for example Array<T>::get) which is not a subtype of loopVariable type.\n+            val get = irCall(indexedGetFun.symbol, type = loopVariable?.type ?: indexedGetFun.returnType).apply {", "msg": "@punzki could you take a look?\r\n\r\nI think this used to work in JVM because bytecode generator is able to fix type mismatch by inserting casts even without explicit IrTypeOperator. I'm not sure if we should rely on this in IR for common lowerings. WebAssembly backend, I'm working on, never encountered a situation where initialization expression type is not a subtype of variable type other than in this case. Do you mind if I make type conversion explicit in this case? Type difference between generic function return type and call expression type is typically generated by frontend, so I guess it is OK."}
{"patch": "@@ -404,7 +404,9 @@ object AbstractTypeChecker {\n \n         if (subType.isStubType() || superType.isStubType()) return isStubTypeEqualsToAnything\n \n-        val superTypeCaptured = superType.asCapturedType()\n+        // superType might be a definitely notNull type (see KT-42824)\n+        val superOriginalType = superType.asDefinitelyNotNullType()?.original() ?: superType", "msg": "I believe we should propagate `!!`-nullability inside `lowerType`, similar to what you did in https://github.com/JetBrains/kotlin/pull/3869. So, subtyping check `T <: Captured(in Foo)!!` will be transformed into `T <: Foo!!`, otherwise we'll just lose information about nullability here"}
{"patch": "@@ -5,7 +5,18 @@\n \n package org.jetbrains.kotlin.fir.analysis.cfa\n \n+import org.jetbrains.kotlin.fir.analysis.checkers.resolvedSymbol", "msg": "Commit message: to perform aN interprocedural analysis to existING CFA"}
{"patch": "@@ -12,12 +12,17 @@ import kotlin.reflect.KClass\n class CheckersConfigurator {\n     private val registeredAliases: MutableMap<KClass<*>, String> = LinkedHashMap()\n     private val additionalCheckers: MutableMap<String, String> = LinkedHashMap()\n+    private val typeArguments: MutableMap<KClass<*>, String> = mutableMapOf()\n \n     inline fun <reified T : FirElement> alias(name: String) {\n         alias(T::class, name)\n     }\n \n     fun alias(kClass: KClass<out FirElement>, name: String) {\n+        if (kClass.typeParameters.isNotEmpty()) {\n+            val typeArgument = kClass.typeParameters.joinToString(\", \", \"<\", \">\") { \"*\" }", "msg": "It's better to use named arguments here"}
{"patch": "@@ -323,3 +324,9 @@ fun Modality.toToken(): KtModifierKeywordToken = when (this) {\n \n val FirFunctionCall.isIterator\n     get() = this.calleeReference.name.asString() == \"<iterator>\"\n+\n+/**\n+ * Returns resolved symbol by reference\n+ */\n+val FirReference.resolvedSymbol", "msg": "There is already exists `fun FirReference.getResolvedSymbolOfNameReference(): FirBasedSymbol<*>?` in `FirUtils.kt`\r\n\r\nAlso please avoid using implicit return types for public properties and functions"}
{"patch": "@@ -1,8 +1,4 @@\n // FILE: test/CallableDescriptor.java\n-// IGNORE_BACKEND_FIR: JVM_IR\n-// Here FIR adds implicit NOT_NULL cast for `origin`, resulting in an assertion being added,\n-// which is the correct (yet mismatching) behavior, according to https://youtrack.jetbrains.com/issue/KT-35656\n-", "msg": "Duh, I'm removing my own comments. \ud83e\udd26  Well, on the bright side, at least now we match with JVM_IR behavior."}
{"patch": "@@ -239,10 +239,6 @@ open class KotlinPlatformAndroidPlugin : KotlinPlatformImplementationPluginBase(\n         super.apply(project)\n     }\n \n-    override fun configurationsForCommonModuleDependency(project: Project): List<Configuration> =\n-        (project.configurations.findByName(\"api\"))?.let(::listOf)\n-            ?: super.configurationsForCommonModuleDependency(project) // older Android plugins don't have api/implementation configs", "msg": "The oldest AGP version used in integration test is 3.1.0(released in March 2018) , so I assume it is the oldest one KGP support, which should have api/implementation configs."}
{"patch": "@@ -153,6 +153,20 @@ abstract class BaseGradleIT {\n             return wrapper\n         }\n \n+        fun mightUpdateSettingsScript(wrapperVersion: String, settingsScript: File) {", "msg": "Rename to \"maybeUpdateSettingsScript\"?"}
{"patch": "@@ -153,6 +153,20 @@ abstract class BaseGradleIT {\n             return wrapper\n         }\n \n+        fun mightUpdateSettingsScript(wrapperVersion: String, settingsScript: File) {\n+            // enableFeaturePreview(\"GRADLE_METADATA\") is no longer needed when building with Gradle 5.4 or above\n+            if (GradleVersion.version(wrapperVersion) > GradleVersion.version(\"5.3\")) {", "msg": "Change to \"version>= 5.4\"."}
{"patch": "@@ -56,7 +56,7 @@ open class KotlinPlatformImplementationPluginBase(platformName: String) : Kotlin\n     private val commonProjects = arrayListOf<Project>()\n \n     protected open fun configurationsForCommonModuleDependency(project: Project): List<Configuration> =", "msg": "Make this one private."}
{"patch": "@@ -58,7 +58,11 @@ class Fir2IrTypeConverter(\n         StandardClassIds.Char to irBuiltIns.charType\n     )\n \n+    private val capturedTypeCache = mutableMapOf<ConeCapturedType, IrType>()\n+    private val capturedTypeStack = mutableSetOf<ConeCapturedType>()", "msg": "Not sure both these structures are needed.... Will do some experiments..."}
{"patch": "@@ -85,13 +88,12 @@ fun Collection<IrOverridableMember>.collectAndFilterRealOverrides(toSkip: (IrOve\n \n // TODO: use this implementation instead of any other\n fun IrSimpleFunction.resolveFakeOverride(allowAbstract: Boolean = false, toSkip: (IrSimpleFunction) -> Boolean = { false }): IrSimpleFunction? {\n-    val reals = collectRealOverrides(toSkip)\n     return if (allowAbstract) {\n+        val reals = collectRealOverrides(toSkip)\n         if (reals.isEmpty()) error(\"No real overrides for ${this.render()}\")\n         reals.first()\n     } else {\n-        reals\n-            .filter { it.modality != Modality.ABSTRACT }\n+        collectRealOverrides(toSkip, { function -> function.modality == Modality.ABSTRACT })", "msg": "why not `it`?"}
{"patch": "@@ -51,20 +52,28 @@ internal val IMPLEMENTATIONS: PlatformImplementations = run {\n     val version = getJavaVersion()\n     if (version >= 0x10008) {\n         try {\n-            return@run castToBaseType<PlatformImplementations>(Class.forName(\"kotlin.internal.jdk8.JDK8PlatformImplementations\").newInstance())\n-        } catch (e: ClassNotFoundException) { }\n+            return@run castToBaseType<PlatformImplementations>(\n+                Class.forName(\"kotlin.internal.jdk8.JDK8PlatformImplementations\").newInstance()\n+            )\n+        } catch (e: ClassNotFoundException) {\n+        }", "msg": "Please revert formatting changes unrelated to the code regions you have changed."}
{"patch": "@@ -47,17 +47,26 @@ internal abstract class AbstractPlatformRandom : Random() {\n     override fun nextBytes(array: ByteArray): ByteArray = array.also { impl.nextBytes(it) }\n }\n \n-internal class FallbackThreadLocalRandom : AbstractPlatformRandom() {\n+internal object FallbackThreadLocalRandom : AbstractPlatformRandom(), Serializable {\n+    private const val serialVersionUID = -727456608900724668L\n+\n     private val implStorage = object : ThreadLocal<java.util.Random>() {\n         override fun initialValue(): java.util.Random {\n             return java.util.Random()\n         }\n     }\n+\n     override val impl: java.util.Random\n         get() = implStorage.get()\n+\n+    private fun readResolve(): Any = FallbackThreadLocalRandom\n }\n \n-private class PlatformRandom(override val impl: java.util.Random) : AbstractPlatformRandom()\n+private class PlatformRandom(override val impl: java.util.Random) : AbstractPlatformRandom(), Serializable {\n+    companion object {", "msg": "Companion object with just a single private const should be private."}
{"patch": "@@ -29,13 +29,13 @@ internal open class JDK8PlatformImplementations : JDK7PlatformImplementations()\n     override fun getMatchResultNamedGroup(matchResult: MatchResult, name: String): MatchGroup? {\n         val matcher = matchResult as? Matcher ?: throw UnsupportedOperationException(\"Retrieving groups by name is not supported on this platform.\")\n \n-        val range = matcher.start(name)..matcher.end(name) - 1\n-        return if (range.start >= 0)\n+        val range = matcher.start(name) until matcher.end(name)\n+        return if (range.first >= 0) {\n             MatchGroup(matcher.group(name), range)\n-        else\n+        } else\n             null\n     }", "msg": "This change should be in a separate commit, or even better, in a separate PR."}
{"patch": "@@ -8,7 +8,7 @@ package kotlin.random.jdk8\n import java.util.concurrent.ThreadLocalRandom\n \n @Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\", \"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n-internal class PlatformThreadLocalRandom : kotlin.random.AbstractPlatformRandom() {\n+internal object PlatformThreadLocalRandom : kotlin.random.AbstractPlatformRandom() {", "msg": "I don't see much sense in transforming it to `object`. It is instantiated once and then is kept in a private property of `Random` companion object. So no need to have another instance where its reference is stored.\r\nSame for `FallbackThreadLocalRandom`"}
{"patch": "@@ -267,10 +267,12 @@ public abstract class Random {\n      *\n      * @sample samples.random.Randoms.defaultRandom\n      */\n-    companion object Default : Random() {\n-\n+    companion object Default : Random(), Serializable {\n+        private const val serialVersionUID = 6449517406788167720L", "msg": "I still don't get what bad can happen if we set `serialVersionUID = 1L` in all such classes?"}
{"patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package random\n+\n+import test.io.serializeAndDeserialize\n+import kotlin.random.Random\n+import kotlin.random.asJavaRandom\n+import kotlin.random.asKotlinRandom\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertSame\n+\n+class RandomJvmSerializationTest {", "msg": "After we settle with serialized representation and serialVersionUID, let's add some serialization stability tests.\r\nSomething like https://github.com/JetBrains/kotlin/blob/1.4.20/libraries/stdlib/jvm/test/collections/CollectionJVMTest.kt#L192-L207"}
{"patch": "@@ -13,5 +13,6 @@ internal actual fun defaultPlatformRandom(): Random =\n \n private val INV_2_26: Double = 2.0.pow(-26)\n private val INV_2_53: Double = 2.0.pow(-53)\n+\n internal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n-    hi26 * INV_2_26 + low27 * INV_2_53\n\\ No newline at end of file\n+    hi26 * INV_2_26 + low27 * INV_2_53", "msg": "Unrelated change"}
{"patch": "@@ -122,8 +123,10 @@ open class ConvertLambdaToReferenceIntention(textGetter: () -> String) : SelfTar\n         }\n \n         val lambdaValueParameterDescriptors = context[FUNCTION, lambdaExpression.functionLiteral]?.valueParameters ?: return false\n-        if (explicitReceiver is KtClassLiteralExpression\n-            && explicitReceiver.receiverExpression?.getCallableDescriptor() in lambdaValueParameterDescriptors\n+        if (explicitReceiver != null && explicitReceiver !is KtSimpleNameExpression &&\n+            explicitReceiver.anyDescendantOfType<KtSimpleNameExpression> {\n+                it.getResolvedCall(context)?.resultingDescriptor in lambdaValueParameterDescriptors\n+            }", "msg": "This whole `isConvertibleCallInLambda` function looks scary to me. I'm sure that it's possible to write it in a more simple way. And I'm a bit afraid that you change this scary function. I'd better appreciate the refactoring of this function. But since your code covers more cases I'll merge it"}
{"patch": "@@ -0,0 +1,11 @@\n+interface A {\n+    fun foo(): String = \"OK\"\n+}\n+\n+abstract class B : A {\n+    abstract override fun foo(): String\n+}\n+\n+abstract class C : B()\n+\n+fun box() = \"OK\"", "msg": "Let's change the test case a little bit to use the classes from the hierarchy. (If the classes aren't loaded at runtime, they are not verified by the JVM and thus may contain invalid bytecode, which the test wouldn't catch)\r\n```\r\ninterface A {\r\n    fun foo(): String = \"Fail\"\r\n}\r\n\r\nabstract class B : A {\r\n    abstract override fun foo(): String\r\n}\r\n\r\nabstract class C : B()\r\n\r\nclass D : C() {\r\n    override fun foo(): String = \"OK\"\r\n}\r\n\r\nfun box() = D().foo()\r\n```"}
{"patch": "@@ -351,6 +351,7 @@ open class DeepCopyIrTreeWithSymbols(\n             declaration.varargElementType?.remapType(),\n             declaration.isCrossinline,\n             declaration.isNoinline,\n+            declaration.isHidden,", "msg": "This was the bug. declaration.isAssignable was passed in the isHidden position."}
{"patch": "@@ -386,12 +405,14 @@ class Kapt3GradleSubplugin @Inject internal constructor(private val registry: To\n             project.logger.warn(\"'kapt.generateStubs' is not used by the 'kotlin-kapt' plugin\")\n         }\n \n+        // These option names must match those defined in `org.jetbrains.kotlin.kapt.cli.KaptCliOption`.\n         pluginOptions += SubpluginOption(\"useLightAnalysis\", \"${kaptExtension.useLightAnalysis}\")\n         pluginOptions += SubpluginOption(\"correctErrorTypes\", \"${kaptExtension.correctErrorTypes}\")\n         pluginOptions += SubpluginOption(\"dumpDefaultParameterValues\", \"${kaptExtension.dumpDefaultParameterValues}\")\n         pluginOptions += SubpluginOption(\"mapDiagnosticLocations\", \"${kaptExtension.mapDiagnosticLocations}\")\n-        pluginOptions += SubpluginOption(\"strictMode\", \"${kaptExtension.strictMode}\")\n+        pluginOptions += SubpluginOption(\"strictMode\", \"${kaptExtension.strictMode}\") // Currently doesn't match KaptCliOption, not sure if it's intended.", "msg": "Possible typo detected: Here this option name is `strictMode`; but in `KaptCliOption`, this option name is `strict`. (They were first introduced in https://github.com/JetBrains/kotlin/commit/c83581e6b8155c6d89da977be6e3cd4af30562e5.) // cc @yanex "}
{"patch": "@@ -70,11 +70,17 @@ class IncrementalProcessor(private val processor: Processor, private val kind: D\n     }\n \n     fun isUnableToRunIncrementally() = !kind.canRunIncrementally\n-    fun getGeneratedToSources() = dependencyCollector.value.getGeneratedToSources()\n-    fun getGeneratedToSourcesAll() = dependencyCollector.value.getGeneratedToSourcesAll()\n+\n+    /** Mapping fromm generated file to type that were used as originating elements. For aggregating APs types will be [null]. */", "msg": "Misspelling: from"}
{"patch": "@@ -197,7 +241,27 @@ object UnusedChecker : FirControlFlowChecker() {\n \n             val status = VariableStatus.READ\n             status.isRead = true\n-            return dataForNode.put(symbol, status)\n+            return update(dataForNode, symbol) { status }\n+        }\n+\n+        private fun update(\n+            info: PathAwareVariableStatusInfo,\n+            symbol: FirPropertySymbol,\n+            updater: (VariableStatus?) -> VariableStatus?,\n+        ): PathAwareVariableStatusInfo {\n+            var resultMap = persistentMapOf<EdgeLabel, VariableStatusInfo>()\n+            var changed = false\n+            for (label in info.keys) {", "msg": "Here also entry enumeration should be better"}
{"patch": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package random\n+\n+import test.io.deserializeFromHex\n+import test.io.serializeAndDeserialize\n+import kotlin.random.Random\n+import kotlin.random.asJavaRandom\n+import kotlin.random.asKotlinRandom\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertSame\n+import kotlin.test.assertTrue\n+\n+class RandomSerializationTest {\n+    @Test\n+    fun defaultIsSerializable() {\n+        val instance = Random\n+        assertSame(instance, serializeAndDeserialize(instance))\n+    }\n+\n+    private fun testPersistedDeserialization(hexValue: String, expected: Any) =\n+        assertEquals(expected = expected, actual = deserializeFromHex(hexValue))", "msg": "Please use `assertSame` here. Also the entire method `testPersistedDeserialization` can be inlined."}
{"patch": "@@ -164,21 +164,30 @@ class PostponedArgumentsAnalyzer(\n \n         val checkerSink: CheckerSink = CheckerSinkImpl(candidate)\n \n+        val lastExpression = lambda.atom.body?.statements?.lastOrNull() as? FirExpression\n         var hasExpressionInReturnArguments = false\n+        // Don't constraint for return expressions of lambda if it has Unit return type.", "msg": "Better to be added with https://github.com/JetBrains/kotlin/commit/def647c0941769e3f7e08ecf242174f74c626e80#diff-5fb4206d83fbcd3e7c827c3b12541010eaf8de08ed8dd2bd470b993cfc8760d9\r\n\r\nAnyway, this also indicates why `Unit` return needs a special handling."}
{"patch": "@@ -216,9 +216,12 @@ class FirControlFlowStatementsResolveTransformer(transformer: FirBodyResolveTran\n     ): CompositeTransformResult<FirStatement> {\n         if (elvisExpression.calleeReference is FirResolvedNamedReference) return elvisExpression.compose()\n         elvisExpression.transformAnnotations(transformer, data)\n-        elvisExpression.transformLhs(transformer, ResolutionMode.ContextDependent)\n+        val expectedArgumentType =\n+            if (data is ResolutionMode.WithExpectedType && data.expectedType !is FirImplicitTypeRef) data", "msg": "Not sure what makes things look questionable, but it wouldn't be a coincidence that top-down propagation of types (from explicit info of enclosing one to inner item) appears again at https://github.com/JetBrains/kotlin/pull/3968/commits/3815dca0a0298b3698a0ae1b911d8030de4266ac"}
{"patch": "@@ -290,7 +295,11 @@ public abstract class Random {\n \n         override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n         override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n-        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray = defaultRandom.nextBytes(array, fromIndex, toIndex)\n+        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray = defaultRandom.nextBytes(\n+            array,\n+            fromIndex,\n+            toIndex\n+        )", "msg": "This change is not related. Better to keep it consistent with the other function definitions."}
{"patch": "@@ -267,10 +268,14 @@ public abstract class Random {\n      *\n      * @sample samples.random.Randoms.defaultRandom\n      */\n-    companion object Default : Random() {\n+    companion object Default : Random(), Serializable {\n+        private const val serialVersionUID = 0L\n \n+        @Transient", "msg": "Ok, I think the variant with all transient fields and `readResolve` will do (without introducing a serialization surrogate). :+1:"}
{"patch": "@@ -68,9 +76,28 @@ class KlibMetadataSerializerExtension(\n         childSerializer: DescriptorSerializer\n     ) {\n         descriptorFileId(descriptor)?.let { proto.setExtension(KlibMetadataProtoBuf.functionFile, it) }\n+        descriptor.findKDoc()?.let { proto.setExtension(KlibMetadataProtoBuf.functionKdoc, it.render()) }", "msg": "IIUC, (secondary) constructors aren't supported (here and in other parts of the machinery)."}
{"patch": "@@ -0,0 +1,39 @@\n+// SKIP_TXT\n+// !DIAGNOSTICS: -UNUSED_PARAMETER\n+// !LANGUAGE: +NewInference\n+\n+fun main() {\n+    Configuration().commands {\n+        Command1 { <!UNRESOLVED_REFERENCE!>someService::execute<!> } // Overload resolution ambiguity. All these functions match.\n+        Command2 { <!UNRESOLVED_REFERENCE!>someService::execute<!> } // Overload resolution ambiguity. All these functions match.", "msg": "So, these two break `// FIR_IDENTICAL`, and indeed, these are `FirNamedReference` without pointing any target/candidate symbol. This will fail eventually if you compile this."}
{"patch": "@@ -1049,9 +1047,7 @@ class Fir2IrDeclarationStorage(\n                 val irParent = findIrParent(fir)\n                 val parentOrigin = (irParent as? IrDeclaration)?.origin ?: IrDeclarationOrigin.DEFINED\n                 val declarationOrigin = computeDeclarationOrigin(firFunctionSymbol, parentOrigin, irParent)\n-                createIrFunction(fir, irParent, origin = declarationOrigin).apply {\n-                    setAndModifyParent(irParent)", "msg": "These two changes are just clean-up while looking at `parent` setting. `createIrFunction` called `bindAndDeclareParameters` above, which set `parent` directly, which could be unified as `setAndModifyParent` call."}
{"patch": "@@ -8,6 +8,102 @@\n \n package kotlin.text\n \n+\n+/**\n+ * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n+ *\n+ * @sample samples.text.Chars.charFromCode\n+ */\n+@ExperimentalStdlibApi\n+@SinceKotlin(\"1.4\")\n+@kotlin.internal.LowPriorityInOverloadResolution // to not clash with Char constructor in js-ir", "msg": "Why does it help? Is it because these functions are in other package than the Char itself? "}
{"patch": "@@ -390,7 +399,7 @@ class Strings {\n     @Sample\n     fun map() {\n         val string = \"kotlin\"\n-        assertPrints(string.map { it.toUpperCase() }, \"[K, O, T, L, I, N]\")\n+        assertPrints(string.map { it.uppercaseChar() }, \"[K, O, T, L, I, N]\")", "msg": "It's not a good idea to use experimental API in samples"}
{"patch": "@@ -154,7 +163,7 @@ class Strings {\n         val string = \"bonne journ\u00e9e\"\n         // associate each character by the code of its upper case equivalent and transform the character to upper case\n         val result = mutableMapOf<Int, Char>()\n-        string.associateByTo(result, { char -> char.toUpperCase().toInt() }, { char -> char.toUpperCase() })\n+        string.associateByTo(result, { char -> char.uppercaseChar().toInt() }, { char -> char.uppercaseChar() })", "msg": "Revert"}
{"patch": "@@ -134,7 +143,7 @@ class Strings {\n     fun associateByWithValueTransform() {\n         val string = \"bonne journ\u00e9e\"\n         // associate each character by the code of its upper case equivalent and transform the character to upper case\n-        val result = string.associateBy({ char -> char.toUpperCase().toInt() }, { char -> char.toUpperCase() })\n+        val result = string.associateBy({ char -> char.uppercaseChar().toInt() }, { char -> char.uppercaseChar() })", "msg": "revert"}
{"patch": "@@ -523,7 +523,7 @@ class Collections {\n             assertPrints(numbers.joinToString(prefix = \"<\", postfix = \">\", separator = \"\u2022\"), \"<1\u20222\u20223\u20224\u20225\u20226>\")\n \n             val chars = charArrayOf('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q')\n-            assertPrints(chars.joinToString(limit = 5, truncated = \"...!\") { it.toUpperCase().toString() }, \"A, B, C, D, E, ...!\")\n+            assertPrints(chars.joinToString(limit = 5, truncated = \"...!\") { it.uppercaseChar().toString() }, \"A, B, C, D, E, ...!\")", "msg": "revert"}
{"patch": "@@ -475,7 +475,7 @@ class Collections {\n         fun distinctAndDistinctBy() {\n             val list = listOf('a', 'A', 'b', 'B', 'A', 'a')\n             assertPrints(list.distinct(), \"[a, A, b, B]\")\n-            assertPrints(list.distinctBy { it.toUpperCase() }, \"[a, b]\")\n+            assertPrints(list.distinctBy { it.uppercaseChar() }, \"[a, b]\")", "msg": "revert"}
{"patch": "@@ -75,53 +75,67 @@ class StringJVMTest {\n     }\n \n     @Test fun capitalize() {\n+        fun testCapitalize(expected: String, string: String) {\n+            assertEquals(expected, string.capitalize())\n+            assertEquals(expected, string.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() })\n+        }\n         // Case mapping that results in multiple characters (validating Character.toUpperCase was not used).\n         assertEquals(\"SS\u00df\u00df\", \"\u00df\u00df\u00df\".capitalize())\n+        assertEquals(\"Ss\u00df\u00df\", \"\u00df\u00df\u00df\".replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() })", "msg": "Note that with `uppercase[0] + uppercase(1).lowercase()` capitalize behavior changes a bit"}
{"patch": "@@ -588,14 +610,32 @@ public fun String.regionMatches(thisOffset: Int, other: String, otherOffset: Int\n /**\n  * Returns a copy of this string converted to lower case using the rules of the specified locale.\n  */\n+@OptIn(ExperimentalStdlibApi::class)\n+@kotlin.internal.InlineOnly\n+public inline fun String.toLowerCase(locale: java.util.Locale): String = lowercase(locale)\n+\n+/**\n+ * Returns a copy of this string converted to lower case using the rules of the specified locale.", "msg": "Add the note about one-to-many and add sample link"}
{"patch": "@@ -8,11 +8,65 @@ package kotlin.text\n // actually \\s is enough to match all whitespace, but \\xA0 added because of different regexp behavior of Rhino used in Selenium tests\n public actual fun Char.isWhitespace(): Boolean = toString().matches(\"[\\\\s\\\\xA0]\")\n \n+/**\n+ * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n+ *\n+ * This function performs one-to-one character mapping using case mapping information from the UnicodeData.txt file,\n+ * to support one-to-many character mapping use the [lowercase] function.\n+ * If this character has no mapping equivalent, the character itself is returned.\n+ *\n+ * @sample samples.text.Chars.lowercase\n+ */\n+@SinceKotlin(\"1.4\")\n+@ExperimentalStdlibApi\n+@kotlin.internal.InlineOnly\n+public actual inline fun Char.lowercaseChar(): Char = js(\"String.fromCharCode\")(toInt()).toLowerCase().charCodeAt(0).unsafeCast<Int>().toChar()", "msg": "The only case (`'\u0130'`) where `lowercase.length > 1` the first char (`'i'`) of the `lowercase` is the correct 1-to-1 mapping equivalent."}
{"patch": "@@ -92,14 +93,22 @@ private class FileClassLowering(val context: JvmBackendContext) : FileLoweringPa\n             else -> error(\"unknown kind of file entry: $fileEntry\")\n         }\n         val isMultifilePart = fileClassInfo.withJvmMultifileClass\n+\n+        val hasOnlyPrivateDeclarations = fileClassMembers\n+            .filterIsInstance<IrDeclarationWithVisibility>()\n+            .all { it.visibility == DescriptorVisibilities.PRIVATE }", "msg": "Please use `DescriptorVisibilities.isPrivate`"}
{"patch": "@@ -0,0 +1,8 @@\n+// WITH_RUNTIME\n+// IGNORE_BACKEND: JVM", "msg": "Please add explicit `// !LANGUAGE: -PackagePrivateFileClassesWithAllPrivateMembers` here for clarity. :)"}
{"patch": "@@ -12,7 +12,9 @@ package kotlin\n // TODO: KT-35100\n //@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n //public inline class Char internal constructor (val value: Int) : Comparable<Char> {\n-public class Char internal constructor(private val value: Int) : Comparable<Char> {\n+@OptIn(ExperimentalUnsignedTypes::class)\n+public class Char(code: UShort) : Comparable<Char> {", "msg": "We will need primary constructor with property when we will make Char inline class again.\r\n\r\nCould we keep primary constructor as is, and make UShort one secondary: \r\n```\r\npublic constructor(code: UShort) : this(chode.toInt())\r\n```\r\n?"}
{"patch": "@@ -144,6 +144,7 @@ enum class LanguageFeature(\n \n     AllowSealedInheritorsInDifferentFilesOfSamePackage(KOTLIN_1_5),\n     SealedInterfaces(KOTLIN_1_5),\n+    PackagePrivateFileClassesWithAllPrivateMembers(KOTLIN_1_5, defaultState = State.DISABLED),", "msg": "Could you please add a comment mentioning that this is about KT-10884? Otherwise looks good :)."}
{"patch": "@@ -36,7 +36,8 @@ val NULLABLE_ANNOTATIONS = listOf(\n     FqName(\"edu.umd.cs.findbugs.annotations.CheckForNull\"),\n     FqName(\"edu.umd.cs.findbugs.annotations.Nullable\"),\n     FqName(\"edu.umd.cs.findbugs.annotations.PossiblyNull\"),\n-    FqName(\"io.reactivex.annotations.Nullable\")\n+    FqName(\"io.reactivex.annotations.Nullable\"),\n+    FqName(\"io.reactivex.rxjava3.annotations.Nullable\")", "msg": "I'm not sure if it's possible to use trailing commas here? As in I'm not sure what kotlin language level the compiler code targets"}
{"patch": "@@ -766,47 +769,99 @@ open class FirDeclarationsResolveTransformer(transformer: FirBodyResolveTransfor\n         }\n     }\n \n+    private fun FirAnonymousFunction.addReturnBeforeLambdaResolution(): FirAnonymousFunction {", "msg": "Returning constant value seems unnecessary, please use `.also { }` construction on a call site\r\n"}
{"patch": "@@ -129,13 +130,21 @@ abstract class DataClassMembersGenerator(\n             if (!irClass.isInline) {\n                 +irIfThenReturnTrue(irEqeqeq(irThis(), irOther()))\n             }\n+\n             +irIfThenReturnFalse(irNotIs(irOther(), irType))\n             val otherWithCast = irTemporary(irAs(irOther(), irType), \"other_with_cast\")\n-            for (property in properties) {\n-                val arg1 = irGetProperty(irThis(), property)\n-                val arg2 = irGetProperty(irGet(irType, otherWithCast.symbol), property)\n-                +irIfThenReturnFalse(irNotEquals(arg1, arg2))\n-            }\n+\n+            properties\n+                .sortedBy {\n+                    if (it.backingField!!.type.isPrimitiveType()) 1\n+                    else 0", "msg": "Wouldn't it result in non-primitive fields being compared first, and primitives second? Shouldn't it be the opposite?"}
{"patch": "@@ -20,7 +20,7 @@ fun test_2(n: Int) {\n \n fun Int.bar(): Int {}\n \n-fun Int.baz(): Int\n+fun Int.baz(): Int {}", "msg": "Otherwise it would be `NON_MEMBER_FUNCTION_NO_BODY`, but I don't think the purpose of this test is to check that."}
{"patch": "@@ -59,7 +59,7 @@ class L {\n     fun B.foo() {}\n }\n \n-fun mest()\n+fun mest() {}", "msg": "Same here. Not sure what the intention was, though. As per the test name, `conflictingOverloads`, the only conflicting declaration is the class `mest` below."}
{"patch": "@@ -5,7 +5,7 @@ interface B\n class Clazz1 : A, B\n class Clazz2 : A, B\n \n-fun <K> select(x: K, y: K): K\n+<!NON_MEMBER_FUNCTION_NO_BODY!>fun <K> select(x: K, y: K): K<!>", "msg": "This and below are different. Actually, not trivial to _not_ introduce other errors while removing `NON_MEMBER_FUNCTION_NO_BODY` case."}
{"patch": "@@ -247,6 +247,30 @@ object LightTreePositioningStrategies {\n             return markElement(tree.operationReference(node) ?: node, startOffset, endOffset, tree, node)\n         }\n     }\n+\n+    val PARAMETER_DEFAULT_VALUE: LightTreePositioningStrategy = object : LightTreePositioningStrategy() {\n+        override fun mark(\n+            node: LighterASTNode,\n+            startOffset: Int,\n+            endOffset: Int,\n+            tree: FlyweightCapableTreeStructure<LighterASTNode>\n+        ): List<TextRange> {\n+            val defaultValueElement = tree.defaultValue(node) ?: node\n+            return markElement(defaultValueElement, startOffset, endOffset, tree, node)\n+        }\n+    }\n+\n+    val PARAMETER_VARARG_MODIFIER: LightTreePositioningStrategy = object : LightTreePositioningStrategy() {", "msg": "I accidentally used this for `USELESS_VARARG_ON_PARAMETER`, and... after https://github.com/JetBrains/kotlin/commit/40bec30393dea6462ba2548da88296a80d99f15a, this one shows the difference. It turned out that old FE reports that diagnostic on the parameter as a whole. Glad we can find this mistake earlier.\r\n\r\nThere are other diagnostics that will use this, so we can keep this. At least I can confirm it really marks `vararg` modifier. :)"}
{"patch": "@@ -6,5 +6,5 @@ fun <R> callIt(fn: () -> R): R = TODO()\n \n fun smartIt(p1: String?, p2: String?) {\n     p1 ?: callIt { TODO() }\n-    p1.<!INAPPLICABLE_CANDIDATE!>length<!> // smartcast\n+    p1.<!UNSAFE_CALL!>length<!> // smartcast", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44510"}
{"patch": "@@ -11,13 +11,13 @@ interface Order {\n fun foo(o: Any) {\n     val order = o as? Order\n     if (order?.expired ?: false) {\n-        order.<!INAPPLICABLE_CANDIDATE!>doSomething<!>()\n+        order.<!UNSAFE_CALL!>doSomething<!>()", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44511"}
{"patch": "@@ -5,7 +5,7 @@ fun bar(z: String?) = z\n fun foo(y: String?) {\n     var x: String? = \"\"\n     if (x != null) {\n-        bar(y?.let { x = null; it }).<!INAPPLICABLE_CANDIDATE!>length<!>\n+        bar(y?.let { x = null; it }).<!UNSAFE_CALL!>length<!>\n         x.length // Smart cast is not possible", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44512\r\n\r\nAlso one below (`withChangesToNull`)"}
{"patch": "@@ -18,7 +18,7 @@ fun kt6840_2(s: String?) {\n \n fun kt1635(s: String?) {\n     s?.hashCode()!!\n-    s.<!INAPPLICABLE_CANDIDATE!>hashCode<!>()\n+    s.<!UNSAFE_CALL!>hashCode<!>()", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44513"}
{"patch": "@@ -7,5 +7,5 @@ abstract class A(val s: String) {\n fun foo(o: String?): Int {\n     val a = object : A(o!!){}\n     a.bar()\n-    return o.<!INAPPLICABLE_CANDIDATE!>length<!>\n+    return o.<!UNSAFE_CALL!>length<!>", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44515"}
{"patch": "@@ -6,30 +6,30 @@ fun foo(x : String?, y : String?) {\n         y.length\n     }\n     else {\n-        x.<!INAPPLICABLE_CANDIDATE!>length<!>\n-        y.<!INAPPLICABLE_CANDIDATE!>length<!>\n+        x.<!UNSAFE_CALL!>length<!>\n+        y.<!UNSAFE_CALL!>length<!>\n     }\n     if (y != null || x == y) {\n-        x.<!INAPPLICABLE_CANDIDATE!>length<!>\n-        y.<!INAPPLICABLE_CANDIDATE!>length<!>\n+        x.<!UNSAFE_CALL!>length<!>\n+        y.<!UNSAFE_CALL!>length<!>\n     }\n     else {\n         // y == null but x != y\n-        x.<!INAPPLICABLE_CANDIDATE!>length<!>\n-        y.<!INAPPLICABLE_CANDIDATE!>length<!>\n+        x.<!UNSAFE_CALL!>length<!>", "msg": "See comment here: https://youtrack.jetbrains.com/issue/KT-41015#focus=Comments-27-4649573.0-0"}
{"patch": "@@ -4,10 +4,10 @@ public class X {\n     public fun fn(): Int {\n         if (x != null)\n             // Smartcast is not possible for variable properties\n-            return x.<!INAPPLICABLE_CANDIDATE!>length<!>\n+            return x.<!UNSAFE_CALL!>length<!>", "msg": "These should be `SMARTCAST_IMPOSSIBLE` and I left a TODO there.\r\n\r\nWill see/learn what _predictable_ nullability means at https://github.com/JetBrains/kotlin/commit/41ebfd025e6cc02cc5559b1a79d6335dd3831cb7 :) Any advices/suggestions are welcome!"}
{"patch": "@@ -7,9 +7,9 @@ operator fun <K> Container<K>.iterator(): Iterator<K> = null!!\n fun test() {\n     val container: Container<String>? = null\n     // Error\n-    container.<!INAPPLICABLE_CANDIDATE!>iterator<!>()\n+    container.<!UNSAFE_CALL!>iterator<!>()\n     // for extension iterator, this code compiles, but should not\n-    <!INAPPLICABLE_CANDIDATE!>for (s in container) {}<!>\n+    <!UNSAFE_CALL!>for (s in container) {}<!>", "msg": "For my own record, this should be rather `ITERATOR_ON_NULLABLE`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/controlStructures/ForLoopWithExtensionIteratorOnNullable.kt#L12"}
{"patch": "@@ -8,5 +8,5 @@ class It {\n }\n \n fun test() {\n-  <!INAPPLICABLE_CANDIDATE, INAPPLICABLE_CANDIDATE!>for (x in Coll()) {}<!>\n+  <!UNSAFE_CALL, UNSAFE_CALL!>for (x in Coll()) {}<!>", "msg": "For my own record, these should be rather `HAS_NEXT_FUNCTION_NONE_APPLICABLE` and `NEXT_NONE_APPLICABLE`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/controlStructures/forWithNullableIterator.kt#L11"}
{"patch": "@@ -8,5 +8,5 @@ fun Array<String>.length() : Int {\n }\n \n fun test(array : Array<String?>?) {\n-    array?.sure<Array<String?>>().<!INAPPLICABLE_CANDIDATE!>length<!>()\n+    array?.sure<Array<String?>>().<!UNSAFE_CALL!>length<!>()", "msg": "To be honest, no idea yet.\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/regressions/kt557.kt#L11\r\n\r\nAt DOT operator, the receiver has `TYPE_MISMATCH`, and the call is reported as `UNRESOLVED_REFERENCE_WRONG_RECEIVER` (well, because type mismatches, hm). We don't have a type checker that reports `TYPE_MISMATCH`, don't we?"}
{"patch": "@@ -87,7 +87,7 @@ fun test() {\n                 this@with.<!UNRESOLVED_REFERENCE!>yield<!>(\"\")\n \n                 yield2(\"\")\n-                this@with.<!INAPPLICABLE_CANDIDATE!>yield2<!>(\"\")\n+                this@with.<!UNSAFE_CALL!>yield2<!>(\"\")", "msg": "Similar to `kt557`, this should be `UNRESOLVED_REFERENCE_WRONG_RECEIVER`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/testsWithStdLib/coroutines/restrictSuspension/outerYield_1_3.kt#L90"}
{"patch": "@@ -8,7 +8,7 @@ fun <R> List<R>.a() {}\n \n fun test1(i: Int?) {\n     1.<!INAPPLICABLE_CANDIDATE!>a<!>()", "msg": "Just for the record, many errors in this file should be rather `UNRESOLVED_REFERENCE_WRONG_RECEIVER`: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/extensions/throwOutCandidatesByReceiver.kt#L10"}
{"patch": "@@ -11,7 +11,7 @@ class MyClass2 {}\n <!CONFLICTING_OVERLOADS!>fun MyClass2.component1()<!> = 1.3\n \n fun test(mc1: MyClass, mc2: MyClass2) {\n-    val (<!INAPPLICABLE_CANDIDATE!>a<!>, b) = <!COMPONENT_FUNCTION_MISSING!>mc1<!>\n+    val (a, b) = <!COMPONENT_FUNCTION_MISSING!>mc1<!>", "msg": "Perhaps, this is the only regression. In old FE, `a` has `OPERATOR_MODIFIER_REQUIRED` as well as `COMPONENT_FUNCTION_MISSING`. FIR should report unresolved error rather than inapplicable candidate. :\\\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/declarationChecks/MultiDeclarationErrors.kt#L14"}
{"patch": "@@ -4,7 +4,7 @@\n operator fun String.invoke(i: Int) {}\n \n fun foo(s: String?) {\n-    <!INAPPLICABLE_CANDIDATE!>s<!>(1)\n+    <!UNSAFE_CALL!>s<!>(1)\n \n-    <!INAPPLICABLE_CANDIDATE!>(s ?: null)(1)<!>\n+    <!UNSAFE_CALL!>(s ?: null)(1)<!>", "msg": "OI/NI behave differently: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/resolve/invoke/errors/unsafeCallWithInvoke.kt#L9\r\n\r\nAssuming NI is default in FIR, I think we should report `UNSAFE_IMPLICIT_INVOKE_CALL` here?"}
{"patch": "@@ -14,11 +14,11 @@ fun test() {\n }\n \n fun check() {\n-    [1, 2] <!INAPPLICABLE_CANDIDATE!>checkType<!> { <!INAPPLICABLE_CANDIDATE!>_<!><Array<Int>>() }\n-    [\"\"] <!INAPPLICABLE_CANDIDATE!>checkType<!> { <!INAPPLICABLE_CANDIDATE!>_<!><Array<String>>() }\n+    [1, 2] <!UNSAFE_CALL!>checkType<!> { <!INAPPLICABLE_CANDIDATE!>_<!><Array<Int>>() }", "msg": "There are many, many cases like this. Somehow `// !CHECK_TYPE` is not quite working well with FIR yet?"}
{"patch": "@@ -21,11 +21,11 @@ fun test() {\n     val platformJ = J.staticJ\n \n     platformNN[0]\n-    <!INAPPLICABLE_CANDIDATE!>platformN[0]<!>\n+    <!UNSAFE_CALL!>platformN[0]<!>\n     platformJ[0]\n \n     platformNN[0] = 1\n-    <!INAPPLICABLE_CANDIDATE!>platformN[0]  = 1<!>\n+    <!UNSAFE_CALL!>platformN[0]  = 1<!>", "msg": "For the record. In addition to `.`, this is another place where the diagnostic positioning matters: it should be array access."}
{"patch": "@@ -18,7 +18,7 @@ fun case_2(x: Class?) {\n     if (x?.fun_4()?.prop_8 != null) {\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.fun_4()\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.fun_4().<!INAPPLICABLE_CANDIDATE!>prop_8<!>\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.fun_4().<!UNSAFE_CALL!>prop_8<!>", "msg": "For the record, this should be `SMARTCAST_IMPOSSIBLE` instead."}
{"patch": "@@ -111,7 +111,7 @@ import contracts.*\n fun case_1(value_1: Any?, value_2: Int?) {\n     value_1.case_1(value_2)\n     <!AMBIGUITY!>println<!>(value_1.<!UNRESOLVED_REFERENCE!>length<!>)\n-    println(value_2.<!INAPPLICABLE_CANDIDATE!>inv<!>())\n+    println(value_2.<!UNSAFE_CALL!>inv<!>())", "msg": "The contract for the extension function `case_1` above is that, if returned, the given argument is not null. Thus, `value_2` should be not null here.\r\n\r\nMany other unsafe calls in this file are originated from such incorrect contract propagations."}
{"patch": "@@ -8,7 +8,7 @@\n  */\n fun case1() {\n     val x : Case1? = Case1()\n-    x.<!INAPPLICABLE_CANDIDATE!>x<!> = \"0\"\n+    x.x = \"0\"", "msg": "Note that this test intentionally adds `-UNSAFE_CALL` to focus on `val` reassignments."}
{"patch": "@@ -89,7 +89,7 @@ fun <T : String?> T.case_9() = this\n fun case_9() {\n     var x: Int? = 10\n     x = null\n-    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Int? & kotlin.Int?\")!>x<!>.<!INAPPLICABLE_CANDIDATE!>case_9<!>()\n+    <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Int? & kotlin.Int?\")!>x<!>.<!UNSAFE_CALL!>case_9<!>()", "msg": "After assigning `null`, it's expected to be resolved to:\r\n```\r\nfun <T: String?> T.case_9() = ...\r\n```\r\nabove, but I'd say this looks a lot like https://youtrack.jetbrains.com/issue/KT-41017"}
{"patch": "@@ -158,7 +158,7 @@ class Case11 {\n         if (y == case_12)\n             throw Exception()\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>y<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>y<!>.<!INAPPLICABLE_CANDIDATE!>length<!>\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.String?\")!>y<!>.<!UNSAFE_CALL!>length<!>", "msg": "For the record, this is also `SMARTCAST_IMPOSSIBLE`."}
{"patch": "@@ -63,7 +63,7 @@ fun case3() {\n  */\n fun case4(marker : Marker?) {\n     marker?.<!DEBUG_INFO_CALL(\"fqName: libPackage.Marker.foo; typeCall: function\")!>foo(y=1)<!>\n-    marker?.<!DEBUG_INFO_CALL(\"fqName: libPackage.Marker.invoke; typeCall: variable&invoke\")!>foo(x=1)<!><!INAPPLICABLE_CANDIDATE!>><!><!SYNTAX!><!>\n+    marker?.<!DEBUG_INFO_CALL(\"fqName: libPackage.Marker.invoke; typeCall: variable&invoke\")!>foo(x=1)<!><!UNSAFE_CALL!>><!><!SYNTAX!><!>", "msg": "This one and one more below are rather resolution errors. It should be `tests.foo`, instead of these `invoke`.\r\n\r\nThe original issue was: https://youtrack.jetbrains.com/issue/KT-37391"}
{"patch": "@@ -52,8 +52,8 @@ inline fun <reified T : CharSequence>case_4(x: Any?) {\n     (x as? T)!!\n     if (x is T?) {\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"T? & kotlin.Any?\")!>x<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"T? & kotlin.Any?\")!>x<!>.<!INAPPLICABLE_CANDIDATE!>length<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"T? & kotlin.Any?\")!>x<!>.<!INAPPLICABLE_CANDIDATE!>get<!>(0)\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"T? & kotlin.Any?\")!>x<!>.<!UNSAFE_CALL!>length<!>", "msg": "This (25) and below two (26, 27) share the same issue. Filed https://youtrack.jetbrains.com/issue/KT-44559"}
{"patch": "@@ -11,9 +11,9 @@ fun case_1(x: Class?) {\n     if (x!!.prop_8?.prop_8?.prop_8?.prop_8 != null) {\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.prop_8\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.prop_8.<!INAPPLICABLE_CANDIDATE!>prop_8<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.prop_8.<!INAPPLICABLE_CANDIDATE!>prop_8<!>.<!INAPPLICABLE_CANDIDATE!>prop_8<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.prop_8.<!INAPPLICABLE_CANDIDATE!>prop_8<!>.<!INAPPLICABLE_CANDIDATE!>prop_8<!>.<!INAPPLICABLE_CANDIDATE!>prop_8<!>\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"Class & Class?\")!>x<!>.prop_8.<!UNSAFE_CALL!>prop_8<!>", "msg": "This (30) and below (31) share the same issue. Filed https://youtrack.jetbrains.com/issue/KT-44560"}
{"patch": "@@ -19,13 +19,13 @@ fun case_1(x: Any?) {\n     val y = null\n     if (x != y) {\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any?\")!>x<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any?\")!>x<!>.<!INAPPLICABLE_CANDIDATE!>equals<!>(null)\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any?\")!>x<!>.<!UNSAFE_CALL!>equals<!>(null)", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-44561\r\n\r\nThere are many more variants in this file as well as: `pos/2.fir.kt` and `pos/7.fir.kt`. "}
{"patch": "@@ -411,6 +418,18 @@ class FirDefaultErrorMessages : DefaultErrorMessages.Extension {\n             map.put(LEAKED_IN_PLACE_LAMBDA, \"Leaked in-place lambda: {2}\", SYMBOL)\n             map.put(FirErrors.WRONG_IMPLIES_CONDITION, \"Wrong implies condition\")\n \n+            // Nullability\n+            map.put(\n+                UNSAFE_CALL,\n+                \"Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type {0}\",\n+                RENDER_TYPE\n+            )\n+            //map.put(\n+            //    UNSAFE_IMPLICIT_INVOKE_CALL,", "msg": "Forgot to mention this. I've tried this by adding a naive check that just checks an `invoke` function call, but then found several cases that require overrides check in general. There are a couple utils that are used at resolution and `fir2ir` regarding `invoke` lookup, and I guess it will require more refactoring, which I guess would be better to be a separate PR/commit."}
{"patch": "@@ -1420,6 +1423,20 @@ class ClassFileToSourceStubConverter(val kaptContext: KaptContextForStubGenerati\n         lineMappings.registerSignature(this, node)\n         return this\n     }\n+\n+    private fun fieldType(field: FieldNode, origin: JvmDeclarationOrigin?): Type {\n+        val signType = Type.getType(field.desc)\n+        return when (val declaration = origin?.element) {\n+            is KtProperty -> {\n+                val delegateType = kaptContext.bindingContext[BindingContext.EXPRESSION_TYPE_INFO, declaration.delegateExpression]?.type", "msg": "After this commit `convertKotlinType()` will be always used for properties with delegates.\r\nUsing it only for anonymous-type delegates would be safer, I think."}
{"patch": "@@ -1420,6 +1423,20 @@ class ClassFileToSourceStubConverter(val kaptContext: KaptContextForStubGenerati\n         lineMappings.registerSignature(this, node)\n         return this\n     }\n+\n+    private fun fieldType(field: FieldNode, origin: JvmDeclarationOrigin?): Type {", "msg": "Minor: we usually start function names with verbs, such as `get`."}
{"patch": "@@ -138,6 +138,8 @@ object FirErrors {\n     val CATCH_PARAMETER_WITH_DEFAULT_VALUE by error0<FirSourceElement, PsiElement>()\n     val REIFIED_TYPE_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n     val TYPE_PARAMETER_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n+    val GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()", "msg": "Instead of `PsiElement`, it's better to be specific: `KtTypeParameterList`: https://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/Errors.java#L178"}
{"patch": "@@ -138,6 +138,8 @@ object FirErrors {\n     val CATCH_PARAMETER_WITH_DEFAULT_VALUE by error0<FirSourceElement, PsiElement>()\n     val REIFIED_TYPE_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n     val TYPE_PARAMETER_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n+    val GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()\n+    val INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()", "msg": "Same for `PsiElement`. It's better to use `KtClassOrObject`: https://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/Errors.java#L179"}
{"patch": "@@ -138,6 +138,8 @@ object FirErrors {\n     val CATCH_PARAMETER_WITH_DEFAULT_VALUE by error0<FirSourceElement, PsiElement>()\n     val REIFIED_TYPE_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n     val TYPE_PARAMETER_IN_CATCH_CLAUSE by error0<FirSourceElement, PsiElement>()\n+    val GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()\n+    val INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS by error0<FirSourceElement, PsiElement>()", "msg": "@mglukhikh already mentioned below, but here, you should use `DECLARATION_NAME` as a positioning strategy."}
{"patch": "@@ -21,11 +21,29 @@ class ControlFlowWithEmptyBodyInspection : AbstractKotlinInspection() {\n         override fun visitIfExpression(expression: KtIfExpression) {\n             val then = expression.then\n             val elseKeyword = expression.elseKeyword\n-            if (then.isEmptyBodyOrNull() && (elseKeyword == null || then?.hasComments() != true)) {\n-                holder.registerProblem(expression, expression.ifKeyword)\n-            }\n-            if (elseKeyword != null && expression.`else`.isEmptyBodyOrNull()) {\n-                holder.registerProblem(expression, elseKeyword)\n+\n+            val thenEmpty = then?.isEmptyBody()\n+            val elseEmpty = expression.`else`?.isEmptyBody()\n+\n+            if (thenEmpty != false) {\n+                // if () { }", "msg": "This could be read as just a commented code - please wrap it in quotes like\r\n```\r\n`if () { }`\r\n```\r\nand/or add couple meaningful words (e.g. `case ...`)"}
{"patch": "@@ -96,10 +96,16 @@ object FirErrors {\n     val VAR_ANNOTATION_PARAMETER by error0<FirSourceElement, KtParameter>(SourceElementPositioningStrategies.VAL_OR_VAR_NODE)\n \n     // Exposed visibility group\n-    val EXPOSED_TYPEALIAS_EXPANDED_TYPE by error3<FirSourceElement, KtNamedDeclaration, FirEffectiveVisibility, FirMemberDeclaration, FirEffectiveVisibility>(SourceElementPositioningStrategies.DECLARATION_NAME)\n-    val EXPOSED_FUNCTION_RETURN_TYPE by error3<FirSourceElement, KtNamedDeclaration, FirEffectiveVisibility, FirMemberDeclaration, FirEffectiveVisibility>(SourceElementPositioningStrategies.DECLARATION_NAME)\n+    val EXPOSED_TYPEALIAS_EXPANDED_TYPE by error3<FirSourceElement, KtNamedDeclaration, FirEffectiveVisibility, FirMemberDeclaration, FirEffectiveVisibility>(", "msg": "If you want to refactor some files according to code style then please do it in separate commit. Otherwise it's hard to understand where are meaningful changes and where is a clenup"}
{"patch": "@@ -164,9 +172,13 @@ object FirErrors {\n     val USELESS_VARARG_ON_PARAMETER by warning0<FirSourceElement, KtParameter>()\n \n     // Properties & accessors\n-    val ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS by error2<FirSourceElement, KtModifierListOwner, FirMemberDeclaration, FirMemberDeclaration>(SourceElementPositioningStrategies.MODALITY_MODIFIER)\n+    val ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS by error2<FirSourceElement, KtModifierListOwner, FirMemberDeclaration, FirMemberDeclaration>(\n+        SourceElementPositioningStrategies.MODALITY_MODIFIER\n+    )\n     val PRIVATE_PROPERTY_IN_INTERFACE by error0<FirSourceElement, KtProperty>(SourceElementPositioningStrategies.VISIBILITY_MODIFIER)\n \n+    val WRONG_SETTER_PARAMETER_TYPE by error0<FirSourceElement, KtProperty>(SourceElementPositioningStrategies.DEFAULT)", "msg": "In FE 1.0 this diagnostic has two parameters with expected and actual setter parameter type. Please add them here too\r\n\r\nSee `Errors.WRONG_SETTER_PARAMETER_TYPE`"}
{"patch": "@@ -8,6 +8,7 @@ package org.jetbrains.kotlin.fir.analysis.diagnostics\n import com.intellij.psi.PsiElement\n import org.jetbrains.kotlin.diagnostics.*\n import org.jetbrains.kotlin.fir.FirSourceElement\n+import org.jetbrains.kotlin.psi.KtParameter", "msg": "Redundant import"}
{"patch": "@@ -2,7 +2,7 @@ import kotlin.reflect.KMutableProperty0\n import kotlin.reflect.KMutableProperty1\n \n class A {\n-    var bar: Int = 1\n+    var bar:Int = 1", "msg": "Missing space (and also redundant chage)"}
{"patch": "@@ -239,6 +239,9 @@ fun FirTypeRef.withReplacedConeType(\n     }\n }\n \n+fun FirTypeRef.withNullability(nullability: ConeNullability): FirTypeRef =", "msg": "Replacing nullability of `FirTypeRef` doesn't makes any sense, because type ref has no nullability. I rewrote changes in `transformElvisExpression` so they looks more idiomatic"}
{"patch": "@@ -0,0 +1,40 @@\n+// CORRECT_ERROR_TYPES\n+// STRICT\n+\n+//FILE: test/ClassRefAnnotation.java\n+\n+package test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.annotation.ElementType;\n+\n+@Target({ ElementType.TYPE, ElementType.METHOD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ClassRefAnnotation {\n+    Class<?>[] value();\n+}\n+\n+//FILE: a.kt", "msg": "I would also add tests with the `correctErrorTypes` option being enabled."}
{"patch": "@@ -10,12 +10,14 @@ import org.jetbrains.kotlin.idea.fir.api.fixes.KtQuickFixRegistrar\n import org.jetbrains.kotlin.idea.fir.api.fixes.KtQuickFixesList\n import org.jetbrains.kotlin.idea.fir.api.fixes.KtQuickFixesListBuilder\n import org.jetbrains.kotlin.idea.frontend.api.fir.diagnostics.KtFirDiagnostic\n+import org.jetbrains.kotlin.idea.quickfix.ChangeVariableMutabilityFix.Companion.VAR_OVERRIDDEN_BY_VAL_FACTORY\n import org.jetbrains.kotlin.idea.quickfix.fixes.ChangeTypeQuickFix\n import org.jetbrains.kotlin.lexer.KtTokens\n import org.jetbrains.kotlin.psi.KtModifierListOwner\n \n class MainKtQuickFixRegistrar : KtQuickFixRegistrar() {\n     private val modifiers = KtQuickFixesListBuilder.registerPsiQuickFix {\n+        // RemoveModifierFix", "msg": "If you need a visual separation of quickfixes blocks, it is better to create a new `KtQuickFixesList` like it's done now for `modifiers` and `overrides`. `KtQuickFixesList.createCombined` was created exactly for that reason :)"}
{"patch": "@@ -67,6 +72,8 @@ internal fun MethodNode.getParametersInfo(containingClass: ClassNode, isInnerCla\n \n         // @JvmOverloads constructors and ordinary methods don't have \"this\" local variable\n         name = name ?: localVariables.getOrNull(index + localVariableIndexOffset)?.name", "msg": "You can avoid additional assignment here:\r\n\r\n```\r\nname = name\r\n    ?: localVariables.getOrNull(index + localVariableIndexOffset)?.name\r\n    ?: originalDescriptor.valueParameters.getOrNull(index)?.name?.identifier\r\n    ?: \"p${index - startParameterIndex}\"\r\n\r\n```"}
{"patch": "@@ -1268,6 +1260,37 @@ class ClassFileToSourceStubConverter(val kaptContext: KaptContextForStubGenerati\n             return treeMaker.Select(typeExpression, treeMaker.name(\"class\"))\n         }\n \n+        fun unwrapArgumentExpression() =", "msg": "I suggest specifying return types for non-trivial functions."}
{"patch": "@@ -88,3 +93,26 @@ private val DEFAULT_USE_SITE_TARGETS: Set<AnnotationUseSiteTarget> =\n fun FirAnnotatedDeclaration.hasAnnotation(classId: ClassId): Boolean {\n     return annotations.any { it.toAnnotationClassId() == classId }\n }\n+\n+private val DEPRECATED_ANNOTATION = ClassId(FqName(\"kotlin\"), Name.identifier(\"Deprecated\"))\n+\n+fun FirAnnotatedDeclaration.deprecationStatus(): DeprecationLevel? {\n+    for (annotation in annotations) {\n+        // TODO: also check Kotlin version annotations\n+        if (annotation.toAnnotationClassId() != DEPRECATED_ANNOTATION) continue\n+\n+        val deprecatedClass = annotation.getCorrespondingClassSymbolOrNull(session)!!\n+        val deprecatedConstructor = deprecatedClass.fir.declarations.single { it is FirConstructor } as FirConstructor\n+        val (_ /*message*/, _ /*replaceWith*/, level) = annotation.argumentMapping?.let { mapping ->", "msg": "That's not actually correct because annotation arguments are resolved in the same transformer as function calls."}
{"patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis.checkers.declaration\n+\n+import org.jetbrains.kotlin.descriptors.ClassKind\n+import org.jetbrains.kotlin.descriptors.Modality\n+import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.DiagnosticReporter\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.reportOn\n+import org.jetbrains.kotlin.fir.declarations.FirCallableMemberDeclaration\n+import org.jetbrains.kotlin.fir.declarations.FirRegularClass\n+import org.jetbrains.kotlin.fir.declarations.modality\n+\n+object FirOpenMemberChecker : FirRegularClassChecker() {", "msg": "Same here. You need to extend `FirClassChecker` instead, in order to visit `declaration: FirClass<*>`. It looks like member objects are visited/checked for now."}
{"patch": "@@ -1017,16 +1017,15 @@ class DeclarationsConverter(\n                                 it.containingClassAttr = lookupTag\n                             }\n                         }\n-                    this.setter =\n-                        if (isVar) {\n-                            convertedAccessors.find { it.isSetter }\n-                                ?: FirDefaultPropertySetter(\n-                                    null, session, FirDeclarationOrigin.Source, returnType, propertyVisibility\n-                                ).also {\n-                                    currentDispatchReceiverType()?.lookupTag?.let { lookupTag ->\n-                                        it.containingClassAttr = lookupTag\n-                                    }\n+                    this.setter = convertedAccessors.find { it.isSetter }", "msg": "Minor, but isn't it still worth leaving some comments here (and corresponding part in `RawFirBuilder`) that we still need to build a setter for `val` to report `VAL_WITH_SETTER`?"}
{"patch": "@@ -123,3 +126,6 @@ internal fun checkPropertyInitializer(\n private val FirProperty.hasAccessorImplementation: Boolean\n     get() = (getter !is FirDefaultPropertyAccessor && getter?.hasBody == true) ||\n             (setter !is FirDefaultPropertyAccessor && setter?.hasBody == true)\n+\n+\n+internal fun FirClass<*>.canHaveOpenMembers(): Boolean = modality() != Modality.FINAL || classKind == ClassKind.ENUM_CLASS", "msg": "Nit: This could be `val` since no parameter/context is needed."}
{"patch": "@@ -485,18 +618,45 @@ interface IrBuilderExtension {\n         return defaultsMap + extractDefaultValuesFromConstructor(irClass.getSuperClassNotAny())\n     }\n \n-    fun buildInitializersRemapping(irClass: IrClass): (IrField) -> IrExpression? {\n+    /*\n+    Creates an initializer adapter function that can replaces IR expressions of getting constructor parameter value by some other expression.\n+    Also adapter may replaces IR expression of getting `this` value by another expression.", "msg": "```suggestion\r\n    Also adapter may replace IR expression of getting `this` value by another expression.\r\n```"}
{"patch": "@@ -485,18 +618,45 @@ interface IrBuilderExtension {\n         return defaultsMap + extractDefaultValuesFromConstructor(irClass.getSuperClassNotAny())\n     }\n \n-    fun buildInitializersRemapping(irClass: IrClass): (IrField) -> IrExpression? {\n+    /*\n+    Creates an initializer adapter function that can replaces IR expressions of getting constructor parameter value by some other expression.", "msg": "```suggestion\r\n    Creates an initializer adapter function that can replace IR expressions of getting constructor parameter value by some other expression.\r\n```"}
{"patch": "@@ -93,6 +96,18 @@ public open class $progression\n \n     override fun toString(): String = ${\"if (step > 0) \\\"\\$first..\\$last step \\$step\\\" else \\\"\\$first downTo \\$last step \\${-step}\\\"\"}\n \n+    override val size: Int\n+        get() = $sizeBody\n+\n+    override fun contains(@Suppress(\"PARAMETER_NAME_CHANGED_ON_OVERRIDE\") /* for the backward compatibility with old names */ value: $t): Boolean = when {\n+        this.isEmpty() -> false\n+        step > 0 && value >= first && value <= last -> (value - first) % step == $zero\n+        step < 0 && value <= first && value >= last -> (first - value) % (-step) == $zero\n+        else -> false\n+    }\n+    \n+    override fun containsAll(elements: Collection<$t>): Boolean = if (this.isEmpty()) elements.isEmpty() else elements.all { it in this }", "msg": "Due to @UnsafeVariance we cannot trust `elements` collection element static type here. For example, try casting a progression to `Collection<Any>` and call `containsAll(listOf(\"x\"))` on that collection.\r\nTo avoid this problem, cast elements to `Collection<*>` and work only with the result further in the body of `containsAll`."}
{"patch": "@@ -49,6 +49,9 @@ class GenerateProgressions(out: PrintWriter) : BuiltInsSourceGenerator(out) {\n                 \"        if (isEmpty()) -1 else (31 * (31 * ${hashLong(\"first\")} + ${hashLong(\"last\")}) + ${hashLong(\"step\")}).toInt()\"\n         }\n \n+        val sizeBody = \"if (isEmpty()) 0 else \" +\n+                \"(last - first) / step + 1\".let { if (kind == LONG) \"($it).toIntExactOrNull() ?: Int.MAX_VALUE\" else it }", "msg": "Potential overflow for ranges like `-1..Int.MAX_VALUE`.\nAlso let's avoid boxing to a nullable Int where possible."}
{"patch": "@@ -513,6 +513,14 @@ class UnsignedRangeGenerator(val type: UnsignedType, out: PrintWriter) : BuiltIn\n         fun hashCodeConversion(name: String, isSigned: Boolean = false) =\n             if (type == UnsignedType.ULONG) \"($name xor ($name ${if (isSigned) \"u\" else \"\"}shr 32))\" else name\n \n+        val sizeBody = \"\"\"\n+            when {\n+              isEmpty() -> 0UL\n+              step > 0 -> (last - first) / step.toULong() + 1UL", "msg": "Potential overflow for a range `0UL..ULong.MAX_VALUE`"}
{"patch": "@@ -55,11 +55,15 @@ class KtQuickFixesListBuilder private constructor() {\n     @OptIn(PrivateForInline::class)\n     private val quickFixes = mutableMapOf<KClass<out KtDiagnosticWithPsi<*>>, MutableList<HLQuickFixFactory>>()\n \n+    @Suppress(\"NOTHING_TO_INLINE\")", "msg": "Why not removing `inline` modifier instead? :)"}
{"patch": "@@ -116,14 +116,14 @@ class QuickFixRegistrar : QuickFixContributor {\n         USELESS_ELVIS.registerFactory(RemoveUselessElvisFix)\n         USELESS_ELVIS_RIGHT_IS_NULL.registerFactory(RemoveUselessElvisFix)\n \n-        val removeRedundantModifierFactory = RemoveModifierFix.createRemoveModifierFactory(true)\n+        val removeRedundantModifierFactory = RemoveModifierFix.removeRedundantModifier", "msg": "Can be inlined too :)"}
{"patch": "@@ -26,6 +27,22 @@ class MainKtQuickFixRegistrar : KtQuickFixRegistrar() {\n                 isRedundant = true\n             )\n         )\n+\n+        val addAbstractModifierFactory = AddModifierFix.createFactory(KtTokens.ABSTRACT_KEYWORD)\n+        registerPsiQuickFixes(KtFirDiagnostic.NonAbstractFunctionWithNoBody::class, AddFunctionBodyFix, addAbstractModifierFactory)\n+\n+        val addAbstractToClassFactory = AddModifierFix.createFactory(KtTokens.ABSTRACT_KEYWORD, KtClassOrObject::class.java)\n+        val removeAbstractModifierFactory = RemoveModifierFix.createRemoveModifierFromListOwnerPsiBasedFactory(KtTokens.ABSTRACT_KEYWORD)", "msg": "Let's not mix up factories creation and registration. E.g, factories can be moved to `AddModifierFix`/`RemoveModifierFix` companions"}
{"patch": "@@ -71,14 +71,14 @@ object FirMemberPropertyChecker : FirRegularClassChecker() {\n                 reporter.reportOn(it, FirErrors.ABSTRACT_DELEGATED_PROPERTY, context)\n             }\n \n-            checkAccessor(property.getter, property.delegate) { src, _ ->\n-                reporter.reportOn(src, FirErrors.ABSTRACT_PROPERTY_WITH_GETTER, context)\n+            checkAccessor(property.getter, property.delegate) { src, _, hasCustomBody ->", "msg": "Maybe personal preference, but having `custom` sounds awkward. Just `hasBody`? If it's a default accessor, it won't have a body anyway."}
{"patch": "@@ -155,7 +155,7 @@ fun case_10() {\n     val x: Int\n     funWithExactlyOnceCallsInPlace outer@ {\n         funWithAtLeastOnceCallsInPlace {\n-            x = 42\n+            <!VAL_REASSIGNMENT!>x<!> = 42", "msg": "This is the only one that differs from FE 1.0 behavior, but I can't tell whether it's a false alarm or not. Due to the labeled return below, this lambda exits to outer, and thus won't be invoked multiple times. However, as the function name indicates, I guess the contract for the caller is that the lambda can be invoked _at least_ once, hence the event occurrence count for this variable would be `AT_LEAST_ONCE`, which also means this can be revisited.\r\n\r\nI don't think there is anything we can do regarding CFG/contract here. cc @demiurg906 "}
{"patch": "@@ -173,7 +174,10 @@ internal class NonReanalyzableDeclarationStructureElement(\n                 firFile,\n                 onDeclarationEnter = { firDeclaration ->\n                     when {\n-                        firDeclaration.isGeneratedDeclaration -> DiagnosticCollectorDeclarationAction.SKIP\n+                        firDeclaration.isGeneratedDeclaration &&", "msg": "Can we just use `SKIP_CURRENT_DECLARATION_AND_CHECK_NESTED` here? I believe this will let us skip the generated declaration itself (e.g., the anonymous object) but get to the real declarations inside (e.g., the nested class in the enum entry)."}
{"patch": "@@ -1,14 +1,22 @@\n-// FIR_IDENTICAL", "msg": "Note that technically they're identical, but somehow other tags with `{JVM}` bother."}
{"patch": "@@ -793,7 +793,10 @@ class RawFirBuilder(\n         override fun visitClassOrObject(classOrObject: KtClassOrObject, data: Unit): FirElement {\n             return withChildClassName(\n                 classOrObject.nameAsSafeName,\n-                classOrObject.isLocal || classOrObject.getStrictParentOfType<KtEnumEntry>() != null\n+                classOrObject.isLocal\n+                        // TODO: currently enum entry initializer is represented in FIR as an FirAnonymousObject. Because of this, all\n+                        //  nested declarations are now marked local. This causes the FirNestedClassChecker to ignore some invalid programs.", "msg": "Nit: perhaps point to https://youtrack.jetbrains.com/issue/KT-45115 ?"}
{"patch": "@@ -454,4 +454,12 @@ class Strings {\n         assertPrints(inputString0.replace('s', 'z'), \"Mizzizzippi\")\n         assertPrints(inputString1.replace(\"data\", \"information\"), \"Insufficient information for meaningful answer.\")\n     }\n+\n+    @Sample\n+    fun startsWith() {\n+        val string = \"Silly Goose Egg\";\n+        assertTrue(string.startsWith('S'));\n+        assertTrue(string.startsWith('s'));\n+        assertFails(string.startsWith('a');", "msg": "This should be `assertFalse`, not `assertFails`. Also, it appears you are missing a closing `)`"}
{"patch": "@@ -454,4 +454,12 @@ class Strings {\n         assertPrints(inputString0.replace('s', 'z'), \"Mizzizzippi\")\n         assertPrints(inputString1.replace(\"data\", \"information\"), \"Insufficient information for meaningful answer.\")\n     }\n+\n+    @Sample\n+    fun startsWith() {\n+        val string = \"Silly Goose Egg\";", "msg": "I don't believe any of these lines should end with a `;`"}
{"patch": "@@ -47,7 +45,10 @@ import org.jetbrains.kotlin.utils.addToStdlib.firstNotNullResult\n internal object FirReferenceResolveHelper {\n     fun FirResolvedTypeRef.toTargetSymbol(session: FirSession, symbolBuilder: KtSymbolByFirBuilder): KtSymbol? {\n \n-        val type = type as? ConeLookupTagBasedType\n+        val type = (\n+                if (this.delegatedTypeRef?.source?.kind == FirFakeSourceElementKind.ArrayTypeFromVarargParameter) type.arrayElementType()\n+                else type\n+                ) as? ConeLookupTagBasedType", "msg": "Let's get rid of this multiline cast by extracting this into a function :)"}
{"patch": "@@ -96,13 +101,24 @@ internal fun FirValueParameter.transformVarargTypeToArrayType() {\n }\n \n internal fun FirTypedDeclaration.transformTypeToArrayType() {\n+    val returnTypeRef = this.returnTypeRef\n+    require(returnTypeRef is FirResolvedTypeRef)\n+    // If the delegated type is already resolved, it means we have already created a resolved array type for this vararg type declaration.\n+    // This is because in the buildResolvedTypeRef call below, we set the delegated type ref to the previous (non-vararg) resolved type ref.\n+    if (returnTypeRef.delegatedTypeRef is FirResolvedTypeRef) return", "msg": "To be safer (and match with comments), I think it's good to double-check if `delegatedTypeRef`'s `source` is `ArrayTypeFromVarargParameter`."}
{"patch": "@@ -617,6 +618,13 @@ internal class InapplicableLateinitModifierImpl(\n     override val firDiagnostic: FirPsiDiagnostic<*> by weakRef(firDiagnostic)\n }\n \n+internal class VarargOutsideParenthesesImpl(\n+    firDiagnostic: FirPsiDiagnostic<*>,\n+    override val token: ValidityToken,\n+) : KtFirDiagnostic.VarargOutsideParentheses(), KtAbstractFirDiagnostic<PsiElement> {", "msg": "I wonder this could be more specific, i.e., `KtExpression` too."}
{"patch": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.", "msg": "Hm, all these newly added files still have old copyright notice?"}
{"patch": "@@ -92,10 +92,13 @@ class FakeOverrideGenerator(\n                     FirTypeScope::getDirectOverriddenFunctions,\n                     useSiteMemberScope,\n                 )\n+                if (updated) {", "msg": "Unfortunately this does not do what you probably expect. This is only a return from lambda, no more. It does not stop `processFunctionsByName` itself, sorry."}
{"patch": "@@ -147,7 +147,9 @@ object FirNotImplementedOverrideChecker : FirClassChecker() {\n             classScope.processFunctionsByName(name) {\n                 val declaration = it.fir\n                 if (declaration.matchesDataClassSyntheticMemberSignatures && declaration.modality != Modality.FINAL) {\n-                    contributedInSupertypes.putIfAbsent(declaration.name, declaration)\n+                    if (contributedInSupertypes.putIfAbsent(declaration.name, declaration) == null) {\n+                        return@processFunctionsByName", "msg": "Same problem as before"}
{"patch": "@@ -42,6 +42,119 @@ public inline class Duration internal constructor(internal val value: Double) :\n         /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */", "msg": "Can't figure out how to leave a comment to unchanged lines, leaving here, KDoc to Duration class:\r\n\r\n>To construct a duration use either the extension function toDuration, or the extension properties hours, minutes, seconds, and so on, available on Int, Long, and Double numeric types.\r\n\r\nWe should recommend using factories instead of extensions"}
{"patch": "@@ -42,6 +42,119 @@ public inline class Duration internal constructor(internal val value: Double) :\n         /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n         public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n             convertDurationUnit(value, sourceUnit, targetUnit)\n+\n+        /** Returns a [Duration] equal to this [Int] number of nanoseconds. */", "msg": "Here and everywhere below: \r\n\r\n`Returns a [Duration] equal to this [Int] number of ...`\r\n\r\nProbably should be \r\n`Returns a [Duration] equal to [value] number of ...`\r\nor\r\n`Returns a [Duration] equal to [Int] [value] number of ...`\r\n\r\n\r\nas we no longer have a receiver "}
{"patch": "@@ -34,6 +36,25 @@ class SerializableCompanionIrGenerator(\n     bindingContext: BindingContext\n ) : SerializableCompanionCodegen(irClass.descriptor, bindingContext), IrBuilderExtension {\n \n+    private val lazyDescriptor = irClass.module.findClassAcrossModuleDependencies(\n+        ClassId(FqName(\"kotlin\"), Name.identifier(\"Lazy\"))\n+    )!!\n+\n+    private val lazeSafeModeClassDescriptor = irClass.module.findClassAcrossModuleDependencies(", "msg": "```suggestion\r\n    private val lazySafeModeClassDescriptor = irClass.module.findClassAcrossModuleDependencies(\r\n```"}
{"patch": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis.checkers.declaration\n+\n+import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.DiagnosticReporter\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.reportOn\n+import org.jetbrains.kotlin.fir.declarations.FirRegularClass\n+import org.jetbrains.kotlin.fir.declarations.isInner\n+\n+object FirInnerClassInsideInlineClassChecker : FirRegularClassChecker() {", "msg": "I'd get rid of this checker and implemented its logic in `FirInlineClassDeclarationChecker`. \r\n"}
{"patch": "@@ -150,3 +151,21 @@ private val FirProperty.hasAccessorImplementation: Boolean\n \n \n internal val FirClass<*>.canHaveOpenMembers: Boolean get() = modality() != Modality.FINAL || classKind == ClassKind.ENUM_CLASS\n+\n+internal fun FirRegularClass.isInlineOrValueClass(): Boolean {\n+    if (this.classKind != ClassKind.CLASS) return false\n+\n+    val modifierList = with(FirModifierList) { source.getModifierList() }\n+    return isInline || modifierList?.modifiers?.any { it.token == KtTokens.VALUE_KEYWORD } == true\n+}\n+\n+internal fun FirRegularClass.getRealPrimaryConstructor() =\n+    declarations.firstOrNull { it is FirConstructor && it.isPrimary && it.source?.kind !is FirFakeSourceElementKind }\n+            as? FirConstructor\n+\n+internal fun FirRegularClass.getFirstPrimaryConstructorProperty(): FirProperty? {\n+    val parameter = getRealPrimaryConstructor()?.valueParameters?.firstOrNull() ?: return null", "msg": "When we call this function, primary constructor and its single parameter is already found. I think it's better to get rid of this function and unite this search with loop on class declarations."}
{"patch": "@@ -65,5 +65,14 @@ object FirMemberFunctionChecker : FirRegularClassChecker() {\n         }\n \n         checkExpectDeclarationVisibilityAndBody(function, source, modifierList, reporter, context)\n+", "msg": "I'd integrate this in `FirInlineClassDeclarationChecker`."}
{"patch": "@@ -65,5 +65,14 @@ object FirMemberFunctionChecker : FirRegularClassChecker() {\n         }\n \n         checkExpectDeclarationVisibilityAndBody(function, source, modifierList, reporter, context)\n+\n+        if (containingDeclaration.isInlineOrValueClass()) {\n+            val reservedFunctions = setOf(\"box\", \"unbox\", \"equals\", \"hashCode\")", "msg": "Also, please declare this as companion object property to avoid constant variable re-creation."}
{"patch": "@@ -106,6 +106,18 @@ object FirMemberPropertyChecker : FirRegularClassChecker() {\n                 }\n             }\n         }\n+", "msg": "I'd integrate this in `FirInlineClassDeclarationChecker`."}
{"patch": "@@ -0,0 +1,32 @@\n+value class BackingFields(val x: Int) {\n+    <!PROPERTY_WITH_BACKING_FIELD_INSIDE_INLINE_CLASS!>val y<!> = 0\n+    var z: String\n+        get() = \"\"\n+        set(value) {}\n+}\n+\n+class Val {\n+    operator fun getValue(thisRef: Any?, kProp: Any?) = 1\n+}\n+inline class DelegatedProp(val x: Int) {\n+    val testVal by <!DELEGATED_PROPERTY_INSIDE_INLINE_CLASS!>Val()<!>\n+}\n+\n+inline class ReversedMembers(val x: Int) {\n+    <!RESERVED_MEMBER_INSIDE_INLINE_CLASS{LT}!>fun <!RESERVED_MEMBER_INSIDE_INLINE_CLASS{PSI}!>box<!>() {}<!>", "msg": "DECLARATION_NAME light tree positioning strategy works erroneously here. I will fix this problem myself."}
{"patch": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir\n+\n+enum class BadNamedArgumentsTarget {", "msg": "Minor: The description can be in a property and returned in `toString()`, i.e.,\r\n```kt\r\nenum class BadNamedArgumentsTarget(val description: String) {\r\n  NON_KOTLIN_FUNCTION(\"non-Kotlin functions\"),\r\n...\r\n  override fun toString() = description\r\n}\r\n```"}
{"patch": "@@ -165,8 +165,8 @@ private class FirCallArgumentsProcessor(\n     }\n \n     private fun processNamedArgument(argument: FirExpression, name: Name) {\n-        if (!function.hasStableParameterNames) {\n-            addDiagnostic(NamedArgumentNotAllowed(argument, function))\n+        function.asBadForNamedArgumentTarget?.let {", "msg": "The value doesn't change for each argument, so you can make this a lazy property in the `FirCallArgumentsProcessor` class, e.g.:\r\n```kt\r\nval badForNamedArgumentTarget: BadForNamedArgumentTarget? by lazy = function.asBadForNamedArgumentTarget\r\n```"}
{"patch": "@@ -72,6 +72,21 @@ fun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? =\n     asserter.assertNotSame(message, illegal, actual)\n }\n \n+/** Asserts that [value] is [T], with an optional [message]. */\n+@SinceKotlin(\"1.4\")", "msg": "Now it's time for `SinceKotlin(\"1.5\")`  : )"}
{"patch": "@@ -72,6 +72,21 @@ fun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? =\n     asserter.assertNotSame(message, illegal, actual)\n }\n \n+/** Asserts that [value] is [T], with an optional [message]. */\n+@SinceKotlin(\"1.4\")\n+@InlineOnly\n+inline fun <reified T: Any> assertIs(value: Any, message: String? = null) {", "msg": "It would be valuable to support it for nullable type and value."}
{"patch": "@@ -72,6 +72,21 @@ fun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? =\n     asserter.assertNotSame(message, illegal, actual)\n }\n \n+/** Asserts that [value] is [T], with an optional [message]. */\n+@SinceKotlin(\"1.4\")\n+@InlineOnly\n+inline fun <reified T: Any> assertIs(value: Any, message: String? = null) {\n+    contract { returns() implies (value is T) }\n+    asserter.assertTrue({ messagePrefix(message) + \"Expected value to be of type <${T::class}>, actual <${value::class}>.\" }, value is T)", "msg": "`typeOf<T>()` provides more precise information about the type, especially its nullability."}
{"patch": "@@ -205,6 +205,28 @@ class BasicAssertionsTest {\n     fun testExpectFails() {\n         checkFailedAssertion { expect(1) { 2 } }\n     }\n+\n+    @Test\n+    fun testAssertIs() {\n+        val s: Any = \"test\"\n+        assertIs<String>(s)\n+        assertEquals(4, s.length)\n+    }\n+    \n+    @Test\n+    fun testAssertIsFails() {\n+        checkFailedAssertion { assertIs<Int>(\"test\") }", "msg": "Could you inspect the assertion returned by `checkFailedAssertion` and check that its message contains the information we expect?"}
{"patch": "@@ -72,6 +72,21 @@ fun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? =\n     asserter.assertNotSame(message, illegal, actual)\n }\n \n+/** Asserts that [value] is [T], with an optional [message]. */", "msg": "```suggestion\r\n/** Asserts that [value] is of type [T], with an optional [message]. */\r\n```\r\n\r\nAlso makes sense to add a note that due to type erasure the type check may be partial, e.g. `assertIs<List<String>>(value)` only checks for the class being `List` and doesn't check the type of elements because it's erased."}
{"patch": "@@ -72,6 +72,21 @@ fun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? =\n     asserter.assertNotSame(message, illegal, actual)\n }\n \n+/** Asserts that [value] is [T], with an optional [message]. */\n+@SinceKotlin(\"1.4\")\n+@InlineOnly\n+inline fun <reified T: Any> assertIs(value: Any, message: String? = null) {\n+    contract { returns() implies (value is T) }\n+    asserter.assertTrue({ messagePrefix(message) + \"Expected value to be of type <${T::class}>, actual <${value::class}>.\" }, value is T)\n+}\n+\n+/** Asserts that [value] !is [T], with an optional [message]. */", "msg": "```suggestion\r\n/** Asserts that [value] is not of type [T], with an optional [message]. */\r\n```"}
{"patch": "@@ -113,6 +113,7 @@ open class AddModifierFix(\n             AddModifierFix.createFactory(KtTokens.OPEN_KEYWORD, KtClassOrObject::class.java)\n         val addFinalToProperty: QuickFixesPsiBasedFactory<PsiElement> =\n             AddModifierFix.createFactory(KtTokens.FINAL_KEYWORD, KtProperty::class.java)\n+        val addInnerModifier = createFactory(KtTokens.INNER_KEYWORD)", "msg": "Nit: we should probably unify on one style here. Either put in types on the other lines or simplify the other lines as well (I prefer the latter)?"}
{"patch": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.analysis.checkers.declaration\n+\n+import org.jetbrains.kotlin.descriptors.ClassKind\n+import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.DiagnosticReporter\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.reportOn\n+import org.jetbrains.kotlin.fir.declarations.FirProperty\n+import org.jetbrains.kotlin.fir.declarations.FirRegularClass\n+import org.jetbrains.kotlin.lexer.KtTokens\n+\n+object FirConstValNotTopLevelOrObjectChecker : FirPropertyChecker() {", "msg": "General note: I would rename this to just `FirConstPropertyChecker` (will do myself) and add all other const checks in this checker (when ready)."}
{"patch": "@@ -99,6 +98,12 @@ private fun mapInapplicableCandidateError(\n \n     return when (rootCause) {\n         is VarargArgumentOutsideParentheses -> FirErrors.VARARG_OUTSIDE_PARENTHESES.on(rootCause.argument.source ?: source)\n+        is NonVarargSpread -> FirErrors.NON_VARARG_SPREAD.on(rootCause.argument.source?.getChild(KtTokens.MUL, depth = 1)!!)\n+        is ArgumentPassedTwice -> FirErrors.ARGUMENT_PASSED_TWICE.on(rootCause.argument.source ?: source)\n+        is TooManyArguments -> FirErrors.TOO_MANY_ARGUMENTS.on(source, rootCause.function)\n+        // TODO: current implementation seems to NoValueForParameter more often than FE1.0 for overloaded functions. We will need to", "msg": "Could you point out some changed examples?"}
{"patch": "@@ -4,6 +4,8 @@ package kt1940\n fun foo(i: Int) {}\n \n fun test() {\n-    <!INAPPLICABLE_CANDIDATE!>foo<!>(1, i = 2) //exception\n-    <!INAPPLICABLE_CANDIDATE!>foo<!>(i = 1, i = 2) //exception\n-}\n\\ No newline at end of file\n+    foo(1, <!ARGUMENT_PASSED_TWICE!>i<!> = 2) //exception\n+    foo(i = 1, <!ARGUMENT_PASSED_TWICE!>i<!> = 2) //exception\n+    foo(1, <!ARGUMENT_PASSED_TWICE!>i<!> = 2, <!ARGUMENT_PASSED_TWICE!>i<!> = 3) //exception\n+    foo(i = 1, <!ARGUMENT_PASSED_TWICE!>i<!> = 2, <!ARGUMENT_PASSED_TWICE!>i<!> = 3) //exception", "msg": "Nice! :)"}
{"patch": "@@ -35,8 +36,9 @@ class ErrorNodeDiagnosticCollectorComponent(collector: AbstractDiagnosticCollect\n     }\n \n     override fun visitErrorNamedReference(errorNamedReference: FirErrorNamedReference, data: CheckerContext) {\n-        val source = data.qualifiedAccesses.lastOrNull()?.source?.takeIf { it.elementType == KtNodeTypes.DOT_QUALIFIED_EXPRESSION }\n-            ?: errorNamedReference.source ?: return\n+        val source = data.qualifiedAccesses.lastOrNull()?.takeIf {", "msg": "Perhaps add a comment on what you're trying to do"}
{"patch": "@@ -0,0 +1,15 @@\n+// !DIAGNOSTICS: -UNUSED_PARAMETER\n+\n+import kotlin.reflect.KProperty\n+\n+class Foo {\n+    var test: String by <!INAPPLICABLE_CANDIDATE!>refreshOnUpdate<!>(\"str\")", "msg": "This is due to https://youtrack.jetbrains.com/issue/KT-45344"}
{"patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.quickfix\n+\n+import com.intellij.codeInsight.intention.IntentionAction\n+import com.intellij.psi.PsiElement\n+import org.jetbrains.kotlin.idea.frontend.api.KtAnalysisSession\n+import kotlin.reflect.KClass\n+import kotlin.reflect.full.isSubclassOf\n+\n+// This is the same as QuickFixesPsiBasedFactory but KtAnalysisSession can be used in doCreateQuickFix().", "msg": "Can you turn this comment into a kdoc? Something like the following would make the referenced classes and methods clickable in the IDE.\n```\n/** This is the same as [QuickFixesPsiBasedFactory] but [KtAnalysisSession] can be used in [doCreateQuickFix]. */\n```"}
{"patch": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.quickfix.fixes\n+\n+import com.intellij.psi.PsiElement\n+import org.jetbrains.kotlin.idea.frontend.api.symbols.markers.KtTypedSymbol\n+import org.jetbrains.kotlin.idea.frontend.api.types.KtTypeNullability\n+import org.jetbrains.kotlin.idea.frontend.api.types.KtTypeWithNullability\n+import org.jetbrains.kotlin.idea.quickfix.ReplaceImplicitReceiverCallFix\n+import org.jetbrains.kotlin.idea.quickfix.ReplaceWithSafeCallFix\n+import org.jetbrains.kotlin.idea.quickfix.quickFixesPsiBasedFactoryWithAnalysis\n+import org.jetbrains.kotlin.idea.references.mainReference\n+import org.jetbrains.kotlin.psi.*\n+\n+object ReplaceCallFixFactories {\n+    val UnsafeCallFactory = quickFixesPsiBasedFactoryWithAnalysis { psiElement: PsiElement ->", "msg": "Should this be renamed to `replaceWithSafeCallFixFactory` to match FE1.0? Also, I think the name should be either SNAKE_CAP or lowerCamel."}
{"patch": "@@ -995,6 +1023,12 @@ internal val KT_DIAGNOSTIC_CONVERTER = KtDiagnosticConverterBuilder.buildConvert\n             token,\n         )\n     }\n+    add(FirErrors.CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT) { firDiagnostic ->", "msg": "Please rebase (also for changes in HLDiagnosticConverter.kt)"}
{"patch": "@@ -1124,9 +1124,15 @@ fun main(args: Array<String>) {\n             testClass<AbstractHighLevelQuickFixTest> {\n                 val pattern = \"^([\\\\w\\\\-_]+)\\\\.kt$\"\n                 model(\"quickfix/abstract\", pattern = pattern, filenameStartsLowerCase = true)\n+                model(\"quickfix/expressions\", pattern = pattern, filenameStartsLowerCase = true)\n                 model(\"quickfix/lateinit\", pattern = pattern, filenameStartsLowerCase = true)\n                 model(\"quickfix/modifiers\", pattern = pattern, filenameStartsLowerCase = true, recursive = false)\n+                model(\"quickfix/nullables\", pattern = pattern, filenameStartsLowerCase = true)\n                 model(\"quickfix/override/typeMismatchOnOverride\", pattern = pattern, filenameStartsLowerCase = true, recursive = false)\n+                model(\"quickfix/replaceInfixOrOperatorCall\", pattern = pattern, filenameStartsLowerCase = true)", "msg": "None of tests from `replaceInfixOrOperatorCall`/`replaceWithDotCal` are passing, may be let\u2019s not generate them?\r\n\r\n"}
{"patch": "@@ -5,8 +5,9 @@\n \n package kotlin.test\n \n+@PublishedApi // called from inline assert functions\n internal fun messagePrefix(message: String?) = if (message == null) \"\" else \"$message. \"\n internal expect fun lookupAsserter(): Asserter\n \n @PublishedApi // required to get stable name as it's called from box tests\n-internal fun overrideAsserter(value: Asserter?): Asserter? = _asserter.also { _asserter = value }\n\\ No newline at end of file\n+internal fun overrideAsserter(value: Asserter?): Asserter? = _asserter.also { _asserter = value }", "msg": "\ud83d\ude2b will fix"}
{"patch": "@@ -38,3 +40,39 @@ private fun FirLightSourceElement.getChild(types: Set<IElementType>, index: Int,\n     val visitor = LighterTreeElementFinderByType(treeStructure, types, index, depth)\n     return visitor.find(lighterASTNode)?.toFirLightSourceElement(treeStructure)\n }\n+", "msg": "Now this util file, `FirSourceChild`, should be renamed somehow. :) Say, `FirSourceUtils` ?"}
{"patch": "@@ -454,6 +454,11 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n         }\n     }\n \n+    val CONVENTIONS by object:DiagnosticGroup(\"Convetions\") {", "msg": "typo: \"Conventions\""}
{"patch": "@@ -205,11 +205,35 @@ class BasicAssertionsTest {\n     fun testExpectFails() {\n         checkFailedAssertion { expect(1) { 2 } }\n     }\n+\n+    @Test\n+    fun testAssertIs() {\n+        val s: Any = \"test\"\n+        assertIs<String>(s)\n+        assertEquals(4, s.length)\n+    }\n+\n+    @Test\n+    fun testAssertIsFails() {\n+        val message = \"Expected value to be of type <kotlin.Int>, actual <class kotlin.String>.\"", "msg": "Note that different platforms can have different `toString` representations of `KType` and `KClass`. Better to check that the message contains essential information rather than to expect it in exact form."}
{"patch": "@@ -823,9 +823,9 @@ class ExpressionsConverter(\n         }\n         val getArgument = context.arraySetArgument.remove(arrayAccess)\n         return buildFunctionCall {\n-            source = arrayAccess.toFirSourceElement()\n+            source = (if (getArgument == null) arrayAccess else arrayAccess.getParent()!!).toFirSourceElement()", "msg": "Nit: You can introduce either `val isGet = getArgument == null` or `isSet` and use here and below for `name`."}
{"patch": "@@ -1,3 +1,4 @@\n+// FIR_IDENTICAL", "msg": "FYI: this should be part of https://github.com/JetBrains/kotlin/commit/d3b42709fd35748f0d5ec1016da52a08944a951c and probably addressed soon."}
{"patch": "@@ -1,3 +1,4 @@\n+// FIR_IDENTICAL", "msg": "Ditto."}
{"patch": "@@ -707,7 +707,12 @@ open class FirDeclarationsResolveTransformer(transformer: FirBodyResolveTransfor\n         if (valueParameter.returnTypeRef is FirImplicitTypeRef) {\n             transformer.replaceDeclarationResolvePhaseIfNeeded(valueParameter, transformerPhase)\n             valueParameter.replaceReturnTypeRef(\n-                valueParameter.returnTypeRef.errorTypeFromPrototype(ConeSimpleDiagnostic(\"Unresolved value parameter type\"))\n+                valueParameter.returnTypeRef.errorTypeFromPrototype(\n+                    ConeSimpleDiagnostic(", "msg": "Nit: below `ConeSimpleDiagnostic` instantiation is written in one line, so I guess this could be in one line too. ;)"}
{"patch": "@@ -707,7 +707,12 @@ open class FirDeclarationsResolveTransformer(transformer: FirBodyResolveTransfor\n         if (valueParameter.returnTypeRef is FirImplicitTypeRef) {\n             transformer.replaceDeclarationResolvePhaseIfNeeded(valueParameter, transformerPhase)\n             valueParameter.replaceReturnTypeRef(\n-                valueParameter.returnTypeRef.errorTypeFromPrototype(ConeSimpleDiagnostic(\"Unresolved value parameter type\"))\n+                valueParameter.returnTypeRef.errorTypeFromPrototype(\n+                    ConeSimpleDiagnostic(\n+                        \"No type for parameter\",\n+                        DiagnosticKind.ValueParameterWithNoTypeAnnotation", "msg": "Nice catch! I wasn't aware of this diagnostic when I added: https://github.com/JetBrains/kotlin/commit/9aaa952b39b0e7882e7eb78b3ed981ed7a84ddac"}
{"patch": "@@ -7,7 +7,7 @@ class Foo {\n \n fun test_1() {\n     val f = Foo()\n-    <!UNRESOLVED_REFERENCE{LT}!>f <!UNRESOLVED_REFERENCE{PSI}!>+<!> f<!>\n+    <!UNRESOLVED_REFERENCE!>f + f<!>", "msg": "Good to see this unification!"}
{"patch": "@@ -13,4 +13,4 @@ class B : A() {\n         <!SUPER_IS_NOT_AN_EXPRESSION!>super<!> {}\n         (<!SUPER_IS_NOT_AN_EXPRESSION!>super<!>) {}\n     }\n-}\n\\ No newline at end of file\n+}", "msg": "Nit: seems not part of this change."}
{"patch": "@@ -454,6 +454,11 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n         }\n     }\n \n+    val CONVENTIONS by object:DiagnosticGroup(\"Conventions\") {", "msg": "Nit: Spaces before and after `:`"}
{"patch": "@@ -24,7 +24,9 @@ object CommonExpressionCheckers : ExpressionCheckers() {\n         FirTypeArgumentsNotAllowedExpressionChecker,\n         FirSealedClassConstructorCallChecker,\n     )\n-    override val functionCallCheckers: Set<FirFunctionCallChecker> = setOf()\n+    override val functionCallCheckers: Set<FirFunctionCallChecker> = setOf(", "msg": "Nit: Add newline before"}
{"patch": "@@ -32,5 +32,5 @@ fun test_3(a: A<D>) {\n }\n \n fun test_4(b: B) {\n-    <!UNRESOLVED_REFERENCE!><!UNRESOLVED_REFERENCE!>b[0]<!> += B()<!> // unresolved\n+    <!UNRESOLVED_REFERENCE!>b<!NO_GET_METHOD!>[0]<!> += B()<!> // unresolved", "msg": "Shouldn't we expect `NO_SET_METHOD` here too? On the assignment part of the `+=`."}
{"patch": "@@ -1,3 +1,4 @@\n+// IGNORE_FIR_DIAGNOSTICS", "msg": "Variable `res` is again uninitialized, but maybe it was incorrectly initialized in the previous PR."}
{"patch": "@@ -52,8 +52,19 @@ internal fun FirMemberDeclaration.isEffectivelyExternal(\n ): Boolean {\n     if (this.isExternal) return true\n \n-    // NB: [MemberDescriptor.isEffectivelyExternal] checks property accessors for property and vice versa.\n-    // But, raw FIR creation already did such upward/downward propagation of modifiers.\n+    if (this is FirPropertyAccessor) {\n+        // Check containing property\n+        val property = context.containingDeclarations.last() as FirProperty\n+        return property.isEffectivelyExternal(containingClass, context)\n+    }\n+\n+    if (this is FirProperty) {\n+        // Property is effectively external if all accessors are external\n+        if (getter?.isExternal == true &&\n+            (!isVar || setter?.isExternal == true)) {", "msg": "Nit: not formatted."}
{"patch": "@@ -519,6 +535,15 @@ class Kapt3GradleSubplugin @Inject internal constructor(private val registry: To\n                 it.mapDiagnosticLocations = kaptExtension.mapDiagnosticLocations\n                 it.annotationProcessorFqNames = kaptExtension.processors.split(',').filter { it.isNotEmpty() }\n                 it.javacOptions = dslJavacOptions.get()\n+                if (includeCompileClasspath && project.classLoadersCacheSize() > 0) {\n+                    project.logger.warn(\n+                        \"ClassLoaders cache can't be enabled together with AP discovery in compile classpath.\"", "msg": "\"compilation classpath\"?"}
{"patch": "@@ -0,0 +1,15 @@\n+// FILE: 1.kt\n+package a\n+\n+open class A {\n+    protected val v = \"OK\"\n+}\n+\n+// FILE: 2.kt\n+import a.*\n+\n+class B : A() {\n+    fun foo() = ::v.get()", "msg": "And just as I published this I realised that `B::v.get(this)` is still broken. Oh well."}
{"patch": "@@ -197,6 +200,16 @@ fun CheckerContext.findClosestClassOrObject(): FirClass<*>? {\n     return null\n }\n \n+fun CheckerContext.findClosestFile(): FirFile? {", "msg": "@mglukhikh  I just found there is `CheckerContext#findClosest<T>()`. Feel free to remove this. Also noticed that, in your experimental branch, its usage is also gone?"}
{"patch": "@@ -0,0 +1,34 @@\n+// !LANGUAGE: +RestrictionOfValReassignmentViaBackingField\n+\n+class Outer {\n+    val i: Int = 1\n+        get() {\n+            class Inner {\n+                var i: Int = 2\n+                    get() {\n+                        field++\n+                        return field\n+                    }\n+                val j: Int = 3\n+                    get() {\n+                        <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!> = 42\n+                        return field\n+                    }\n+\n+                fun innerMember() {\n+                    <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++\n+                }\n+            }\n+            return field\n+        }\n+\n+    val j: Int = 4\n+        get() {\n+            fun local() {\n+                <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++\n+                <!VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR!>field<!>++", "msg": "FYI, this second report is the only thing that breaks `// FIR_IDENTICAL`"}
{"patch": "@@ -565,6 +566,7 @@ class FirDefaultErrorMessages : DefaultErrorMessages.Extension {\n             map.put(PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY, \"Private setters are not allowed for abstract properties\")\n             map.put(PRIVATE_SETTER_FOR_OPEN_PROPERTY, \"Private setters are not allowed for open properties\")\n             map.put(VAL_WITH_SETTER, \"A 'val'-property cannot have a setter\")\n+            map.put(WRONG_SETTER_PARAMETER_TYPE, \"Setter parameter type must be equal to the type of the property\", TO_STRING, TO_STRING)", "msg": "The error message needs to render the (expected) property type.\r\n\r\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/diagnostics/rendering/DefaultErrorMessages.java#L478"}
{"patch": "@@ -10,7 +10,7 @@ enum class Color {\n class MyColor(val x: <!UNRESOLVED_REFERENCE!>Color.RED<!>, y: <!UNRESOLVED_REFERENCE!>Color.RED<!>) : <!UNRESOLVED_REFERENCE!>Color.RED<!> {\n \n     var z: <!UNRESOLVED_REFERENCE!>Color.RED<!> = Color.RED\n-    set(arg: <!UNRESOLVED_REFERENCE!>Color.RED<!>) { z = arg }\n+    set(arg: <!UNRESOLVED_REFERENCE, WRONG_SETTER_PARAMETER_TYPE!>Color.RED<!>) { z = arg }", "msg": "This shouldn't be type mismatch: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/EnumEntryAsType.kt#L13"}
{"patch": "@@ -1,5 +1,5 @@\n class My {\n-    var x: String = \"\"\n+    var x: <!WRONG_SETTER_PARAMETER_TYPE!>String<!> = \"\"", "msg": "This report seems not right either: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/varargs/varargInSetter.kt#L2"}
{"patch": "@@ -38,10 +38,10 @@ interface Test<in I, out O, P> {\n     var neOk22: Inv<out O>\n     var neOk23: Inv<out I>\n \n-    var neOk30: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS!>Pair<I, ><!>\n+    var neOk30: <!WRONG_NUMBER_OF_TYPE_ARGUMENTS, WRONG_SETTER_PARAMETER_TYPE!>Pair<I, ><!>", "msg": "All changes in this file look not correct: https://github.com/JetBrains/kotlin/blob/master/compiler/testData/diagnostics/tests/variance/InvariantPosition.kt#L41\r\n\r\nBtw, these properties don't have user-contributed setters at all, which means you need to bail out for default accessors."}
{"patch": "@@ -57,11 +58,35 @@ fun <@OnlyInputTypes T> assertEquals(expected: T, actual: T, message: String? =\n     asserter.assertEquals(message, expected, actual)\n }\n \n+/** Asserts that [actual] is within a [delta] value of the [expected] value with an optional [message]. */\n+@SinceKotlin(\"1.4\")", "msg": "`@SinceKotlin(\"1.5\")`"}
{"patch": "@@ -57,11 +58,35 @@ fun <@OnlyInputTypes T> assertEquals(expected: T, actual: T, message: String? =\n     asserter.assertEquals(message, expected, actual)\n }\n \n+/** Asserts that [actual] is within a [delta] value of the [expected] value with an optional [message]. */\n+@SinceKotlin(\"1.4\")\n+fun assertEquals(expected: Double, actual: Double, delta: Double, message: String? = null) {", "msg": "Please rename all `delta` arguments name to `absoluteTolerance`"}
{"patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.descriptors.impl\n+\n+import org.jetbrains.kotlin.descriptors.ModuleCapability\n+import org.jetbrains.kotlin.descriptors.PackageViewDescriptor\n+import org.jetbrains.kotlin.name.FqName\n+import org.jetbrains.kotlin.storage.StorageManager\n+\n+interface PackageViewDescriptorAccessor {", "msg": "The name like `PackageViewDescriptor` seems to be more clear to me, but I don't insist here"}
{"patch": "@@ -14,6 +14,7 @@\n  * limitations under the License.\n  */\n \n+", "msg": "Revert changes to this file."}
{"patch": "@@ -29,9 +32,13 @@ fun box() =\n             cProp.getter == C_propReflect.getter -> \"cProp.getter == C_propReflect.getter\"\n             C_propReflect.getter == cProp.getter -> \"C_propReflect.getter == cProp.getter\"\n \n-            // TODO https://youtrack.jetbrains.com/issue/KT-13490\n-            // cProp.getter != C()::prop.getter -> \"cProp.getter != C()::prop.getter\"\n-            // cProp.setter != C()::prop.setter -> \"cProp.setter != C()::prop.setter\"\n+            // https://youtrack.jetbrains.com/issue/KT-13490", "msg": "Now that the issue is fixed, this comment is no longer needed, so please remove it"}
{"patch": "@@ -34,11 +34,7 @@ object FirOverrideChecker : FirClassChecker() {\n             stubTypesEqualToAnything = false\n         )\n \n-        val firTypeScope = declaration.unsubstitutedScope(\n-            context.sessionHolder.session,\n-            context.sessionHolder.scopeSession,\n-            withForcedTypeCalculator = true", "msg": "Note that this is not necessary as mentioned at: https://github.com/JetBrains/kotlin/pull/4124#discussion_r583631765"}
{"patch": "@@ -67,9 +67,22 @@ class FakeOverrideGenerator(\n     }\n \n     fun IrClass.getFakeOverrides(klass: FirClass<*>, realDeclarations: Collection<FirDeclaration>): List<IrDeclaration> {\n+        val classLookupTag = klass.symbol.toLookupTag()\n+        val realDeclarationNames = realDeclarations.mapNotNullTo(mutableSetOf()) l@{\n+            val callableDeclaration = (it as? FirCallableMemberDeclaration<*>) ?: return@l null", "msg": "nit: this `l` label does not seem to make the code more readable. Consider removing it and just use `@mapNotNullTo` where needed below."}
{"patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kdocExport\n+\n+/**\n+ * Summary class [KDocExport]\n+ * @property xyzzy Doc for property xyzzy\n+ * @property zzz See below.\n+ */\n+\n+// Expected: this comment shall not affect KDoc (i.e. kdoc above is still OK)\n+class KDocExport(\n+    /**\n+     * @param xyzzy is documented.\n+     * This is multi-line KDoc\n+     */\n+    val xyzzy: String) {\n+\n+    /** Non-primary ctor KDoc: */\n+    constructor() : this(\"blabla\")\n+\n+    /** @property xyzzy KDoc for foo? */\n+    val foo = \"foo\"\n+    /** @property foo KDoc for yxxyz? */\n+    var yxxyz = 0;\n+}", "msg": "No tests for cases when StubRenderer has to emit both commits -- kdoc and `stub.comment`."}
{"patch": "@@ -321,3 +323,165 @@ val FirValueParameter.hasValOrVar: Boolean\n         val source = this.source ?: return false\n         return source.getChild(VAL_VAR_TOKEN_SET) != null\n     }\n+\n+fun ConeKotlinType.canBeUsedForConstVal() =\n+    (this.classId in StandardClassIds.primitiveTypes || this.classId in StandardClassIds.unsignedTypes) && !this.isNullable ||\n+            this.classId == StandardClassIds.String\n+\n+fun checkConstInitializerAndAnnotationArguments(", "msg": "I'd name it `checkConstantArguments` and change its visibility to `internal`"}
{"patch": "@@ -4,7 +4,7 @@ fun interface IFoo {\n     fun foo(i: Int)\n }\n \n-fun interface IFoo2 : IFoo\n+<!FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS!>fun<!> interface IFoo2 : IFoo", "msg": "This is incorrect, because `IFoo2` has exactly one abstract method which is inhereted from `IFoo`"}
{"patch": "@@ -15,7 +15,7 @@ fun interface F3 {\n     fun invoke()\n }\n \n-fun interface F4 {\n+<!FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS!>fun<!> interface F4 {", "msg": "Those changes also incorrect. Function `functionDelegate` has default implementation, so `F4` can be `fun interface`. See FE 1.0 counterpart in `functionDelegateClashOnJvm.kt`"}
{"patch": "@@ -15,7 +15,7 @@ fun interface F3 {\n     fun invoke()\n }\n \n-fun interface F4 {\n+<!FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS!>fun<!> interface F4 {\n     fun functionDelegate(): Function<*>? = null", "msg": "Also it's worth to implement `FunctionDelegateMemberNameClashChecker` in this PR, because it is part of checkers for `fun` interfaces"}
{"patch": "@@ -14,6 +14,7 @@ import org.jetbrains.kotlin.fir.analysis.diagnostics.DiagnosticReporter\n import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors\n import org.jetbrains.kotlin.fir.analysis.diagnostics.reportOn\n import org.jetbrains.kotlin.fir.declarations.*\n+import org.jetbrains.kotlin.lexer.KtModifierKeywordToken", "msg": "Why is this change requreid?"}
{"patch": "@@ -385,7 +385,8 @@ open class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransform\n         val operatorIsError = operatorCallReference?.isError ?: true\n \n         val lhsReference = leftArgument.toResolvedCallableReference()\n-        val lhsVariable = (lhsReference?.resolvedSymbol as? FirVariableSymbol<*>)?.fir\n+        val lhsSymbol = lhsReference?.resolvedSymbol as? FirVariableSymbol<*>", "msg": "Ah, I think this is the reason you changed the error's type. You can use `as? FirPropertySymbol` here."}
{"patch": "@@ -14,7 +14,7 @@ import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.FIR\n import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.FQ_NAMES_IN_TYPES\n import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.NAME\n import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.NULLABLE_STRING\n-import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.PROPERTY_NAME\n+import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.VARIABLE_NAME", "msg": "Not in order?"}
{"patch": "@@ -5,7 +5,7 @@ fun test(foo: Foo?) {\n         // Correct\n         foo.bar?.length\n         // Unnecessary\n-        foo?.bar?.length\n+        foo<!UNNECESSARY_SAFE_CALL!>?.<!>bar?.length\n     }\n-    foo.bar?.length\n-}\n\\ No newline at end of file\n+    foo.bar<!UNNECESSARY_SAFE_CALL!>?.<!>length", "msg": "Filed https://youtrack.jetbrains.com/issue/KT-45814"}
{"patch": "@@ -38,7 +38,7 @@ fun case_4(x: Any) {\n fun case_5(x: Any?) {\n     if (!(x !is Nothing?)) {\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any? & kotlin.Nothing\")!>x<!>\n-        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any? & kotlin.Nothing\")!>x<!>?.inv()\n+        <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any? & kotlin.Nothing\")!>x<!><!UNNECESSARY_SAFE_CALL!>?.<!>inv()", "msg": "Here and below, filed https://youtrack.jetbrains.com/issue/KT-45816"}
{"patch": "@@ -11,7 +11,7 @@ import java.lang.StringBuilder\n object CodeMetaInfoParser {\n     private val openingRegex = \"\"\"<!([^>][^\"]*?((\".*?\")(, \".*?\")*?)?[^\"]*?)!>\"\"\".toRegex()\n     private val closingRegex = \"<!>\".toRegex()\n-    private val commentRegex = \"\"\"(//[^\\r\\n]*)|(/\\*(.*?)\\*/)\"\"\".toRegex(RegexOption.DOT_MATCHES_ALL)\n+    private val commentRegex = \"\"\"/\\*(.*?)\\*/\"\"\".toRegex(RegexOption.DOT_MATCHES_ALL)", "msg": "Please squash this commit with first one before pushing"}
{"patch": "@@ -759,6 +759,26 @@ object PositioningStrategies {\n     val REFERENCE_BY_QUALIFIED: PositioningStrategy<PsiElement> = FindReferencePositioningStrategy(false)\n     val REFERENCED_NAME_BY_QUALIFIED: PositioningStrategy<PsiElement> = FindReferencePositioningStrategy(true)\n \n+    val ASSIGNMENT_VALUE: PositioningStrategy<KtProperty> = object : PositioningStrategy<PsiElement>() {\n+        override fun mark(element: PsiElement): List<TextRange> {\n+            return if (element is KtProperty) {\n+                markElement(element.initializer ?: element)\n+            } else {\n+                markElement(element)\n+            }", "msg": "Simplify?\r\n\r\n```suggestion\r\n            return markElement(if (element is KtProperty) element.initializer ?: element else element)\r\n```"}
{"patch": "@@ -32,9 +32,9 @@ fun useEn2(x: En2) = x\n fun bar(x: Any) {\n     if (x is En && x is En2) {\n         when (x) {\n-            En.A -> useEn(x)\n-            En2.D -> useEn2(x)\n+            <!INCOMPATIBLE_TYPES!>En.A<!> -> useEn(x)", "msg": "FE1.0 does not report this because the type of `x` is `Any` rather than an intersection of `En` and `En2`. It seems the FE1.0 checker is not taking smart cast into consideration for this diagnostic. For example, the following code demonstrate the bug in FE1.0:\r\n\r\n```\r\nfun foo(x: Any, s: String) {\r\n    if (x is String) {\r\n        x == 1 // FE1.0 thinks this is OK\r\n    }\r\n    s == 1 // FE1.0 reports EQUALITY_NOT_APPLICABLE\r\n}\r\n```"}
{"patch": "@@ -7,8 +7,8 @@ import checkSubtype\n fun main(args : Array<String>) {\n     val x = checkSubtype<Any>(args[0])\n     if(x is java.lang.CharSequence) {\n-        if (\"a\" == x) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // OK\n-        if (\"a\" == x || \"b\" == x) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // <\u2013 THEN ERROR\n-        if (\"a\" == x && \"a\" == x) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // <\u2013 ELSE ERROR\n+        if (<!EQUALITY_NOT_APPLICABLE!>\"a\" == x<!>) x.<!UNRESOLVED_REFERENCE!>length<!> else x.length() // OK", "msg": "This is similar to https://github.com/JetBrains/kotlin/pull/4281#discussion_r607421688. BTW, I was surprised to learn `kotlin.String` is not a subtype of `java.lang.CharSequence`."}
{"patch": "@@ -142,6 +144,17 @@ private fun showProcessorTimings(wrappedProcessors: List<ProcessorWrapper>, logg\n     }\n }\n \n+private fun dumpProcessorTiming(wrappedProcessors: List<ProcessorWrapper>, apReportFile: File?, logger: (String) -> Unit) {", "msg": "apReportFile can be non-nullable here, because you already check it's nullability in ?.let about"}
{"patch": "@@ -30,5 +30,11 @@ enum class DiagnosticKind {\n     UnknownCallableKind,\n     IllegalProjectionUsage,\n     MissingStdlibClass,\n-    Other\n+    Other,", "msg": "Minor: I'd leave Other at the end"}
{"patch": "@@ -175,6 +175,11 @@ private fun ConeSimpleDiagnostic.getFactory(): FirDiagnosticFactory0<FirSourceEl\n         DiagnosticKind.IllegalProjectionUsage -> FirErrors.ILLEGAL_PROJECTION_USAGE\n         DiagnosticKind.MissingStdlibClass -> FirErrors.MISSING_STDLIB_CLASS\n         DiagnosticKind.Other -> FirErrors.OTHER_ERROR\n+        DiagnosticKind.IncorrectCharacterLiteral -> FirErrors.INCORRECT_CHARACTER_LITERAL\n+        DiagnosticKind.EmptyCharacterLiteral -> FirErrors.EMPTY_CHARACTER_LITERAL\n+        DiagnosticKind.TooManyCharactersInCharacterLiteral -> FirErrors.TOO_MANY_CHARACTERS_IN_CHARACTER_LITERAL\n+        DiagnosticKind.IllegalEscape -> FirErrors.ILLEGAL_ESCAPE\n+        DiagnosticKind.IllegalEscapeSequence -> FirErrors.ILLEGAL_ESCAPE_SEQUENCE", "msg": "As I can see ILLEGAL_ESCAPE_SEQUENCE has no usages in FE 1.0 and can be dropped."}
{"patch": "@@ -321,3 +323,183 @@ val FirValueParameter.hasValOrVar: Boolean\n         val source = this.source ?: return false\n         return source.getChild(VAL_VAR_TOKEN_SET) != null\n     }\n+\n+fun ConeKotlinType.canBeUsedForConstVal(): Boolean {", "msg": "Please create a separate file with functions related to constant expressions (this one, `checkConstantArguments`, `ConstantArgumentKind`, etc.). You can call this file `FirConstChecks.kt` or something like this."}
{"patch": "@@ -0,0 +1,50 @@\n+// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE\n+\n+fun println(x: String) {\n+}\n+\n+fun run(block: () -> Unit) {}\n+\n+val propertyNameOnTheNextLine = 1\n+\n+fun foo() {\n+    val<!SYNTAX!><!>\n+    println(\"abc\")\n+\n+    val<!SYNTAX!><!>\n+    run {\n+        println(\"abc\")\n+    }\n+\n+    val<!SYNTAX!><!>\n+    if (1 == 1) {\n+\n+    }\n+\n+    val<!SYNTAX!><!>\n+    (1 + 2)\n+\n+    // `propertyNameOnTheNextLine` parsed as simple name expression\n+    val<!SYNTAX!><!>\n+    propertyNameOnTheNextLine\n+\n+    val<!SYNTAX!><!>\n+    // comment\n+    propertyNameOnTheNextLine\n+\n+    val<!SYNTAX!><!> /* comment */\n+    propertyNameOnTheNextLine\n+\n+    // Correct properties\n+    val\n+    property1 = 1\n+\n+    val\n+    propertyWithBy by <!DELEGATE_SPECIAL_FUNCTION_MISSING!><!UNRESOLVED_REFERENCE!>lazy<!> { 1 }<!>", "msg": "Ideally we should skip reporting this since `lazy` is unresolved. But there does not seem to be a way to communicate this between `ErrorNodeDiagnosticCollectorComponent` and the standalone checker."}
{"patch": "@@ -4,12 +4,12 @@\n \n import kotlin.reflect.KProperty\n \n-val a by <!UNRESOLVED_REFERENCE!>a<!>\n+val a by <!RECURSION_IN_IMPLICIT_TYPES!>a<!>\n \n val b by Delegate(b)\n \n-val c by <!UNRESOLVED_REFERENCE!>d<!>\n-val d by <!UNRESOLVED_REFERENCE!>c<!>\n+val c by d", "msg": "The problems with delegate is not reported here because `d` is not initialized. But unitialized variable is not reported as for now. If we want to avoid such regression for the time being. I can make the delegate checker report (redundant) issues with delegate. That would introduce more redundant reporting elsewhere though."}
{"patch": "@@ -159,6 +159,14 @@ internal class NativeIndexImpl(val library: NativeLibrary, val verbose: Boolean\n \n     private fun getDeclarationId(cursor: CValue<CXCursor>): DeclarationID {\n         val usr = clang_getCursorUSR(cursor).convertAndDispose()\n+\n+        // Different anonymous inner unions/structs may have the same USR", "msg": "Different how? Could you please provide an example?"}
{"patch": "@@ -118,7 +114,14 @@ class SerializableIrGenerator(\n                 // for abstract classes fields MUST BE checked in child classes\n                 !serializableDescriptor.isAbstractSerializableClass() && !serializableDescriptor.isSealedSerializableClass()\n             ) {\n-                generateGoldenMaskCheck(seenVars, properties, getSerialDescriptorExpr())\n+                val getDescriptorExpr = if (serializableDescriptor.isStaticSerializable) {\n+                    getStaticSerialDescriptorExpr()\n+                } else {\n+                    // internal constructor creates only for internal classes - so companion exists", "msg": "'internal' comment here may create confusion that it is related to internal visibility, not the `isInternalSerializable` function. So i'd rather avoid this word here"}
{"patch": "@@ -162,7 +164,16 @@ abstract class StructDef(val size: Long, val align: Int, val decl: StructDecl) {\n     abstract val members: List<StructMember>\n     abstract val kind: Kind\n \n-    val fields: List<Field> get() = members.filterIsInstance<Field>()\n+    val fields: List<Field> get() {\n+        val result = mutableListOf<Field>()\n+        members.forEach {\n+            when (it) {\n+                is Field -> result.add(it)\n+                is AnonymousInnerRecord -> result.addAll((it.type as RecordType).decl.def!!.fields)\n+            }\n+        }\n+    return result", "msg": "Wrong indent?"}
{"patch": "@@ -162,7 +164,16 @@ abstract class StructDef(val size: Long, val align: Int, val decl: StructDecl) {\n     abstract val members: List<StructMember>\n     abstract val kind: Kind\n \n-    val fields: List<Field> get() = members.filterIsInstance<Field>()\n+    val fields: List<Field> get() {\n+        val result = mutableListOf<Field>()\n+        members.forEach {\n+            when (it) {\n+                is Field -> result.add(it)\n+                is AnonymousInnerRecord -> result.addAll((it.type as RecordType).decl.def!!.fields)\n+            }\n+        }\n+    return result\n+    }", "msg": "Shouldn't we do the same for `bitFields` below?\nIf yes, then please add a test checking this."}
{"patch": "@@ -106,7 +106,7 @@ private fun Type.isIntegerLikeType(): Boolean = when (this) {\n                         when (it) {\n                             is BitField -> it.type.isIntegerLikeType()\n                             is Field -> it.offset == 0L && it.type.isIntegerLikeType()\n-                            is IncompleteField -> false\n+                            is IncompleteField, is AnonymousInnerRecord -> false", "msg": "Is this correct?"}
{"patch": "@@ -10,15 +10,16 @@ fun tryRenderStructOrUnion(def: StructDef): String? = when (def.kind) {\n private fun tryRenderStruct(def: StructDef): String? {\n     val isPackedStruct = def.fields.any { !it.isAligned }\n \n-    var offset = 0L\n+    // The only case when offset starts from non-zero is a inner anonymous struct or union\n+    var offset = def.members.filterIsInstance<Field>().firstOrNull()?.offsetBytes ?: 0L", "msg": "Would this work for \n```c\nstruct S {\n    char a;\n    struct {\n        __attribute__((aligned(4)))\n        char x;\n    };\n};\n```\n?"}
{"patch": "@@ -116,7 +112,14 @@ class SerializableIrGenerator(\n                 // for abstract classes fields MUST BE checked in child classes\n                 !serializableDescriptor.isAbstractSerializableClass() && !serializableDescriptor.isSealedSerializableClass()\n             ) {\n-                generateGoldenMaskCheck(seenVars, properties, getSerialDescriptorExpr())\n+                val getDescriptorExpr = if (serializableDescriptor.isStaticSerializable) {\n+                    getStaticSerialDescriptorExpr()\n+                } else {\n+                    // synthetic constructor creates only for internally serializable classes - so companion definitely exists", "msg": "```suggestion\r\n                    // synthetic constructor is created only for internally serializable classes - so companion definitely exists\r\n```"}
{"patch": "@@ -267,8 +260,11 @@ internal class NativeIndexImpl(val library: NativeLibrary, val verbose: Boolean\n                     }\n                     fieldCursor.type.kind == CXType_Record -> {\n                         // TODO: clang_Cursor_getOffsetOfField is OK for anonymous, but only for the 1st level of such nesting\n+                        val declCursor = clang_getTypeDeclaration(fieldCursor.type)\n                         AnonymousInnerRecord(\n-                                convertCursorType(fieldCursor) as RecordType,\n+                                RecordType(createStructDecl(declCursor).also {", "msg": "This looks better, but still `StructDecl` (and `RecordType`) seems kinda useless here, and it should be pretty easy to get rid of.\r\n\r\n`findNamedParent` still looks redundant: why do we need to _find_ parent, if we already _know_ it? I mean, for the root struct it is the struct itself, and for nested anonymous structs we know the exact parent here.\r\nAlternatively, we could also make parents unnecessary, if we stopped using the root struct as the base for field offsets (which also makes some sense). But I believe this might depend on the way other issues are handled."}
{"patch": "@@ -305,7 +305,6 @@ class FirMemberDeserializer(private val c: FirDeserializationContext) {\n                 isOverride = false\n                 isConst = Flags.IS_CONST.get(flags)\n                 isLateInit = Flags.IS_LATEINIT.get(flags)\n-                isInline = Flags.IS_INLINE.get(flags)", "msg": "Why inline flag shouldn't be loaded?"}
{"patch": "@@ -8,30 +8,57 @@\n // WITH_REFLECT\n \n import kotlin.reflect.KMutableProperty1\n+import kotlin.reflect.KMutableProperty2\n import kotlin.reflect.full.*\n \n class C {\n     var prop = 42\n+    var String.prop: Int\n+        get() = 42\n+        set(value) {}", "msg": "Not sure if this is a good case for our test for `KProperty2`"}
{"patch": "@@ -144,7 +144,18 @@ object Main {\n                 break\n             }\n             else {\n-                setRunner(MainClassRunner(arg))\n+                val workingDir = File(\".\")\n+                val classFile = File(arg)\n+                // allow running class files with '.class' extension, but in order to infer its fully qualified name,\n+                // it must be located in the working directory or a subdirectory of it\n+                val className =\n+                    if (arg.endsWith(\".class\") && classFile.exists() && classFile.canonicalPath.contains(workingDir.canonicalPath)) {\n+                        classFile.canonicalFile.toRelativeString(workingDir.canonicalFile).removeSuffix(\".class\")\n+                            .replace(File.separatorChar, '.')\n+                    } else {\n+                        arg\n+                    }", "msg": "The method `toRelativeString` may throw an `IllegalArgumentException` when our `classFile.canonicalFile` and `workingDir.canonicalFile` have different roots, but it has been circumvented in our `if` statement,  so there is no need to catch it."}
{"patch": "@@ -17,7 +17,7 @@ fun test2(): KClass<out Foo>? {\n     var f: Foo? = null\n     if (f != null) {\n         run { f = null }\n-        return <!RETURN_TYPE_MISMATCH!><!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>f<!>::class<!>\n+        return <!EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS!>f<!>::class", "msg": "I don't understand how your checker could provoke this change (will recheck myself)"}
{"patch": "@@ -6,6 +6,11 @@ fun test() : Int {\n     val a : () -> Unit = {\n         foo(<!ARGUMENT_TYPE_MISMATCH!>1<!>)\n     }\n+", "msg": "Why this change is needed?"}
{"patch": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.idea.frontend.api.symbols\n+\n+import com.intellij.openapi.diagnostic.Logger\n+import com.intellij.openapi.util.Iconable\n+import com.intellij.psi.PsiClass\n+import com.intellij.ui.RowIcon\n+import com.intellij.util.PlatformIcons\n+import org.jetbrains.kotlin.descriptors.Modality\n+import org.jetbrains.kotlin.descriptors.Visibilities\n+import org.jetbrains.kotlin.idea.KotlinIcons\n+import org.jetbrains.kotlin.idea.frontend.api.symbols.markers.*\n+import org.jetbrains.kotlin.psi.KtClass\n+import org.jetbrains.kotlin.psi.KtDeclaration\n+import javax.swing.Icon\n+\n+object KtIconProvider {", "msg": "Please, consider adding KtAnalysingSession as receiver parameter for all functions here. This is needed to ensure the contract that we can access symbols only in KtAnalysisSession context"}
{"patch": "@@ -0,0 +1,54 @@\n+// FILE: test.kt\n+\n+inline fun f(block: () -> Unit) {\n+    block()\n+}\n+\n+var x: String = \"\"\n+\n+fun compute(): String {\n+    try {\n+        try {\n+            val y = 42\n+            for (i in 0 until 1) {\n+                return \"NORMAL_RETURN\"\n+            }\n+        } finally {\n+            var s = \"NOPE\"\n+            x = s\n+            f {\n+                return \"NON_LOCAL_RETURN\"\n+            }\n+        }\n+    } finally {\n+        val s2 = \"OK\"\n+        x = s2  // TODO: Why is `s2` not visible here?", "msg": "This is a little puzzling. I would like to have a look at that separately from this change."}
{"patch": "@@ -173,6 +173,10 @@ sealed class FirFakeSourceElementKind : FirSourceElementKind() {\n     // for java annotations constructor implicit parameters are generated\n     // with a fake source which refers to declared annotation methods\n     object ImplicitAnnotationAnnotationConstructorParameter : FirFakeSourceElementKind()\n+\n+    // for the implicit field storing the delegated object for class delegation\n+    // with a fake source that refers to the KtObjectLiteralExpression that creates the delegate", "msg": "Nit: The delegate can be any expression, not just an object literal (e.g., function call, name reference)."}
{"patch": "@@ -417,3 +414,62 @@ fun isSubtypeOfForFunctionalTypeReturningUnit(context: ConeInferenceContext, sub\n     }\n     return false\n }\n+\n+fun FirCallableMemberDeclaration<*>.isVisibleInClass(parentClass: FirClass<*>): Boolean {\n+    val classPackage = parentClass.symbol.classId.packageFqName\n+    if (visibility == Visibilities.Private ||\n+        !visibility.visibleFromPackage(classPackage, symbol.callableId.packageName)\n+    ) return false\n+    if (visibility == Visibilities.Internal &&\n+        declarationSiteSession !== parentClass.declarationSiteSession\n+    ) return false\n+    return true\n+}\n+\n+/**\n+ * Get the [ImplementationStatus] for this symbol.\n+ *\n+ * @param parentClass the contextual class for this query. This class must not be abstract or sealed.", "msg": "This comment should be modified (class _can_ be abstract or sealed)"}
{"patch": "@@ -204,22 +204,22 @@ object IgnoreTests {\n     }\n \n \n-    fun cleanUpIdenticalFirTestFile(originalTestFile: File) {\n-        val firTestFile = deriveFirTestFile(originalTestFile)\n+    fun cleanUpIdenticalFirTestFile(", "msg": "Do you mind fixing the typo in the package name \"uitls\"? :)"}
{"patch": "@@ -486,6 +486,11 @@ class BodyResolveContext(\n         return withTowerDataCleanup {\n             addLocalScope(FirLocalScope())\n             if (function is FirSimpleFunction) {\n+                // Make all value parameters available in the local scope so that even one parameter that refers to another parameter,\n+                // which may not be initialized yet, could be resolved. We will detect and report such case in checkers.", "msg": "Suggestion: Be specific and say \"in FirFunctionParameterChecker\" instead of \"in checkers\" (also below in `forConstructorParameters`)"}
{"patch": "@@ -393,6 +423,24 @@ class ExpressionCodegen(\n         }\n     }\n \n+    private fun addLocalVariableGapsForFinallyBlocks(", "msg": "Not sure about naming, maybe \"splitLocalVariableRangesByFinnalyBlocks\"?"}
{"patch": "@@ -120,25 +120,28 @@ interface TypeDeclaration {\n     val location: Location\n }\n \n-sealed class StructMember(val name: String, val type: Type) {\n+sealed class StructMember(val name: String) {\n     abstract val offset: Long?\n }\n \n /**\n  * C struct field.\n  */\n-class Field(name: String, type: Type, override val offset: Long, val typeSize: Long, val typeAlign: Long)\n-    : StructMember(name, type)\n+class Field(name: String, val type: Type, override val offset: Long, val typeSize: Long, val typeAlign: Long)\n+    : StructMember(name)\n \n val Field.isAligned: Boolean\n     get() = offset % (typeAlign * 8) == 0L\n \n-class BitField(name: String, type: Type, override val offset: Long, val size: Int) : StructMember(name, type)\n+class BitField(name: String, val type: Type, override val offset: Long, val size: Int) : StructMember(name)\n \n-class IncompleteField(name: String, type: Type) : StructMember(name, type) {\n+class IncompleteField(name: String, val type: Type) : StructMember(name) {", "msg": "Is `type` here used?"}
{"patch": "@@ -8,35 +8,45 @@ fun tryRenderStructOrUnion(def: StructDef): String? = when (def.kind) {\n }\n \n private fun tryRenderStruct(def: StructDef): String? {\n-    val isPackedStruct = def.fields.any { !it.isAligned }\n-\n+    // The only case when offset starts from non-zero is a inner anonymous struct or union\n+    val baseOffset = def.members.filterIsInstance<Field>().firstOrNull()?.offsetBytes ?: 0L", "msg": "So for\n```c\nstruct S {\n    struct {\n        int x;\n    };\n    int y;\n};\n```\n`immediateOffset` of the `AnonymousInnerRecord` will be negative? Is this intended?"}
{"patch": "@@ -47,8 +52,13 @@ object FirDelegatedPropertyChecker : FirPropertyChecker() {\n             override fun visitElement(element: FirElement) = element.acceptChildren(this)\n \n             override fun visitFunctionCall(functionCall: FirFunctionCall) {\n-                val errorNamedReference = functionCall.calleeReference as? FirErrorNamedReference ?: return\n-                if (errorNamedReference.source?.kind != FirFakeSourceElementKind.DelegatedPropertyAccessor) return\n+                val hasReferenceError = checkFunctionReferenceErrors(functionCall)\n+                if (isGet && !hasReferenceError) checkReturnType(functionCall)\n+            }\n+\n+            private fun checkFunctionReferenceErrors(functionCall: FirFunctionCall): Boolean {", "msg": "Can you rename this to `hasFunctionReferenceErrors`?"}
{"patch": "@@ -95,7 +95,7 @@ fun branchedAndNestedWithNativeOperators(x: Any?, y: Any?) {\n                     equalsTrue(isInt(y) && isString(y))                          // y is Int, String\n             )\n             &&\n-            (1 == 2 || y is Int || isString(y))\n+            (1 == 2 || <!USELESS_IS_CHECK!>y is Int<!> || isString(y))", "msg": "Note that this is `&&` clause, which means the previous one is `true`, where both sides of `||` include `y is Int` or `isInt(y)` with contract `y is Int`. Hence, this is what FIR smartcast detects well (while FE 1.0 didn't warn anything)."}
{"patch": "@@ -14,15 +14,15 @@ fun g(a: SomeClass?) {\n         a.hashCode()\n         a.foo\n         (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n-        (a as SomeSubClass).foo\n+        (a <!USELESS_CAST!>as SomeSubClass<!>).foo\n     }\n     val b = (a as? SomeSubClass)?.foo\n     if (b != null) {\n         // 'a' can be cast to SomeSubClass\n         a.hashCode()\n         a.foo\n         (a as? SomeSubClass)<!UNSAFE_CALL!>.<!>foo\n-        (a as SomeSubClass).foo\n+        (a <!USELESS_CAST!>as SomeSubClass<!>).foo", "msg": "Note that this test is same as `basicOn` below, but without `SafeCastCheckBoundSmartCasts`, which disables collection of nullability info. As we all know(?), nullability is not available for `== null`, but available for `!= null` in FIR DFA. That's why, with or without that flag, we're seeing those variables as non-null `SomeSubClass`. That flag is on since 1.2, so seeing the same result with `basicOn` seems okay."}
{"patch": "@@ -5,7 +5,7 @@ enum class En { A, B, \u0421 }\n fun foo() {\n     // nullable variable\n     val en2: Any? = En.A\n-    if (en2 is En) {\n+    if (<!USELESS_IS_CHECK!>en2 is En<!>) {", "msg": "Unlike cast (`as`),  FE1.0's `is` check doesn't see if the use of type checking defines the expression type. I.e., it never checks exact cast, but always up cast. It's unclear whether FE1.0 doesn't have smartcast info at this point or intentionally uses the user-specified type (`Any?`). In contrast, FIR has smartcast info here (`En`) from the initial value, and regards this (and below) `is` is redundant."}
{"patch": "@@ -7,7 +7,7 @@ fun <T> foo() = foo() as T\n \n fun <T> foo2(): T = TODO()\n \n-val test = foo2().plus(\"\") as String\n+val test = foo2().plus(\"\") <!USELESS_CAST!>as String<!>", "msg": "`foo2`'s return type is `T`, but again, with smartcast, its type is seen as `Nothing`. Not sure how `T/Nothing.plus` is resolved, and I think if that becomes unresolved or error type, this warning would be gone. Anyhow, with that resolution, `.plus(\"\")` is `String`, and thus redundant cast. :\\"}
{"patch": "@@ -17,5 +17,5 @@ val asStarList = foo() as List<*>\n \n val safeAs = foo() as? String\n \n-val fromIs = foo() is String\n-val fromNoIs = foo() !is String\n+val fromIs = <!USELESS_IS_CHECK!>foo() is String<!>\n+val fromNoIs = <!USELESS_IS_CHECK!>foo() !is String<!>", "msg": "Quite similar here. `foo()` returns `Nothing` (or technically, `throw`), which makes `is String` up cast. :\\"}
{"patch": "@@ -43,7 +43,7 @@ class case_4 : ClassLevel3() {\n \n     fun <T>T.case_4_3_wrap() {\n         fun case_4_3_contract() {\n-            contract { returns() implies (this@case_4_3_wrap is ClassLevel1) }\n+            contract { returns() implies (<!USELESS_IS_CHECK!>this@case_4_3_wrap is ClassLevel1<!>) }", "msg": "This seems false warning, but smartcast for `this` is `ClassLevel1 & T`. Didn't dig further why smartcast has that, but I suspect that such info is back-propagated from the below `this@... !is ClassLevel1` (if persistent flow is not isolated)?"}
{"patch": "@@ -187,7 +187,7 @@ fun case_14() {\n     do {\n         <!DEBUG_INFO_EXPRESSION_TYPE(\"kotlin.Any?\")!>x<!>\n         x = x<!UNSAFE_CALL!>.<!>equals(10)\n-    } while (x is Any)\n+    } while (<!USELESS_IS_CHECK!>x is Any<!>)", "msg": "This and below seem what FIR DFA is doing better (i.e., FE1.0 didn't warn). With proper checks (`if (x == null) return` or `if (x is Any) { ... }`), `x` starts with non-null `Any` in the beginning of the loop, and then after `x = ... equals ...`, smartcast info for `x` is `Boolean`, hence redundant `is Any`.\r\n\r\nIt's irony, though, that, with special handling via preliminary loop visitor, `x`'s type before reassignment is still `Any?` so that `UNSAFE_CALL` behavior matches, hmm."}
{"patch": "@@ -759,6 +759,35 @@ class CoroutineTransformerMethodVisitor(\n             referencesToCleanBySuspensionPointIndex += currentSpilledReferencesCount to predSpilledReferencesCount\n         }\n \n+        // Calculate debug metadata mapping before modifying method node to make it easier to locate", "msg": "This code block has just been moved earlier. It is unchanged."}
{"patch": "@@ -24,6 +24,6 @@ fun g(x: B<Int>) {\n \n     if (y is Nothing?) {\n         f(y)\n-        <!NONE_APPLICABLE!>g<!>(y)\n+        g(y)", "msg": "Well, at least, we are consistent now (see line 22 above)."}
{"patch": "@@ -26,7 +26,7 @@ fun testSpilling(x: Any?) {\n         myAssert(x is String)\n         x.length\n     }\n-    x.<!UNRESOLVED_REFERENCE!>length<!>\n+    x<!UNSAFE_CALL!>.<!>length", "msg": "This one seems interesting. From the path that passed through `if`, `x is String`. From the synthetic `else`, `x == null` (or `x is Nothing?`). After type `or`ing, now `x is String?`. :\\\r\n\r\nI updated `isAcceptableForSmartcast` accordingly, but seems not good enough. I expect type `or` also needs to drop `Nothing?` at every step?"}
{"patch": "@@ -1,6 +1,6 @@\n // FIR_IDENTICAL\n // !LANGUAGE: +NewInference\n-// !DIAGNOSTICS: -USELESS_IS_CHECK USELESS_NULLABLE_CHECK -UNUSED_VALUE -UNUSED_PARAMETER -UNREACHABLE_CODE -UNUSED_VARIABLE -USELESS_NULLABLE_CHECK\n+// !DIAGNOSTICS: -USELESS_IS_CHECK -USELESS_NULLABLE_CHECK -UNUSED_VALUE -UNUSED_PARAMETER -UNREACHABLE_CODE -UNUSED_VARIABLE -USELESS_NULLABLE_CHECK", "msg": "`-USELESS_NULLABLE_CHECK` appears twice. I think you can just remove this."}
{"patch": "@@ -39,9 +39,9 @@ class ErrorNodeDiagnosticCollectorComponent(\n     }\n \n     override fun visitResolvedTypeRef(resolvedTypeRef: FirResolvedTypeRef, data: CheckerContext) {\n-        val errorType = resolvedTypeRef.type as? ConeClassErrorType ?: return\n-        val source = resolvedTypeRef.source ?: return\n-        reportFirDiagnostic(errorType.diagnostic, source, reporter, data)\n+        assert(resolvedTypeRef.type !is ConeKotlinErrorType) {", "msg": "I use this assertion to detect remaining cases, but let me know if you think it's better to remove this override as a whole."}
{"patch": "@@ -32,6 +34,9 @@ interface KtTypeProviderMixIn : KtAnalysisSessionMixIn {\n \n     fun KtNamedClassOrObjectSymbol.buildSelfClassType(): KtType =\n         analysisSession.typeProvider.buildSelfClassType(this)\n+\n+    fun KtType.makeNullable(): KtType =", "msg": "Maybe some more general function like `KtType.withNullability(newNullability: KtNullablility): KtType`"}
{"patch": "@@ -47,8 +47,8 @@ class DiagnosticBuilder(\n \n     @OptIn(PrivateForInline::class, ExperimentalStdlibApi::class)\n     inline fun <reified T> parameter(name: String) {\n-        if (parameters.size == 3) {\n-            error(\"Diagnostic cannot have more than 3 parameters\")\n+        if (parameters.size >= 4) {", "msg": "Should we introduce a `const val` somewhere for this magic number, just in case if we want to expand again?"}
{"patch": "@@ -87,6 +87,7 @@ private fun mapUnsafeCallError(\n         return FirErrors.UNSAFE_IMPLICIT_INVOKE_CALL.on(source, rootCause.actualType)\n     }\n \n+    val receiverExpression = candidate.callInfo.explicitReceiver", "msg": "This is the same as `left` below so you can just rename `left` to `receiverExpression` (and maybe `right` to `singleArgument`?)."}
{"patch": "@@ -371,10 +375,16 @@ private fun checkApplicabilityForArgumentType(\n             return type\n         }\n \n+        val isMismatchDueToNullability = AbstractTypeChecker.isSubtypeOf(\n+            context.session.typeContext,\n+            argumentType,\n+            actualExpectedType.withNullability(ConeNullability.NULLABLE, context.session.typeContext)", "msg": "Btw, this was the motivation of #4340 :)"}
{"patch": "@@ -9,6 +9,7 @@ import org.jetbrains.kotlin.fir.declarations.FirFunction\n import org.jetbrains.kotlin.fir.declarations.FirValueParameter\n import org.jetbrains.kotlin.fir.expressions.FirExpression\n import org.jetbrains.kotlin.fir.expressions.FirNamedArgumentExpression\n+import org.jetbrains.kotlin.fir.psi", "msg": "Accidentally added? Remove"}
{"patch": "@@ -467,7 +467,7 @@ class FirDefaultErrorMessages : DefaultErrorMessages.Extension {\n             map.put(NAMED_PARAMETER_NOT_FOUND, \"Cannot find a parameter with this name: {0}\", TO_STRING)\n             map.put(MANY_LAMBDA_EXPRESSION_ARGUMENTS, \"Only one lambda expression is allowed outside a parenthesized argument list\")\n \n-            map.put(ARGUMENT_TYPE_MISMATCH, \"Argument type mismatch: actual type is {1} but {0} was expected\", TO_STRING, TO_STRING)\n+            map.put(ARGUMENT_TYPE_MISMATCH, \"Argument type mismatch: actual type is {1} but {0} was expected\", TO_STRING, TO_STRING, NOT_RENDERED)", "msg": "Super nit: Not imported in this commit. But it is in the next one, so no big deal :)"}
{"patch": "@@ -347,6 +347,8 @@ fun PsiElement.parameterIndex(): Int {\n     }\n }\n \n+val KtValueArgument.argumentIndex get() = (parent as KtValueArgumentList).arguments.indexOf(this)", "msg": "Nit: explicit return type? (even though index sounds like an integer :) )"}
{"patch": "@@ -47,8 +47,8 @@ class DiagnosticBuilder(\n \n     @OptIn(PrivateForInline::class, ExperimentalStdlibApi::class)\n     inline fun <reified T> parameter(name: String) {\n-        if (parameters.size == 3) {\n-            error(\"Diagnostic cannot have more than 3 parameters\")\n+        if (parameters.size >= MAX_DIAGNOSTIC_PARAMETER_COUNT) {\n+            error(\"Diagnostic cannot have more than 4 parameters\")", "msg": "And... I expect you to use that constant here as well..."}
{"patch": "@@ -17,8 +19,11 @@ interface KotlinCompile<out T : KotlinCommonOptions> : Task {\n         kotlinOptions.fn()\n     }\n \n+    fun kotlinOptions(fn: Action<in T>) {", "msg": "Thank you for adding this override :+1: "}
{"patch": "@@ -61,12 +61,11 @@ class Android25ProjectHandler(\n         kotlinTask.configure { kotlinTaskInstance ->\n             kotlinTaskInstance.inputs.files(variantData.getSourceFolders(SourceKind.JAVA)).withPathSensitivity(PathSensitivity.RELATIVE)\n \n-            kotlinTaskInstance.mapClasspath {\n-                val kotlinClasspath = variantData.getCompileClasspath(preJavaClasspathKey)\n-                kotlinClasspath + project.files(AndroidGradleWrapper.getRuntimeJars(androidPlugin, androidExt))\n-            }\n+            kotlinTaskInstance.classpath = project.files()\n+                .from(variantData.getCompileClasspath(preJavaClasspathKey))\n+                .from(Callable { AndroidGradleWrapper.getRuntimeJars(androidPlugin, androidExt) })", "msg": "Nit: could use here Kotlin lambda (also evaluated lazily):\r\n```kotlin\r\n.from({ AndroidGradleWrapper.getRuntimeJars(androidPlugin, androidExt) })\r\n```"}
{"patch": "@@ -34,12 +36,12 @@ class FirKotlinUFile(\n         sourcePsi.importDirectives.map { FirKotlinUImportStatement(it, this) }\n     }\n \n-    override val classes: List<UClass>\n-        get() {\n-            // TODO: Script\n-            // TODO: Facade: getOrCreateFirLightFacade()\n-            return sourcePsi.declarations.mapNotNull { (it as? KtClassOrObject)?.toUClass() }\n-        }\n+    override val classes: List<UClass> by lz {\n+        val facadeOrScriptClass = if (sourcePsi.isScript()) sourcePsi.script?.toLightClass() else sourcePsi.findFacadeClass()\n+        val facadeOrScriptUClass = facadeOrScriptClass?.toUClass()?.let { listOf(it) } ?: emptyList()\n+        val classes = sourcePsi.declarations.mapNotNull { (it as? KtClassOrObject)?.toUClass() }\n+        facadeOrScriptUClass + classes\n+    }", "msg": "Now `UFile` is also in its final shape I guess. My next step would be to think of ways to simplify/unify `UFile` and `UImportStatement` at each plugin."}
{"patch": "@@ -95,22 +95,20 @@ class DarwinArm64AbiInfo : ObjCAbiInfo {\n     }\n }\n \n+private fun StructDef.hasIntegerLikeLayout(): Boolean {\n+    return size <= 4 &&\n+            members.all {\n+                when (it) {\n+                    is BitField -> it.type.isIntegerLikeType()\n+                    is Field -> it.offset == 0L && it.type.isIntegerLikeType()\n+                    is AnonymousInnerRecord -> it.offset == 0L && it.def.hasIntegerLikeLayout()", "msg": "`it.offset == 0L` is probably always `false` now."}
{"patch": "@@ -0,0 +1,113 @@\n+import kotlinx.cinterop.*\n+import kotlin.test.*\n+import structAnonym.*\n+\n+fun test_simple() {\n+    val c = retByValue()\n+    c.useContents {\n+        assertEquals(37, x)\n+        assertEquals(42L + 0x100000000, b)", "msg": "Will this work for big-endian targets?"}
{"patch": "@@ -52,7 +51,7 @@ class IvyResolver : ExternalDependenciesResolver {\n                 resolveArtifact(\n                     artifactId[0], artifactId[1], artifactId[2],\n                     if (artifactId.size > 3) artifactId[3] else null,\n-                    if (artifactType.isNotEmpty()) artifactType else null,\n+                    artifactType.ifEmpty { null },", "msg": "I would prefer not to have irrelevant changes in such commits. It makes history analysis more difficult. If you want to suggest such refactorings, please submit a separate PR, or at least in a separate commit."}
{"patch": "@@ -660,6 +662,20 @@ private val blockDecomposerLoweringPhase = makeBodyLoweringPhase(\n     prerequisite = setOf(typeOperatorLoweringPhase, suspendFunctionsLoweringPhase)\n )\n \n+private val stringConcatenationLowering = makeBodyLoweringPhase(\n+    ::StringConcatenationLowering,\n+    name = \"StringConcatenationLowering\",\n+    description = \"Lowers String concatenation to a chain of String::plus\",\n+    prerequisite = setOf(blockDecomposerLoweringPhase)", "msg": "The `blockDecomposerLoweringPhase` step creates String concatenations, so it needs to run first"}
{"patch": "@@ -675,7 +691,8 @@ private val primitiveCompanionLoweringPhase = makeBodyLoweringPhase(\n private val callsLoweringPhase = makeBodyLoweringPhase(\n     ::CallsLowering,\n     name = \"CallsLowering\",\n-    description = \"Handle intrinsics\"\n+    description = \"Handle intrinsics\",\n+    prerequisite = setOf(stringPlusLongLowering)", "msg": "This one lowers the `String::plus` to `jsPlus`, so the fix for Longs needs to happen first"}
{"patch": "@@ -525,7 +525,7 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n     val PROPERTIES_AND_ACCESSORS by object : DiagnosticGroup(\"Properties & accessors\") {\n         val ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS by error<KtModifierListOwner>(PositioningStrategy.MODALITY_MODIFIER) {\n             parameter<FirMemberDeclaration>(\"property\")\n-            parameter<FirMemberDeclaration>(\"containingClass\") // TODO use FirClass instead of FirMemberDeclaration\n+            parameter<FirRegularClass>(\"containingClass\")", "msg": "Same"}
{"patch": "@@ -66,10 +70,17 @@ object FirPropertyInitializationAnalyzer : AbstractFirPropertyInitializationChec\n             symbol: FirPropertySymbol,\n             node: VariableAssignmentNode\n         ): Boolean {\n+            if (symbol.fir.isVal && node.fir in capturedWrites) {\n+                if (symbol.fir.isLocal) {\n+                    reporter.reportOn(node.fir.lValue.source, FirErrors.CAPTURED_VAL_INITIALIZATION, symbol, context)\n+                } else {\n+                    reporter.reportOn(node.fir.lValue.source, FirErrors.CAPTURED_MEMBER_VAL_INITIALIZATION, symbol, context)", "msg": "Please note that this checker isn't invoked against member properties yet, and thus we don't see any changes in this commit/PR. Extending this to member properties in general is on my TODO list."}
{"patch": "@@ -386,14 +379,17 @@ private fun checkApplicabilityForArgumentType(\n     }\n \n     if (!csBuilder.addSubtypeConstraintIfCompatible(argumentType, expectedType, position)) {\n+        val smartcastExpression = argument as? FirExpressionWithSmartcast\n+        if (smartcastExpression != null) {\n+            val unstableType = smartcastExpression.smartcastType.coneType\n+            if (csBuilder.addSubtypeConstraintIfCompatible(unstableType, expectedType, position)) {\n+                sink.reportDiagnosticIfNotNull(UnstableSmartCast.ResolutionError(smartcastExpression, expectedType))", "msg": "Here you should report error only when smartcast is unstable"}
{"patch": "@@ -19,11 +19,13 @@ import org.jetbrains.kotlin.fir.types.FirTypeRef\n import org.jetbrains.kotlin.fir.visitors.FirTransformer\n import org.jetbrains.kotlin.fir.visitors.FirVisitor\n import org.jetbrains.kotlin.fir.visitors.transformSingle\n+import org.jetbrains.kotlin.types.SmartcastStability\n \n internal class FirExpressionWithSmartcastImpl(\n     override var originalExpression: FirQualifiedAccessExpression,\n-    override val typeRef: FirTypeRef,\n-    override val typesFromSmartCast: Collection<ConeKotlinType>\n+    override val smartcastType: FirTypeRef,\n+    override val typesFromSmartCast: Collection<ConeKotlinType>,\n+    override var smartcastStability: SmartcastStability?", "msg": "IMO this property should be `val` (and `originalExpression` should be `val` too actually).\n\nExpressions with smartcasts (as any other expressions) should not be revisited after they were resolved, so having some mutable state in this class is strange"}
{"patch": "@@ -272,9 +272,11 @@ fun BodyResolveComponents.transformQualifiedAccessUsingSmartcastInfo(\n         return buildExpressionWithSmartcastToNull {\n             originalExpression = qualifiedAccessExpression\n             // TODO: Use Nothing? during resolution?\n-            typeRef = intersectedTypeRefWithoutNullableNothing\n+            smartcastType = intersectedTypeRefWithoutNullableNothing\n             // NB: Nothing? in types from smartcast in DFA is recorded here (and the expression kind itself).\n             this.typesFromSmartCast = typesFromSmartCast\n+            // TODO: differentiate capture local variable\n+            this.smartcastStability = stability.impliedSmartcastStability ?:SmartcastStability.STABLE_VALUE", "msg": "Nit: space after elivs? Below too."}
{"patch": "@@ -667,11 +669,13 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n             parameter<FirExpression>(\"lhs\")\n             parameter<String>(\"operator\")\n             parameter<FirExpression>(\"rhs\")\n+            parameter<FirExpression?>(\"receiverExpression\")", "msg": "I suspect either `receiverExpression` or `lhs` isn't needed here"}
{"patch": "@@ -667,11 +669,13 @@ object DIAGNOSTICS_LIST : DiagnosticList() {\n             parameter<FirExpression>(\"lhs\")\n             parameter<String>(\"operator\")\n             parameter<FirExpression>(\"rhs\")\n+            parameter<FirExpression?>(\"receiverExpression\")\n         }\n         val UNSAFE_OPERATOR_CALL by error<KtExpression>(PositioningStrategy.REFERENCE_BY_QUALIFIED) {\n             parameter<FirExpression>(\"lhs\")\n             parameter<String>(\"operator\")\n             parameter<FirExpression>(\"rhs\")\n+            parameter<FirExpression?>(\"receiverExpression\")", "msg": "I suspect either `receiverExpression` or `lhs` isn't needed here"}
{"patch": "@@ -21,6 +24,20 @@ fun <T : FirElement, D> MutableList<T>.transformInplace(transformer: FirTransfor\n     }\n }\n \n+fun <T : FirElement, D> MutableList<T>.transformInplaceWithPredicate(", "msg": "Please make this function `inline`"}
{"patch": "@@ -614,7 +614,11 @@ object PositioningStrategies {\n     @JvmField\n     val VALUE_ARGUMENTS: PositioningStrategy<KtElement> = object : PositioningStrategy<KtElement>() {\n         override fun mark(element: KtElement): List<TextRange> {\n-            return markElement(element.findDescendantOfType<KtValueArgumentList>()?.rightParenthesis ?: element)\n+            val e = when (element) {", "msg": "Name suggestion: `qualifiedCall` (also for light tree changes)"}
{"patch": "@@ -11,10 +11,8 @@ import org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic\n import org.jetbrains.kotlin.fir.expressions.builder.buildConstExpression\n import org.jetbrains.kotlin.fir.expressions.builder.buildErrorExpression\n import org.jetbrains.kotlin.fir.expressions.builder.buildErrorLoop\n+import org.jetbrains.kotlin.fir.expressions.impl.*", "msg": "Then, I think you can remove `import ...impl.FirBlockImpl` below too?"}
{"patch": "@@ -94,4 +105,21 @@ private object CheckersFactory {\n             }\n         }\n     }\n+\n+    @OptIn(ExperimentalStdlibApi::class)\n+    private inline fun createExpressionCheckers(\n+        createExpressionCheckers: MutableList<ExpressionCheckers>.() -> Unit\n+    ): ExpressionCheckers =\n+        createExpressionCheckers(buildList(createExpressionCheckers))\n+", "msg": "Nit: additional line"}
{"patch": "@@ -0,0 +1,20 @@\n+// WITH_RUNTIME\n+// WITH_COROUTINES\n+// IGNORE_BACKEND: JS_IR", "msg": "```\r\njava.lang.IllegalStateException: ERROR:\r\nTypeError: Cannot read property '_value_2' of undefined\r\n    at _no_name_provided__74.doResume_0_k$ (returnUnboxedFromLambda_v5.js:15119:42)\r\n    at _no_name_provided__74.invoke_sv8swh_k$ (returnUnboxedFromLambda_v5.js:15095:16)\r\n    at _no_name_provided__1_1.l [as _$this_createCoroutineUnintercepted] (returnUnboxedFromLambda_v5.js:15148:16)\r\n    at _no_name_provided__1_1.doResume_2_0_k$ (returnUnboxedFromLambda_v5.js:13518:17)\r\n    at _no_name_provided__1_1.doResume_0_k$ (returnUnboxedFromLambda_v5.js:13521:17)\r\n    at _no_name_provided__1_1.CoroutineImpl_0.resumeWith_jccoe6_k$ (returnUnboxedFromLambda_v5.js:13428:37)\r\n    at _no_name_provided__1_1.CoroutineImpl_0.resumeWith_bnunh2_k$ (returnUnboxedFromLambda_v5.js:13458:17)\r\n    at startCoroutine (returnUnboxedFromLambda_v5.js:2072:19)\r\n    at Object.box (returnUnboxedFromLambda_v5.js:14990:5)\r\n    at (d8):1:10\r\n```"}
{"patch": "@@ -0,0 +1,20 @@\n+// WITH_RUNTIME\n+// WITH_COROUTINES\n+// IGNORE_BACKEND: JS_IR", "msg": "```\r\norg.junit.ComparisonFailure: expected:<[OK]> but was:<[fail: 2]>\r\n```"}
{"patch": "@@ -210,23 +210,14 @@ abstract class PersistentLogicSystem(context: ConeInferenceContext) : LogicSyste\n     }\n \n     @OptIn(DfaInternals::class)\n-    private fun PersistentFlow.getApprovedTypeStatements(variable: RealVariable, parentFlow: PersistentFlow): MutableTypeStatement {\n+    private fun PersistentFlow.getApprovedTypeStatements(variable: RealVariable): MutableTypeStatement {\n         var flow = this\n         val result = MutableTypeStatement(variable)\n         val variableUnderAlias = directAliasMap[variable]\n         if (variableUnderAlias == null) {\n             // get approved type statement even though the starting flow == parent flow", "msg": "This comment becomes stale."}
{"patch": "@@ -29,7 +27,22 @@ internal class FirArgumentListImpl(\n     }\n \n     override fun <D> transformArguments(transformer: FirTransformer<D>, data: D): FirArgumentListImpl {\n-        arguments.transformInplace(transformer, data)\n+        // Transform all normal arguments first and then lambda to make CFG correct. See KT-46825\n+        val mutableListLambdaArgs = mutableListOf<Pair<Int, FirAnonymousFunction>>()", "msg": "Name suggestion: `postponedLambdaArgs`"}
{"patch": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.uast.test.kotlin\n+\n+import org.jetbrains.uast.UFile\n+import org.jetbrains.uast.test.common.kotlin.FirUastIdentifiersTestBase\n+import java.io.File\n+\n+abstract class AbstractFE1UastIdentifiersTest : AbstractKotlinUastTest(), FirUastIdentifiersTestBase {\n+    override val isFirUastPlugin: Boolean = false\n+\n+    override fun check(filePath: String, file: UFile) {\n+        super<FirUastIdentifiersTestBase>.check(filePath, file)\n+    }\n+\n+    override var testDataDir = File(\"plugins/uast-kotlin-fir/testData\")\n+\n+    fun doTest(filePath: String) {\n+        testDataDir = File(filePath).parentFile\n+        val testName = filePath.substring(filePath.lastIndexOf('/') + 1).removeSuffix(\".kt\")", "msg": "Maybe  `val testName  = File(filePath).nameWithoutExtension`"}
{"patch": "@@ -4,7 +4,7 @@ fun foo(arg: Int?) {\n     if (x == null) return\n     run {\n         // Unsafe because of owner modification\n-        x<!UNSAFE_CALL!>.<!>hashCode()\n+        x.hashCode()", "msg": "Need to update the above comment (on `.fir` and original) too? Like `// Safe: since run is in-place`"}
{"patch": "@@ -18,9 +18,15 @@ object StubRenderer {\n             val kDoc = if (shouldExportKDoc) {\n                 descriptor?.extractKDocString()?.let {\n                     if (it.isNotEmpty()) {  // sometimes `findDoc` return empty string; is it a bug?\n+                        assert(it.startsWith(\"/**\") && it.endsWith(\"*/\"))", "msg": "Why add the assert here, if the code below checks the same and gracefully handles the case when it is not true?"}
{"patch": "@@ -82,6 +83,10 @@ internal class LambdaMetafactoryArgumentsBuilder(\n         if (context.irIntrinsics.getIntrinsic(implFun.symbol) != null)\n             return null\n \n+        // Don't generate reference to inlineOnly methods as those do not exist at runtime.\n+        if (implFun.hasAnnotation(INLINE_ONLY_ANNOTATION_FQ_NAME))", "msg": "This should probably be at least `implFun.isEffectivelyInlineOnly()`, because invokedynamic won't work if the function has reified type parameters.\r\n\r\n```\r\nimport java.util.function.Consumer\r\n\r\ninline fun <reified T> foo(x: T) =\r\n    println(\"${T::class.simpleName}($x)\")\r\n\r\nfun call1(c: Consumer<String>, s: String) {\r\n    c.accept(s)\r\n}\r\n\r\nfun main() {\r\n    call1(::foo, \"Hello World!\") // java.lang.UnsupportedOperationException: This function has a reified type parameter and thus can only be inlined at compilation time, not called directly.\r\n}\r\n```\r\n\r\nPlus, if the function is a property accessor, the property has the annotation, not the function (`isEffectivelyInlineOnly` handles that too).\r\n\r\nMaybe it's best not to use invokedynamic with inline functions at all so that they are indeed copied as before?"}
{"patch": "@@ -77,20 +76,25 @@ internal class LambdaMetafactoryArgumentsBuilder(\n         if (samClass.requiresDelegationToDefaultImpls())\n             return null\n \n+        // TODO in cases where LambdaMetafactory is unusable directly due to problems with the implementation function,\n+        //      we can still avoid generating an entire class by converting the function reference into a lambda first;\n+        //      see `InlineCallableReferenceToLambdaPhase`", "msg": "Yes, I've thought about that (and did some performance measurements on artificial projects). The benefit of creating a function reference with `invokedynamic` instead of an explicit class is rather marginal, and, in fact, it might be even a disadvantage in some very specific corner cases, since you effectively move some work from compile time to execution time, while the rest (loading a class, creating an instance, invoking implementation method) remains the same. I see no actual reason to take extra actions (like creating additional methods) just for the sake of using `invokedynamic`.\r\n"}
{"patch": "@@ -50,4 +54,22 @@ internal class KtFirSmartcastProvider(\n             }?.let(::add)\n         }\n     }\n+\n+    override fun getStableNullability(expression: KtExpression): StableNullability {", "msg": "Please, wrap it with `withValidityAssertion { ... }` to check that current analysis session is still valid"}
{"patch": "@@ -1147,6 +1147,10 @@ fun main(args: Array<String>) {\n                 model(\"checker/diagnosticsMessage\", excludedPattern = excludedFirTestdataPattern)\n             }\n \n+            testClass<AbstractHighLevelIntentionTest> {\n+                model(\"intentions/importAllMembers\", pattern = \"^([\\\\w\\\\-_]+)\\\\.(kt|kts)$\")\n+                model(\"intentions/importMember\", pattern = \"^([\\\\w\\\\-_]+)\\\\.(kt|kts)$\")", "msg": "Please, extract this regexp into pattern, so we can easily reuse it for other intentions "}
{"patch": "@@ -29,4 +31,8 @@ interface FirKotlinUastResolveProviderService : BaseKotlinUastResolveProviderSer\n                 return null\n         }\n     }\n+\n+    override fun getExpressionType(uExpression: UExpression): PsiType? {", "msg": "FYI, the future changes regarding this API are here: https://github.com/JetBrains/kotlin/pull/4429"}
{"patch": "@@ -241,26 +299,38 @@ private class ElementsToShortenCollector(private val shorteningContext: FirShort\n             // if qualifier is null, then this type have no package and thus cannot be shortened\n             if (typeElement.qualifier == null) return null\n \n-            val firstFoundClass = shorteningContext.findFirstClassifierInScopesByName(positionScopes, classId.shortClassName)?.classId\n-\n-            if (firstFoundClass == classId) {\n-                return ShortenType(typeElement)\n-            }\n-        }\n-\n-        // none class matched\n-        val (mostTopLevelClassId, mostTopLevelTypeElement) = allClassIds.zip(allTypeElements).last()\n-        val availableClassifier = shorteningContext.findFirstClassifierInScopesByName(positionScopes, mostTopLevelClassId.shortClassName)\n+            val option = classShortenOption(\n+                shorteningContext.firSession.symbolProvider.getClassLikeSymbolByFqName(classId) as? FirRegularClassSymbol ?: return null", "msg": "This is quite long, and you make the same call a few times. Maybe you can add a helper function in `ShorteningContext`?"}
{"patch": "@@ -434,6 +434,35 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com\n     return -(low + 1)  // key not found\n }\n \n+/**\n+ * If this list starts with the given [prefix], returns a view of the portion of this list without [prefix].\n+ * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n+ *\n+ * Structural changes in the base list make the behavior of the view undefined.\n+ */\n+public fun <T> List<T>.removePrefix(prefix: List<T>): List<T> {\n+    return if (this.startWith(prefix)) {\n+        this.subList(prefix.size, this.size)\n+    } else {\n+        this\n+    }\n+}\n+\n+/**\n+ * Returns `true` if this list starts with the specified prefix.\n+ *\n+ * For empty [prefix] returns true\n+ */\n+public fun <T> List<T>.startWith(prefix: List<T>): Boolean {", "msg": "Shouldn't this be \"startsWith\", to be consistent with the current implementation for String?"}
{"patch": "@@ -8,7 +8,14 @@ package org.jetbrains.kotlin.fir.expressions\n import org.jetbrains.kotlin.diagnostics.WhenMissingCase\n \n sealed class ExhaustivenessStatus {\n-    object Exhaustive : ExhaustivenessStatus()\n+    object ProperlyExhaustive : ExhaustivenessStatus()", "msg": "Maybe add a comment for this one too, something like,\r\n```\r\n/**\r\n * This value is used if the subject has type other than `Nothing`, in which case it's literally exhaustive\r\n * only if type's possible cases are properly covered.\r\n */\r\n```"}
{"patch": "@@ -96,7 +96,8 @@ interface KtSymbolProviderMixIn : KtAnalysisSessionMixIn {\n     fun KtClassOrObject.getClassOrObjectSymbol(): KtClassOrObjectSymbol =\n         analysisSession.symbolProvider.getClassOrObjectSymbol(this)\n \n-    fun KtClassOrObject.getNamedClassOrObjectSymbol(): KtNamedClassOrObjectSymbol =\n+    /** Gets the corresponding class or object symbol corresponding or null if the given [ktClassOrObject] is an enum entry. */", "msg": "Nit: I think 2nd `corresponding` is not necessary? Also, `KtClassOrObject` w/ capital K."}
{"patch": "@@ -92,14 +96,34 @@ class FirTypeResolverImpl(private val session: FirSession) : FirTypeResolver() {\n         }\n     }\n \n+    private fun FirQualifierResolver.resolveEnumSymbol(\n+        qualifier: List<FirQualifierPart>,\n+        classId: ClassId\n+    ): FirVariableSymbol<FirEnumEntry>? {\n+        val enumClassSymbol = resolveSymbolWithPrefix(qualifier.dropLast(1), classId) ?: return null\n+        val enumClassFir = enumClassSymbol.fir as? FirRegularClass ?: return null\n+        if (enumClassFir.classKind != ClassKind.ENUM_CLASS) return null", "msg": "```kt\r\nif (!enumClassFir.isEnumClass) return null\r\n```"}
{"patch": "@@ -39,32 +37,25 @@ class InlineCodegenForDefaultBody(\n     }\n \n     override fun genCallInner(callableMethod: Callable, resolvedCall: ResolvedCall<*>?, callDefault: Boolean, codegen: ExpressionCodegen) {\n-        val nodeAndSmap = PsiInlineCodegen(\n-            codegen, state, function, methodOwner, jvmSignature, TypeParameterMappings(), sourceCompilerForInline\n-        ).createInlineMethodNode(\n-            callDefault, null, codegen.typeSystem\n-        )\n-        val childSourceMapper = SourceMapCopier(sourceMapper, nodeAndSmap.classSMAP)\n-\n-        val node = nodeAndSmap.node\n-        val transformedMethod = MethodNode(\n-            node.access,\n-            node.name,\n-            node.desc,\n-            node.signature,\n-            node.exceptions.toTypedArray()\n-        )\n+        val asmMethod = if (callDefault)", "msg": "FYI: Looks like that current default inline scheme is overcompilicated in that sense that it's possible to keep general scheme here with `$default` wrapper that fills default values and then call inline function without any inlining at this step.\r\nAnd only on call site both function could be combined together. But it require some work in compatibility aspect"}
{"patch": "@@ -16,20 +16,23 @@ import org.jetbrains.kotlin.psi.*\n \n class HLSpecifyExplicitTypeForCallableDeclarationIntention :\n     AbstractHLIntention<KtCallableDeclaration, CallableReturnTypeUpdaterApplicator.Type>(\n-        KtCallableDeclaration::class\n+        KtCallableDeclaration::class, applicator", "msg": "Minor formatting: should be placed at new line"}
{"patch": "@@ -40,6 +43,17 @@ interface KtTypeInfoProviderMixIn : KtAnalysisSessionMixIn {\n     val KtType.isString: Boolean get() = isClassTypeWithClassId(DefaultTypeClassIds.STRING)\n     val KtType.isAny: Boolean get() = isClassTypeWithClassId(DefaultTypeClassIds.ANY)\n \n+    val KtType.baseClassSymbol: KtClassOrObjectSymbol?", "msg": "Maybe expandedClassSymbol?\r\nAlso, please add KDoc"}
{"patch": "@@ -37,6 +37,20 @@ class FirSpecificTypeResolverTransformer(\n         }\n     }\n \n+    @set:PrivateForInline\n+    var isOperandOfIsOperator: Boolean = false\n+\n+    @OptIn(PrivateForInline::class)\n+    inline fun <R> withisOperandOfIsOperator(block: () -> R): R {", "msg": "Nit: Capitalize \"I\" in first \"is\""}
{"patch": "@@ -66,7 +80,7 @@ class FirSpecificTypeResolverTransformer(\n     ): FirResolvedTypeRef {\n         functionTypeRef.transformChildren(this, data)\n         session.lookupTracker?.recordTypeLookup(functionTypeRef, data.scopeOwnerLookupNames, currentFile?.source)\n-        val resolvedType = typeResolver.resolveType(functionTypeRef, data, areBareTypesAllowed).takeIfAcceptable()\n+        val resolvedType = typeResolver.resolveType(functionTypeRef, data, areBareTypesAllowed, false).takeIfAcceptable()", "msg": "Nit: Can you name the last parameter? `isOperandOfIsOperator = false`"}
{"patch": "@@ -223,6 +227,11 @@ class FirCallResolver(\n             else -> null\n         }\n \n+", "msg": "Nit: unnecessary new line"}
{"patch": "@@ -166,4 +162,16 @@ fun PsiElement.getKotlinFqName(): FqName? = when (val element = namedUnwrappedEl\n     }\n     is KtNamedDeclaration -> element.fqName\n     else -> null\n+}\n+\n+fun KtDotQualifiedExpression.fqNameSegments(): List<String>? {", "msg": "Maybe add a comment with example? I guess it's like: p.q.Outer.Inner.Companion -> [p, q, Outer, Inner, Companion] (or reversed)?"}
{"patch": "@@ -186,19 +240,32 @@ private class FirShorteningContext(val firResolveState: FirModuleResolveState) {\n     }\n }\n \n-private sealed class ElementToShorten\n-private class ShortenType(val element: KtUserType, val nameToImport: FqName? = null) : ElementToShorten()\n-\n-private class ShortenQualifier(val element: KtDotQualifiedExpression, val nameToImport: FqName? = null) : ElementToShorten() {\n-    fun withElement(newElement: KtDotQualifiedExpression) = ShortenQualifier(newElement, nameToImport)\n+private sealed class ElementToShorten {\n+    abstract val nameToImport: FqName?\n+    abstract val importAllInParent: Boolean", "msg": "NAMING: Again, I would use `useStarImport` here"}
{"patch": "@@ -39,7 +39,8 @@ fun decodePluginOptions(options: String): Map<String, List<String>> {\n         repeat(valueCount) {\n             val size = ois.readInt()\n             val byteArray = ByteArray(size)\n-            values += String(byteArray, StandardCharsets.UTF_8)\n+            val valueBytes = ois.readFully(byteArray)\n+            values += String(valueBytes, StandardCharsets.UTF_8)", "msg": "byteArray should be passed instead of valueBytes, I suppose"}
{"patch": "@@ -358,17 +418,47 @@ private class ElementsToShortenCollector(\n         val callExpression = qualifiedCallExpression.selectorExpression as? KtCallExpression ?: return\n \n         val calleeReference = functionCall.calleeReference\n-        val callableId = findUnambiguousReferencedCallableId(calleeReference) ?: return\n-\n-        val scopes = shorteningContext.findScopesAtPosition(callExpression, namesToImport, towerContextProvider) ?: return\n-        val availableCallables = shorteningContext.findFunctionsInScopes(scopes, callableId.callableName)\n+        val calledSymbol = findUnambiguousReferencedCallableId(calleeReference) ?: return\n+        processQualifiedAccess(calledSymbol, qualifiedCallExpression, callExpression, shorteningContext::findFunctionsInScopes)\n+    }\n \n+    private fun processQualifiedAccess(", "msg": "NAMING: How about `processCallableQualifiedAccess`?"}
{"patch": "@@ -22,8 +22,8 @@ class TestSuperForBase : B() {\n     override fun foo() {\n         super<Base>.foo()\n         super<B>.foo()\n-        super<<!UNRESOLVED_REFERENCE, UNRESOLVED_REFERENCE!>MyBase<!>>.<!UNRESOLVED_REFERENCE!>foo<!>()\n-        <!NOT_A_SUPERTYPE!>super<U><!>.foo()\n+        super<<!NOT_A_SUPERTYPE!>MyBase<!>>.foo()", "msg": "FE1.0 does accept this because the non-top level `MyBase` is resolved in FE1.0. However, FIR does not honor non-top level type alias, hence `MyBase` is rejected here."}
{"patch": "@@ -7,7 +7,7 @@ class Test {\n         val t = object {\n             fun some() {\n                 // See KT-13597\n-                a = \"12\"\n+                <!VAL_REASSIGNMENT!>a<!> = \"12\"", "msg": "This should be captured val initialization, which means the current captured writes detector misses something... Anyway, reporting a different diagnostic would be okay-ish. :\\"}
{"patch": "@@ -10,9 +10,9 @@ class Test {\n \n         run {\n             // Not sure do we need diagnostic also here\n-            this@Test.str = \"B\"\n+            <!VAL_REASSIGNMENT!>this@Test.str<!> = \"B\"", "msg": "`UseCallsInPlaceEffect` is enabled since 1.3, so having the same results with `..._after.fir.kt` is expected."}
{"patch": "@@ -2,11 +2,11 @@ class A(val next: A? = null) {\n     val x: String\n     init {\n         next?.x = \"a\"\n-        x = \"b\"\n-        this.x = \"c\"\n-        x = \"d\" // don't repeat the same diagnostic again with this receiver\n-        this.x = \"e\"\n+        <!VAL_REASSIGNMENT!>x<!> = \"b\"", "msg": "This is a false alarm, and the reason behind this is that property initialization info is kind of aggregated to property symbol only, i.e., property accesses/writes with different receivers aren't differentiated yet. I left a TODO above in a related place. A quick trial reveals this is not a trivial issue. I'll keep working on it, while these changes are reviewed. Seems not harmful for full pipeline at the moment."}
{"patch": "@@ -523,6 +520,7 @@ private val FirSimpleFunction.matchesToStringSignature: Boolean\n \n fun checkTypeMismatch(\n     lValueOriginalType: ConeKotlinType,\n+    assignment: FirVariableAssignment?,\n     rValue: FirExpression,\n     context: CheckerContext,\n     source: FirSourceElement,", "msg": "The `source` parameter here is actually `rValue.source` so you can just remove it so it's not confusing which element's source it is, and just use `rValue.source` everywhere (or a local variable for `rValue.source`)."}
{"patch": "@@ -0,0 +1,2 @@\n+class A(<!ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS!>abstract<!> val i: Int)\n+class B(abstract i: Int)", "msg": "Missing `WRONG_MODIFIER_TARGET`? cc @punzki "}
{"patch": "@@ -111,10 +111,46 @@ class ForLoopsLowering(val context: CommonBackendContext) : BodyLoweringPass {\n     }\n }\n \n+/**\n+ * Abstract class for additional for-loop bodies transformations.\n+ */\n+abstract class ForLoopBodyTransformer : IrElementTransformerVoid() {\n+    protected lateinit var mainLoopVariable: IrVariable\n+    protected lateinit var loopHeader: ForLoopHeader\n+    protected lateinit var loopVariableComponents: Map<Int, IrVariable>\n+    protected lateinit var context: CommonBackendContext\n+\n+    open fun initialize(\n+        context: CommonBackendContext,\n+        loopVariable: IrVariable,\n+        forLoopHeader: ForLoopHeader,\n+        loopComponents: Map<Int, IrVariable>\n+    ) {\n+        this.context = context", "msg": "Maybe you could move this initialization over to `transform` and change this function to `abstract fun analyze(forLoopHeader: ForLoopHeader)`. That way subclasses don't need to remember to call `super.initialize(...)` and also you only need the `ForLoopHeader` for now in `KonanBCEForLoopBodyTransformer`."}
{"patch": "@@ -186,6 +187,39 @@ abstract class KtClassOrObject :\n         parts.reverse()\n         return parts.joinToString(separator = \".\")\n     }\n+\n+    fun getContextReceiverList(): KtContextReceiverList? {\n+        val stub = stub\n+        if (stub != null) {\n+            return getStubOrPsiChild(KtStubElementTypes.CONTEXT_RECEIVER_LIST)", "msg": "You don't need to check if stub != null\n`getStubOrPsiChild` already handle both cases\n\nThat comment may be applied to other similar methods you've added previous commits"}
{"patch": "@@ -0,0 +1,17 @@\n+// !DIAGNOSTICS: -UNUSED_PARAMETER\n+\n+fun <T> listOf(vararg e: T): List<T> = null!!\n+\n+class A<T>\n+\n+context(List<T>)\n+fun <T> A<T>.f() {}\n+\n+fun main() {\n+    with(listOf(1, 2, 3)) {\n+        A<Int>().f()\n+    }\n+    with(listOf(\"1\", \"2\", \"3\")) {\n+        A<Int>().<!NO_CONTEXT_RECEIVER!>f()<!>", "msg": "Are there any cases that start working (green) after this commit applied?\nIf there are ones, maybe it's worth adding them here"}
{"patch": "@@ -0,0 +1,14 @@\n+interface Common\n+interface C1 : Common\n+interface C2 : Common\n+\n+context(Common)\n+fun foo() {}\n+\n+fun Common.bar() {}\n+\n+context(C1, C2)\n+fun test() {\n+    <!MULTIPLE_ARGUMENTS_APPLICABLE_FOR_CONTEXT_RECEIVER!>foo()<!>\n+    bar()", "msg": "I think some kind of receivers ambiguity diagnostic should be there as well\n"}
{"patch": "@@ -0,0 +1,13 @@\n+// WITH_REFLECT", "msg": "Looks like `WITH_REFLECT` is not needed in this test.\r\n\r\nAlso, it fails on the old JS backend (`JsCodegenBoxTestGenerated$DelegatedProperty.testDelegateToAnotherMutable`), please add `IGNORE_BACKEND: JS`"}
{"patch": "@@ -0,0 +1,52 @@\n+// WITH_REFLECT\n+// WITH_RUNTIME", "msg": "`WITH_RUNTIME` is not needed because it's implied by `WITH_REFLECT` (also in `delegateToGenericJavaProperty.kt` and `delegateToAnother.kt`)"}
{"patch": "@@ -478,6 +482,10 @@ class ExpressionCodegen(\n             val parameterType = callable.valueParameterTypes[i]\n             require(arg != null) { \"Null argument in ExpressionCodegen for parameter ${irParameter.render()}\" }\n             callGenerator.genValueAndPut(irParameter, arg, parameterType, this, data)\n+\n+            if (expression.symbol.owner.origin == IrDeclarationOrigin.LOCAL_FUNCTION_FOR_LAMBDA && arg is IrConst<*>) {", "msg": "`IrConst<*>` expression is just a constant literal. It doesn't imply anything about given call expression being a result of direct invoke optimization for a lambda."}
{"patch": "@@ -148,121 +146,59 @@ class JvmOptimizationLowering(val context: JvmBackendContext) : FileLoweringPass\n                     if (left.isNullConst() && right is IrConst<*> || right.isNullConst() && left is IrConst<*>)\n                         return IrConstImpl.constFalse(expression.startOffset, expression.endOffset, context.irBuiltIns.booleanType)\n \n-                    val safeCallLeft = parseSafeCall(left)\n-                    if (safeCallLeft != null && right.type.isJvmPrimitive()) {\n-                        return rewriteSafeCallEqeqPrimitive(safeCallLeft, right, expression)\n-                    }\n-\n-                    val safeCallRight = parseSafeCall(right)\n-                    if (safeCallRight != null && left.type.isJvmPrimitive()) {\n-                        return rewritePrimitiveEqeqSafeCall(left, safeCallRight, expression)\n+                    if (expression.symbol == context.irBuiltIns.eqeqSymbol) {\n+                        if (right.type.isJvmPrimitive()) {", "msg": "Please, add a test with `@EnhancedNullability Int` (`@NotNull Integer getInteger()` in Java)."}
{"patch": "@@ -111,10 +111,25 @@ class ForLoopsLowering(val context: CommonBackendContext) : BodyLoweringPass {\n     }\n }\n \n+/**\n+ * Abstract class for additional for-loop bodies transformations.\n+ */\n+abstract class ForLoopBodyTransformer : IrElementTransformerVoid() {\n+\n+    abstract fun transform(\n+        context: CommonBackendContext,\n+        irExpression: IrExpression,", "msg": "Minor: Could you rename this  to `loopBody`?"}
{"patch": "@@ -49,14 +50,29 @@ class KonanBCEForLoopBodyTransformer : ForLoopBodyTransformer() {\n             irExpression.transformChildrenVoid(this)\n     }\n \n+    private fun IrGetValue.compareConstValue(compare: (IrExpression) -> Boolean): Boolean {\n+        val variable = symbol.owner\n+        return if (variable is IrVariable && !variable.isVar && variable.initializer != null) {\n+            compare(variable.initializer!!)\n+        } else false\n+    }\n+\n     private fun IrExpression.compareIntegerNumericConst(compare: (Long) -> Boolean): Boolean {\n         @Suppress(\"UNCHECKED_CAST\")\n-        return this is IrConst<*> && value is Number && compare((value as Number).toLong())\n+        return when (this) {\n+            is IrConst<*> -> value is Number && compare((value as Number).toLong())\n+            is IrGetValue -> compareConstValue { it.compareIntegerNumericConst(compare) }", "msg": "The changes to check for `val`s are good! Could you please expand on the tests too?"}
{"patch": "@@ -284,98 +353,4 @@ object FloatingPointParser {\n         }\n         return first == '0' && (second == 'x' || second == 'X')\n     }\n-\n-    /**\n-     * Returns the closest double value to the real number in the string.\n-     *\n-     * @param string the String that will be parsed to a floating point\n-     * @return the double closest to the real number\n-     * @exception NumberFormatException if the String doesn't represent a double\n-     */\n-    fun parseDouble(string: String): Double {", "msg": "This was a code duplication, that was unified in one single _inline generic_ method for all types. This logic should be in one place, so we will reduce the number of potential issues."}
{"patch": "@@ -155,16 +249,25 @@ object FloatingPointParser {\n         if (length == 0)\n             throw NumberFormatException(s)\n \n+        // Getting dot separator from the string (E/e)\n         decimal = s.indexOf('.')\n-        if (decimal > -1) {\n+        s = if (decimal > -1) {\n             shift = end - decimal - 1\n             // Prevent e overflow, shift >= 0.\n             if (e >= 0 || e - Int.MIN_VALUE > shift) {\n                 e -= shift\n             }\n-            s = s.substring(start, decimal) + s.substring(decimal + 1, end)\n+            s.substring(start, decimal) + s.substring(decimal + 1, end)\n         } else {\n-            s = s.substring(start, end)\n+            s.substring(start, end)\n+        }\n+\n+        // Optimal validation of characters in the string to prevent incorrect parsing.\n+        // Number after an exponent were validated already.\n+        s.forEach {", "msg": "`s` - is a body of a floating point number, for example in `500e100` - `s` = 500. But there WAS **no check** that it contains valid characters (digits), so we were in the situation when we could start processing of invalid string with a further logic and return `Infinity` in case of long string (`38` characters for `float` and `308` for `double`). "}
{"patch": "@@ -0,0 +1,6 @@\n+// TARGET_BACKEND: JVM_IR\n+\n+val map: Map<String, String> = hashMapOf(\"a\" to \"all\", \"b\" to \"bar\", \"c\" to \"code\")\n+val d: String? by map\n+\n+// 1 @Lorg/jetbrains/annotations/NotNull;()", "msg": "We use codegen/bytecodeListing tests for such cases, it makes ABI comparison between old and new back-end easier."}
{"patch": "@@ -0,0 +1,32 @@\n+// TARGET_BACKEND: JVM_IR", "msg": "Please, add irText tests for a class with context receiver."}
{"patch": "@@ -232,16 +232,21 @@ open class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransform\n             else -> {\n                 val types = components.findTypesForSuperCandidates(superTypeRefs, containingCall)\n                 val resultType = if (types.size == 1) {\n-                    // NB: NOT_A_SUPERTYPE is reported by a separate checker\n                     buildResolvedTypeRef {\n                         source = superReferenceContainer.source?.fakeElement(FirFakeSourceElementKind.SuperCallImplicitType)\n                         type = types.single()\n                     }\n+                } else if (types.size > 1) {", "msg": "Nit: maybe `when(types.size) { ... }` instead of `if ... else if ... else`?"}
{"patch": "@@ -53,9 +73,10 @@ object FirSealedSupertypeChecker : FirClassChecker() {\n                 continue\n             }\n \n-            val classSymbol = context.session.symbolProvider.getClassLikeSymbolByFqName(classId) as? FirRegularClassSymbol ?: continue\n+            val fir = context.session.symbolProvider.getClassLikeSymbolByFqName(classId)", "msg": "Nit: this change made the line shorter, so line wrapping seems not necessary."}
{"patch": "@@ -154,81 +159,117 @@ open class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransform\n     ): FirQualifiedAccessExpression {\n         val labelName = superReference.labelName\n         val implicitReceiver =\n-            if (labelName != null) implicitReceiverStack[labelName] as? ImplicitDispatchReceiverValue\n-            else implicitReceiverStack.lastDispatchReceiver()\n+            // Only report label issues if the lable is set and the receiver stack is not empty", "msg": "```suggestion\r\n            // Only report label issues if the label is set and the receiver stack is not empty\r\n```"}
{"patch": "@@ -154,81 +159,117 @@ open class FirExpressionsResolveTransformer(transformer: FirBodyResolveTransform\n     ): FirQualifiedAccessExpression {\n         val labelName = superReference.labelName\n         val implicitReceiver =\n-            if (labelName != null) implicitReceiverStack[labelName] as? ImplicitDispatchReceiverValue\n-            else implicitReceiverStack.lastDispatchReceiver()\n+            // Only report label issues if the lable is set and the receiver stack is not empty\n+            if (labelName != null && implicitReceiverStack.lastDispatchReceiver() != null) {", "msg": "Calculate `val = implicitReceiverStack.lastDispatchReceiver()` only one time and use it in two places (here and in `else` branch)."}
{"patch": "@@ -135,14 +135,12 @@ class Fir2IrTypeConverter(\n             is ConeCapturedType -> {\n                 val cached = capturedTypeCache[this]\n                 if (cached == null) {\n-                    val irType = lowerType?.toIrType(typeContext) ?: run {", "msg": "Hi @mglukhikh , I am not confident about this change here. Without it, the logic would convert a `Captured<in String>` to a `String`, which seems wrong. It should instead be converted to `Any` instead. I thought about this and it seems to be the case for `out` projection as well. Hence it appears `lowerType` is useless."}
{"patch": "@@ -940,6 +940,19 @@ object PositioningStrategies {\n         }\n     }\n \n+    @OptIn(ExperimentalStdlibApi::class)\n+    val COMMAS: PositioningStrategy<PsiElement> = object : PositioningStrategy<PsiElement>() {\n+        override fun mark(element: PsiElement): List<TextRange> {\n+            return buildList {\n+                for (child in element.allChildren) {\n+                    if (child.node.elementType == KtTokens.COMMA) {\n+                        addAll(super.mark(child))", "msg": "It can be optimized since `mark` always returns only single element:\r\n\r\n```suggestion\r\n                        add(markSingleElement(child))\r\n```\r\n\r\n"}
{"patch": "@@ -186,9 +186,19 @@ class DynamicCallableDescriptors(private val storageManager: StorageManager, bui\n             val funLiteral = funLiteralExpr.functionLiteral\n \n             val receiverType = funLiteral.receiverTypeReference?.let { dynamicType }\n+            val contextReceiversTypes = funLiteral.contextReceivers.map { dynamicType }\n+\n             val parameterTypes = funLiteral.valueParameters.map { dynamicType }\n \n-            return createFunctionType(owner.builtIns, Annotations.EMPTY, receiverType, parameterTypes, null, dynamicType)\n+            return createFunctionType(", "msg": "TODO: Split adding new argument and refactoring"}
{"patch": "@@ -195,8 +215,13 @@ class SimpleCandidateFactory(\n             if (dispatchReceiver == null) ExplicitReceiverKind.NO_EXPLICIT_RECEIVER else ExplicitReceiverKind.DISPATCH_RECEIVER\n \n         return createCandidate(\n-            errorDescriptor, explicitReceiverKind, dispatchReceiver, extensionArgumentReceiver = null,", "msg": "TODO: Split adding new argument and refactoring"}
{"patch": "@@ -32,6 +34,20 @@ internal val annotationImplementationPhase = makeIrFilePhase<JvmBackendContext>(\n \n class JvmAnnotationImplementationTransformer(val jvmContext: JvmBackendContext, file: IrFile) :\n     AnnotationImplementationTransformer(jvmContext, file) {\n+    private val publicAnnotationImplementationClasses = mutableSetOf<IrClassSymbol>()\n+\n+    // FIXME: Copied from JvmSingleAbstractMethodLowering", "msg": "Before someone asks, the problem is that `allScopes` is protected in `IrElementTransformerVoidWithContext` which is in backend.common while `isInPublicInlineScope` is defined in backend.jvm, i.e., we can't define this utility as an extension function without refactoring somewhere. And I don't want to make such a refactoring part of this PR.\r\n"}
{"patch": "@@ -53,9 +72,9 @@ object FirSealedSupertypeChecker : FirClassChecker() {\n                 continue\n             }\n \n-            val classSymbol = context.session.symbolProvider.getClassLikeSymbolByFqName(classId) as? FirRegularClassSymbol ?: continue\n+            val fir = context.session.symbolProvider.getClassLikeSymbolByFqName(classId) as? FirRegularClassSymbol ?: continue", "msg": "Property `fir` has `FirRegularClassSymbol` type. Can you please rename it back?"}
{"patch": "@@ -29,19 +31,29 @@ object FirSealedSupertypeChecker : FirClassChecker() {\n     }\n \n     private fun checkGlobalDeclaration(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {\n-        for (it in declaration.superTypeRefs) {\n-            val classId = it.coneType.classId ?: continue\n+        val subclassPackage = declaration.classId.packageFqName\n+        for (superTypeRef in declaration.superTypeRefs) {\n+            val classId = superTypeRef.coneType.classId ?: continue", "msg": "Super minor: if `classSymbol` below is renamed to `superClass`, isn't it aligned if we renamed this to `superClassId`? :)"}
{"patch": "@@ -1,4 +1,3 @@\n-// IGNORE_BACKEND_FIR: JVM_IR", "msg": "This is probably not related to this PR, looks like someone forgot to update the expected data for this test."}
{"patch": "@@ -19,13 +19,18 @@ public actual inline fun <R> synchronized(lock: Any, block: () -> R): R {\n         callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n     }\n \n+    // Force the lock object into a local and use that local for monitor enter/exit.\n+    // This ensures that the JVM can prove that locking is balanced which is a\n+    // prerequisite for using fast locking implementations. See KT-48367 for details.\n+    val lockLocal = lock", "msg": "Super minor, but do we usually name something like `localLock`? :)"}
{"patch": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.load.java\n+\n+import org.jetbrains.kotlin.builtins.StandardNames\n+import org.jetbrains.kotlin.descriptors.annotations.KotlinTarget\n+import org.jetbrains.kotlin.name.FqName\n+import java.util.concurrent.ConcurrentHashMap\n+\n+typealias TypeQualifierWithApplicability<Annotation> = Pair<Annotation, Set<AnnotationQualifierApplicabilityType>>", "msg": "I don't insist here, but we're trying to use one-capital-letter names for type parameters (e.g. `A` here)\nSame for AbstractAnnotationTypeQualifierResolver\n"}
{"patch": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.load.java.typeEnhancement\n+\n+import org.jetbrains.kotlin.builtins.jvm.JavaToKotlinClassMap\n+import org.jetbrains.kotlin.load.java.AbstractAnnotationTypeQualifierResolver\n+import org.jetbrains.kotlin.load.java.AnnotationQualifierApplicabilityType\n+import org.jetbrains.kotlin.load.java.JavaTypeQualifiersByElementType\n+import org.jetbrains.kotlin.name.FqNameUnsafe\n+import org.jetbrains.kotlin.types.model.KotlinTypeMarker\n+import org.jetbrains.kotlin.types.model.TypeParameterMarker\n+import org.jetbrains.kotlin.types.model.TypeSystemContext\n+import org.jetbrains.kotlin.types.model.TypeVariance\n+\n+abstract class AbstractSignatureParts<Annotation : Any> {", "msg": "ditto about parameter name\n"}
{"patch": "@@ -153,6 +153,26 @@ private class NoExplicitReceiverScopeTowerProcessor<C : Candidate>(\n             ExplicitReceiverKind.NO_EXPLICIT_RECEIVER,\n             data.implicitReceiver\n         )\n+        is TowerData.BothTowerLevelAndContextReceiversGroup -> {\n+            val groupsOfDuplicateCandidates = data.contextReceiversGroup.flatMap { receiver ->", "msg": "Please, add `BothTowerLevelAndContextReceiversGroup` case to the when at `recordLookups` below, too"}
{"patch": "@@ -387,11 +387,9 @@ class FunctionGenerator(declarationGenerator: DeclarationGenerator) : Declaratio\n         val constantDefaultValue =\n             ConstantExpressionEvaluator.getConstant(valueExpression, context.bindingContext)?.toConstantValue(valueParameterDescriptor.type)\n                 ?: error(\"Constant value expected for default parameter value in annotation, got $valueExpression\")\n-        return context.irFactory.createExpressionBody(\n-            UNDEFINED_OFFSET, UNDEFINED_OFFSET,\n-            context.constantValueGenerator.generateConstantValueAsExpression(\n-                UNDEFINED_OFFSET, UNDEFINED_OFFSET, constantDefaultValue, valueParameterDescriptor.varargElementType\n-            )\n-        )\n+        val converted = context.constantValueGenerator.generateAnnotationValueAsExpression(\n+            UNDEFINED_OFFSET, UNDEFINED_OFFSET, constantDefaultValue, valueParameterDescriptor\n+        ) ?: error(\"Could not convert annotation default $valueExpression\")", "msg": "`$valueExpression` will always just print the node type, consider adding `getElementTextWithContext()` and/or info about `valueParameterDescriptor`"}
{"patch": "@@ -611,7 +611,7 @@ class KmValueParameter(\n      * @param visitor the visitor which will visit data in this value parameter\n      */\n     fun accept(visitor: KmValueParameterVisitor) {\n-        type?.let { visitor.visitType(it.flags)?.let(it::accept) }\n+        type.let { visitor.visitType(it.flags)?.let(it::accept) }", "msg": "I guess the `let` call can be inlined now for simplicity\r\n```suggestion\r\n        visitor.visitType(type.flags)?.let(type::accept)\r\n```"}
{"patch": "@@ -209,6 +209,8 @@ class NewCapturedType(\n \n     override val arguments: List<TypeProjection> get() = listOf()\n \n+    override val attributes: TypeAttributes = annotations.toAttributes()", "msg": "Same"}
{"patch": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.codegen\n+\n+import org.jetbrains.kotlin.utils.threadLocal\n+\n+object AsmTypeInfo {\n+    private val mappings by threadLocal { mutableMapOf<String, MutableSet<String>>() }\n+\n+    fun put(type: String, superType: String) {\n+        if (mappings[type] == null) {\n+            mappings[type] = mutableSetOf()\n+        }\n+        mappings[type]!!.add(superType)\n+    }\n+\n+    fun isSubType(type: String, superType: String): Boolean {\n+        // ASM caches the result of getCommonSuperClass, so it is safe to do remove\n+        val result = mappings[type]?.remove(superType) == true\n+        if (result && mappings[type]!!.isEmpty()) {\n+            mappings.remove(type)\n+        }\n+        return result", "msg": "Can be rewritten by the following way without redundant access to the map:\r\n\r\n```suggestion\r\n        // ASM caches the result of getCommonSuperClass, so it is safe to do remove\r\n        val mapping = mappings[type]\r\n        if (mapping != null) {\r\n            val result = mapping.remove(superType)\r\n            if (mapping.isEmpty()) {\r\n                mappings.remove(type)\r\n            }\r\n            return result\r\n        }\r\n        return false\r\n```"}
{"patch": "@@ -275,6 +275,23 @@ class KonanConfig(val project: Project, val configuration: CompilerConfiguration\n     internal val propertyLazyInitialization: Boolean get() = configuration.get(KonanConfigKeys.PROPERTY_LAZY_INITIALIZATION)!!\n \n     internal val lazyIrForCaches: Boolean get() = configuration.get(KonanConfigKeys.LAZY_IR_FOR_CACHES)!!\n+\n+    internal val entryPointName: String by lazy {\n+        if (target.family == Family.ANDROID) {\n+            val androidProgramTypeOrNull = configuration.get(BinaryOptions.androidProgramType)\n+            if (androidProgramTypeOrNull == null) {\n+                configuration.report(CompilerMessageSeverity.WARNING,\n+                        \"Android Native executables are currently built as shared libraries with NativeActivity support, but the \" +", "msg": "The absolute majority of our users invoke compiler via Gradle, so it makes sense to show how to adjust Gradle script instead of compiler flag. Let's change the message to the following:\r\n\r\n> Android Native executables are currently built as shared libraries with NativeActivity support, but the default behavior is going to change in 1.7.0 to build regular executables instead.\r\n> To keep using NativeActivity support, add `binaryOptions[\"androidProgramType\"] = \"nativeActivity\"` to your androidNative executable configuration block in Gradle script:\r\n> ```\r\n> binaries {\r\n>     executable {\r\n>         binaryOptions[\"androidProgramType\"] = \"nativeActivity\"\r\n>     }\r\n> }\r\n> ```\r\n> See https://youtrack.jetbrains.com/issue/KT-49406 for more details.\r\n\r\nI'll populate the YouTrack ticket with a content (including other ways to tune the compiler behavior) a bit later."}
{"patch": "@@ -145,8 +145,8 @@ class AndroidLinker(targetProperties: AndroidConfigurables)\n         return listOf(Command(clang).apply {\n             +\"-o\"\n             +executable\n-            +\"-fPIC\"\n-            +\"-shared\"\n+            if (dynamic) +\"-fPIC\" else +listOf(\"-fPIE\", \"-pie\")\n+            if (dynamic) +\"-shared\"", "msg": "Let's change these lines to something like this:\r\n```kotlin\r\nwhen (kind) {\r\n    LinkerOutputKind.EXECUTABLE -> +listOf(\"-fPIE\", \"-pie\")\r\n    LinkerOutputKind.DYNAMIC_LIBRARY -> +listOf(\"-fPIC\", \"-shared\")\r\n    LinkerOutputKind.STATIC_LIBRARY -> {}\r\n}\r\n```\r\nMotivation:\r\n* It is more explicit that we add these flags only when producing executables.\r\n* Nothing will go wrong if we add another `LinkerOutputKind`."}
{"patch": "@@ -28,8 +30,17 @@ interface IrLazyFunctionBase : IrLazyDeclarationBase, IrTypeParametersContainer\n \n     fun createValueParameters(): List<IrValueParameter> =\n         typeTranslator.buildWithScope(this) {\n-            descriptor.valueParameters.mapTo(arrayListOf()) {\n-                stubGenerator.generateValueParameterStub(it).apply { parent = this@IrLazyFunctionBase }\n+            val result = arrayListOf<IrValueParameter>()", "msg": "@dnpetrov Please, take a look at this part"}
{"patch": "@@ -245,6 +245,10 @@ internal class ObjCExportCodeGenerator(\n         return irFunction?.name?.asString()\n     }\n \n+    internal val unitContinuationToRetainedCompletionConverter: LLVMValueRef by lazy {", "msg": "Please put this property just after `continuationToRetainedCompletionConverter`, to improve the readability."}
{"patch": "@@ -117,20 +119,22 @@ private suspend fun callSuspendBridgeImpl(bridge: SuspendBridge<Int>) {\n     assertEquals(1, bridge.intAsAny(1))\n \n     assertSame(Unit, bridge.unitAsAny(2))\n+    assertSame(Unit, bridge.nullableUnit(3))", "msg": "Please add a test for calling `unit` method. Not sure why is it missing."}
{"patch": "@@ -23,6 +23,8 @@ object BinaryOptions : BinaryOptionRegistry() {\n     val sourceInfoType by option<SourceInfoType>()\n \n     val androidProgramType by option<AndroidProgramType>()\n+\n+    val unitSuspendFunctionExport by option<UnitSuspendFunctionExport>()", "msg": "The option name should indicate that it affects only Obj-C export. E.g. `unitSuspendFunctionObjCExport`."}
{"patch": "@@ -957,6 +975,8 @@ private fun ObjCExportCodeGenerator.generateObjCImp(\n     var errorOutPtr: LLVMValueRef? = null\n     var continuation: LLVMValueRef? = null\n \n+    // val properlyExportUnitSuspendFunctions = codegen.context.config.unitSuspendFunctionObjCExport == UnitSuspendFunctionObjCExport.PROPER", "msg": "Leftover."}
{"patch": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.fir.resolve\n+\n+import org.jetbrains.kotlin.fir.FirSession\n+import org.jetbrains.kotlin.fir.declarations.FirRegularClass\n+import org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider\n+import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider\n+import org.jetbrains.kotlin.fir.symbols.ConeClassLikeLookupTag\n+import org.jetbrains.kotlin.fir.symbols.ConeClassifierLookupTag\n+import org.jetbrains.kotlin.fir.symbols.ConeClassifierLookupTagWithFixedSymbol\n+import org.jetbrains.kotlin.fir.symbols.impl.*\n+import org.jetbrains.kotlin.util.WeakPair\n+\n+fun ConeClassifierLookupTag.toSymbol(useSiteSession: FirSession): FirClassifierSymbol<*>? =", "msg": "Remove this file from commit, because it was moved from `:resolve` module to `:providers` (`compiler/fir/providers/src/org/jetbrains/kotlin/fir/resolve/LookupTagUtils.kt`)"}
{"patch": "@@ -30,3 +30,4 @@ class CustomAnnotationTypeAttribute(val annotations: List<FirAnnotation>) : Cone\n val ConeAttributes.custom: CustomAnnotationTypeAttribute? by ConeAttributes.attributeAccessor<CustomAnnotationTypeAttribute>()\n \n val ConeAttributes.customAnnotations: List<FirAnnotation> get() = custom?.annotations.orEmpty()\n+", "msg": "Should be moved into previous commit"}
{"patch": "@@ -610,6 +610,22 @@ interface ClassicTypeSystemContext : TypeSystemInferenceExtensionContext, TypeSy\n         return IntegerLiteralTypeConstructor.findCommonSuperType(explicitSupertypes)\n     }\n \n+    override fun unionTypeAttributes(types: List<KotlinTypeMarker>): List<AnnotationMarker> {\n+        @Suppress(\"UNCHECKED_CAST\")\n+        types as List<KotlinType>", "msg": "It's more clean to write cast right inside recievier of `map` call. `(types as List<KotlinType>).map {...}...`"}
{"patch": "@@ -610,6 +610,22 @@ interface ClassicTypeSystemContext : TypeSystemInferenceExtensionContext, TypeSy\n         return IntegerLiteralTypeConstructor.findCommonSuperType(explicitSupertypes)\n     }\n \n+    override fun unionTypeAttributes(types: List<KotlinTypeMarker>): List<AnnotationMarker> {\n+        @Suppress(\"UNCHECKED_CAST\")\n+        types as List<KotlinType>\n+        return types.map { it.unwrap().attributes }.reduce { x, y -> x.union(y) }.toList()\n+    }\n+\n+    override fun KotlinTypeMarker.replaceTypeAttributes(newAttributes: List<AnnotationMarker>): KotlinTypeMarker {\n+        require(this is KotlinType)\n+        val typeAttributes = newAttributes.filterIsInstance<TypeAttribute<*>>()", "msg": "You can unsafely cast `newAttributes` to `List<TypeAttribute<*>>` here"}
{"patch": "@@ -395,6 +395,20 @@ interface ConeInferenceContext : TypeSystemInferenceExtensionContext, ConeTypeCo\n         return ConeIntegerLiteralTypeImpl.findCommonSuperType(explicitSupertypes)\n     }\n \n+    override fun unionTypeAttributes(types: List<KotlinTypeMarker>): List<AnnotationMarker> {\n+        @Suppress(\"UNCHECKED_CAST\")\n+        types as List<ConeKotlinType>", "msg": "Same"}
{"patch": "@@ -395,6 +395,20 @@ interface ConeInferenceContext : TypeSystemInferenceExtensionContext, ConeTypeCo\n         return ConeIntegerLiteralTypeImpl.findCommonSuperType(explicitSupertypes)\n     }\n \n+    override fun unionTypeAttributes(types: List<KotlinTypeMarker>): List<AnnotationMarker> {\n+        @Suppress(\"UNCHECKED_CAST\")\n+        types as List<ConeKotlinType>\n+        return types.map { it.attributes }.reduce { x, y -> x.union(y) }.toList()\n+    }\n+\n+    override fun KotlinTypeMarker.replaceTypeAttributes(newAttributes: List<AnnotationMarker>): KotlinTypeMarker {\n+        require(this is ConeKotlinType)\n+        val typeAttributes = newAttributes.filterIsInstance<ConeAttribute<*>>()", "msg": "Same"}
{"patch": "@@ -79,6 +80,8 @@ fun StorageComponentContainer.configureModule(\n     analyzerServices.platformConfigurator.configureModuleComponents(this)\n     analyzerServices.platformConfigurator.configureModuleDependentCheckers(this)\n \n+    useInstance(TypeAttributeTranslators(moduleContext.project))", "msg": "It's better to use `useImpl<TypeAttributeTranslators>()` here. `project` will be injected automatically"}
{"patch": "@@ -386,11 +390,16 @@ interface IrTypeSystemContext : TypeSystemContext, TypeSystemCommonSuperTypesCon\n     override fun SimpleTypeMarker.isPrimitiveType(): Boolean =\n         this is IrSimpleType && irTypePredicates_isPrimitiveType()\n \n-    override fun KotlinTypeMarker.getAnnotations(): List<AnnotationMarker> {\n+    override fun KotlinTypeMarker.getAttributes(): List<AnnotationMarker> {\n         require(this is IrType)\n         return this.annotations.map { object : AnnotationMarker, IrElement by it {} }\n     }\n \n+    override fun KotlinTypeMarker.getCustomAttributes(): List<AnnotationMarker> {\n+        require(this is IrType)\n+        return emptyList() // TODO: Ir does not currently support custom non-annotation attributes.", "msg": "It's not `TODO`. IR backed should not support attributes by design"}
{"patch": "@@ -60,7 +60,12 @@ class MutableVariableWithConstraints private constructor(\n                 && previousConstraint.isNullabilityConstraint == constraint.isNullabilityConstraint\n             ) {\n                 if (newConstraintIsUseless(previousConstraint, constraint)) {\n-                    return previousConstraint to false\n+                    // Preserve constraints with different custom type attributes.\n+                    // This allows us to union type attributes in NewCommonSuperTypeCalculator.kt\n+                    with(context) {\n+                        if (previousConstraint.type.getCustomAttributes() == constraint.type.getCustomAttributes())", "msg": "Maybe it's better to replace `getCustomAttributes` with `hasCustomAttributes` and only then filter attributes?"}
{"patch": "@@ -49,6 +49,9 @@ object BuiltinSpecialBridgesUtil {\n         signatureByDescriptor: (FunctionDescriptor) -> Signature,\n         state: GenerationState\n     ): Set<BridgeForBuiltinSpecial<Signature>> {\n+//        if (function.name.asString() == \"get\" && function.containingDeclaration.name.asString() == \"B\") {", "msg": "Minor: dropped."}
{"patch": "@@ -81,7 +81,8 @@ class FieldPropertyLValue(\n     PropertyLValueBase(context, scope, startOffset, endOffset, origin, type, callReceiver, superQualifier) {\n \n     override fun load(): IrExpression =\n-        callReceiver.call { dispatchReceiverValue, extensionReceiverValue ->\n+        // TODO: Use context receiver values\n+        callReceiver.call { dispatchReceiverValue, extensionReceiverValue, _ ->", "msg": "`FieldPropertyLValue` is created for Java fields. Such properties should not have context receivers. Add an assertion here that `contextReceiverValues.isEmpty()`."}
{"patch": "@@ -22,5 +22,15 @@ import org.jetbrains.kotlin.descriptors.FunctionDescriptor\n class EvaluatorFragmentInfo(\n     val classDescriptor: ClassDescriptor,\n     val methodDescriptor: FunctionDescriptor,\n-    val parameters: List<DeclarationDescriptor>\n-)\n\\ No newline at end of file\n+    val parameters: List<EvaluatorFragmentParameterInfo>,\n+)\n+\n+data class EvaluatorFragmentParameterInfo(\n+    val descriptor: DeclarationDescriptor,\n+    val isLValue: Boolean,\n+) {\n+    // Used from IntelliJ Debugger Plug-in.\n+    // TODO: Remove when intellij-community#1839 lands.\n+    @Suppress(\"unused\")\n+    constructor(descriptor: DeclarationDescriptor) : this(descriptor, false)", "msg": "Ignore this, will revert. Completely misread the problem :sweat_smile: \r\n"}
{"patch": "@@ -437,9 +437,9 @@ fun getDeclarationLabels(lambdaOrFun: PsiElement?, descriptor: DeclarationDescri\n     val result = HashSet<String>()\n \n     if (lambdaOrFun != null) {\n-        val label = LabelResolver.getLabelNameIfAny(lambdaOrFun)\n-        if (label != null) {\n-            result.add(label.asString())\n+        val label = LabelResolver.getLabelNamesIfAny(lambdaOrFun, addClassNameLabels = false)\n+        if (label.isNotEmpty()) {\n+            result.add(label.single().asString())", "msg": "Put separate check for `label.size > 1` and report an error"}
{"patch": "@@ -16,9 +16,7 @@\n \n package org.jetbrains.kotlin.resolve.calls.inference\n \n-import org.jetbrains.kotlin.builtins.createFunctionType\n-import org.jetbrains.kotlin.builtins.isBuiltinExtensionFunctionalType\n-import org.jetbrains.kotlin.builtins.isSuspendFunctionType\n+import org.jetbrains.kotlin.builtins.*", "msg": "Revert"}
{"patch": "@@ -76,6 +77,10 @@ class NewCallableReferenceResolvedCall<D : CallableDescriptor>(\n         extensionReceiver = extensionReceiver?.replaceType(newType)\n     }\n \n+    override fun updateContextReceiverTypes(newTypes: List<KotlinType>) {\n+        return", "msg": "Put `TODO: Update context receivers`"}
{"patch": "@@ -19,6 +19,8 @@ package org.jetbrains.kotlin.resolve.calls.model\n import org.jetbrains.kotlin.builtins.KotlinBuiltIns\n import org.jetbrains.kotlin.builtins.ReflectionTypes\n import org.jetbrains.kotlin.config.LanguageVersionSettings\n+import org.jetbrains.kotlin.descriptors.CallableDescriptor\n+import org.jetbrains.kotlin.descriptors.ClassConstructorDescriptor", "msg": "Remove"}
{"patch": "@@ -92,7 +96,7 @@ interface ScopeTowerLevel {\n class CandidateWithBoundDispatchReceiver(\n     val dispatchReceiver: ReceiverValueWithSmartCastInfo?,\n     val descriptor: CallableDescriptor,\n-    val diagnostics: List<ResolutionDiagnostic>\n+    val diagnostics: MutableList<ResolutionDiagnostic>", "msg": "Can I revert it to `List`?"}
{"patch": "@@ -214,7 +214,7 @@ private fun ImplicitScopeTower.getExtensionInvokeCandidateDescriptor(\n             ?: error(\"No single synthesized invoke for $invokeDescriptor: $synthesizedInvokes\")\n \n     // here we don't add SynthesizedDescriptor diagnostic because it should has priority as member\n-    return CandidateWithBoundDispatchReceiver(extensionFunctionReceiver, synthesizedInvoke, listOf())\n+    return CandidateWithBoundDispatchReceiver(extensionFunctionReceiver, synthesizedInvoke, mutableListOf())", "msg": "Revert (see the comment above)"}
{"patch": "@@ -317,15 +317,27 @@ internal class DescriptorRendererImpl(\n \n     private fun StringBuilder.renderFunctionType(type: KotlinType) {", "msg": "What about rendering functions, classes, and properties with context receivers?"}
{"patch": "@@ -145,6 +145,15 @@ var KmProperty.syntheticMethodForAnnotations: JvmMethodSignature?\n         jvm.syntheticMethodForAnnotations = value\n     }\n \n+/**\n+ * TODO: WHAT IS AN EXAMPLE OF THIS?", "msg": "```suggestion\r\n * JVM signature of a synthetic method for properties which delegate to another property,\r\n * which constructs and returns a property reference object.\r\n * See https://kotlinlang.org/docs/delegated-properties.html#delegating-to-another-property.\r\n *\r\n * Example: `JvmMethodSignature(\"getX$delegate\", \"()Ljava/lang/Object;\")`.\r\n```"}
{"patch": "@@ -395,5 +396,15 @@ fun main(args: Array<String>) {\n                 model(\"box\")\n             }\n         }\n+\n+        testGroup(\n+            \"plugins/atomicfu/atomicfu-compiler/test\",", "msg": "Probably only `*/testData/` required here "}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{\n+            it.isWhitespace()\n+        }\n+        assertFalse(containsWhiteSpace)\n+\n+        val isLowerCase: (Char) -> Boolean = Char::isLowerCase\n+        val charSequence = \"Ariya\"\n+        assertFalse(charSequence.all(isLowerCase))", "msg": "Could the function reference `Char::isLowerCase` be passed to `CharSequence.all` directly?\r\nThe introduction of a separate `val` doesn't seem to enhance clarity."}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{\n+            it.isWhitespace()\n+        }\n+        assertFalse(containsWhiteSpace)\n+\n+        val isLowerCase: (Char) -> Boolean = Char::isLowerCase\n+        val charSequence = \"Ariya\"\n+        assertFalse(charSequence.all(isLowerCase))\n+\n+        val containsAllCharsOf: String.(String) -> Boolean = { bigger ->", "msg": "Introducing a named function is more Kotlin-ish than creating a lambda just to assign it to a `val`:\r\n```\r\nfun String.containsAllCharsOf(other: String): Boolean {\r\n    return other.all { this.contains(it) }\r\n}\r\n```"}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{\n+            it.isWhitespace()\n+        }\n+        assertFalse(containsWhiteSpace)\n+\n+        val isLowerCase: (Char) -> Boolean = Char::isLowerCase\n+        val charSequence = \"Ariya\"\n+        assertFalse(charSequence.all(isLowerCase))\n+\n+        val containsAllCharsOf: String.(String) -> Boolean = { bigger ->\n+            bigger.all { this.contains(it) }\n+        }\n+        val sentence = \"This is a short string.\"\n+        val line = \"This is a long string with lot's of characters.\"\n+        assertTrue(line.containsAllCharsOf(sentence))\n+\n+        val allSentenceCharsInsideLine = sentence.all {", "msg": "Is it equivalent to `line.containsAllCharsOf(sequence)`? Reusing the existing function would be better."}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{\n+            it.isWhitespace()\n+        }\n+        assertFalse(containsWhiteSpace)", "msg": "In samples we use `assertPrints(value, stringRepresentation)` which is converted to \r\n```\r\nprintln(value) // stringRepresentation\r\n```\r\nin Kotlin website. E.g. the `splitToSequence` sample above is converted to this runnable code in docs website: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split-to-sequence.html"}
{"patch": "@@ -507,4 +507,29 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        val name = \"fatima\"\n+        val containsWhiteSpace: Boolean = name.any{", "msg": "Could we use `assertPrints(name.any { it.isWhitespace() }, false)` directly?"}
{"patch": "@@ -0,0 +1,29 @@\n+// TARGET_BACKEND: JVM_IR\n+// WITH_STDLIB\n+// WITH_REFLECT\n+// FULL_JDK\n+\n+annotation class Ann1(val value: UByte = 41u)\n+annotation class Ann2(val value: UShort = 42u)\n+annotation class Ann3(val value: UInt = 43u)\n+annotation class Ann4(val value: ULong = 44u)\n+\n+@Ann1\n+@Ann2\n+@Ann3\n+@Ann4\n+class A\n+\n+fun box(): String {\n+    val default1 = A::class.java.getDeclaredAnnotation(Ann1::class.java).value", "msg": "`Class.getDeclaredAnnotation` is missing on JDK6 and older versions of Android, so the corresponding tests (`compiler/tests-different-jdk`, `compiler/android-tests`) are failing. Let's use `Class.getAnnotation` instead"}
{"patch": "@@ -200,4 +202,15 @@ private val Framework.namePrefix: String\n     )\n \n private fun Project.appleFrameworkDir(frameworkSearchDir: File) =\n-    buildDir.resolve(\"xcode-frameworks\").resolve(frameworkSearchDir)\n\\ No newline at end of file\n+    buildDir.resolve(\"xcode-frameworks\").resolve(frameworkSearchDir)\n+\n+private fun Project.copyFiles(files: Array<File>, destDir: File) {", "msg": "It would be perfect to add comment about symlinks behavior with YouTrack issue ID."}
{"patch": "@@ -144,23 +146,26 @@ fun KotlinType.replace(\n ): KotlinType {\n     if ((newArguments.isEmpty() || newArguments === arguments) && newAnnotations === annotations) return this\n \n+    val newAttributes = attributes.replaceAnnotations(\n+        // Specially handle FilteredAnnotations here due to FilteredAnnotations.isEmpty()\n+        if (newAnnotations is FilteredAnnotations && newAnnotations.isEmpty()) Annotations.EMPTY else newAnnotations", "msg": "There is a strange(?) implementation of FilteredAnnotations.isEmpty() that some of the tests rely on: https://github.com/JetBrains/kotlin/blob/master/core/descriptors/src/org/jetbrains/kotlin/descriptors/annotations/Annotations.kt#L71"}
{"patch": "@@ -200,4 +203,32 @@ private val Framework.namePrefix: String\n     )\n \n private fun Project.appleFrameworkDir(frameworkSearchDir: File) =\n-    buildDir.resolve(\"xcode-frameworks\").resolve(frameworkSearchDir)\n\\ No newline at end of file\n+    buildDir.resolve(\"xcode-frameworks\").resolve(frameworkSearchDir)\n+\n+/**\n+ * macOS frameworks contain symlinks which are resolved/removed by the Gradle [Copy] task.\n+ * To preserve these symlinks we are using the `cp` command instead.\n+ * See https://youtrack.jetbrains.com/issue/KT-48594.\n+ */\n+private abstract class FrameworkCopy : DefaultTask() {\n+\n+    @get:InputFiles\n+    var files: FileCollection? = null", "msg": "We need little bit more checks :) and since the task is abstract we can avoid nullability\r\n```\r\n@get:PathSensitive(PathSensitivity.ABSOLUTE)\r\n@get:IgnoreEmptyDirectories\r\n@get:InputFiles\r\n@get:SkipWhenEmpty\r\nabstract var files: FileCollection\r\n\r\n@get:OutputDirectory\r\nabstract var destDir: File\r\n```"}
{"patch": "@@ -176,11 +180,10 @@ internal fun Project.registerEmbedAndSignAppleFrameworkTask(framework: Framework\n \n     embedAndSignTask.configure { task ->\n         task.dependsOn(assembleTask)\n-        task.from(appleFrameworkDir(envFrameworkSearchDir)) { it.include(framework.outputFile.name + \"/**\") }\n-        task.into(envEmbeddedFrameworksDir)\n-\n-        if (envSign != null) {\n-            task.doLast {\n+        task.files = files(File(appleFrameworkDir(envFrameworkSearchDir), framework.outputFile.name))\n+        task.destDir = envEmbeddedFrameworksDir\n+        task.doLast {\n+            if (envSign != null) {", "msg": "i think better:\r\n```\r\nif (envSign != null) task.doLast {\r\n```"}
{"patch": "@@ -320,7 +320,14 @@ class RegexTest {\n     @Test fun replaceEvaluator() {\n         val input = \"/12/456/7890/\"\n         val pattern = \"\\\\d+\".toRegex()\n-        assertEquals(\"/2/3/4/\", pattern.replace(input, { it.value.length.toString() }))\n+        assertEquals(\"/2/3/4/\", pattern.replace(input) { it.value.length.toString() })\n+    }\n+\n+    @Test fun replaceFirstEvaluator() {\n+        val pattern = \"\\\\d+\".toRegex()\n+        assertEquals(\"no_match\", pattern.replaceFirst(\"no_match\") { it.value.length.toString() })\n+        assertEquals(\"6\", pattern.replaceFirst(\"012345\") { it.value.length.toString() })\n+        assertEquals(\"abc[123]de\", pattern.replaceFirst(\"abc123de\") { \"[${it.value}]\" })", "msg": "Makes sense to check an input string of \"abc123de56\" to ensure that only the _first_ match is actually replaced."}
{"patch": "@@ -689,7 +691,9 @@ private fun getInlineFunctionsMap(header: KotlinClassHeader, bytes: ByteArray):\n             desc: String,\n             signature: String?,\n             exceptions: Array<out String>?\n-        ): MethodVisitor {\n+        ): MethodVisitor? {\n+            if (access and Opcodes.ACC_PRIVATE == Opcodes.ACC_PRIVATE) return null", "msg": "Nice, reducing the size of the cache!"}
{"patch": "@@ -67,7 +64,23 @@ internal class RangeToHandler(private val context: CommonBackendContext) :\n             if (preferJavaLikeCounterLoop || this.constLongValue == -1L) return null\n         }\n \n-        val irConst = this as? IrConst<*> ?: return null\n+        return when (this) {\n+            is IrConst<*> -> convertIrConst(this)\n+            is IrCall -> convertIrCall(this)\n+            else -> null\n+        }\n+    }\n+\n+    private fun convertIrCall(irCall: IrCall): IrExpression? {\n+        return if (irCall.origin == IrStatementOrigin.MINUS && (irCall.getValueArgument(0) as? IrConst<*>)?.value == 1)", "msg": "That might be a bit too optimistic because of possible underflow.\r\nPlease, add the following test:\r\n```\r\nfun box(): String {\r\n    val M1 = Int.MAX_VALUE - 2\r\n    val M2 = Int.MIN_VALUE\r\n    var t = 0\r\n    for (x in M1..M2-1) {\r\n        ++t\r\n        if (t > 3) return \"Failed: too many iterations\"\r\n    }\r\n    if (t != 3) return \"Failed: t=$t\"\r\n    return \"OK\"\r\n}\r\n```\r\nWe are not going to do proper value range analysis here. However, there are some relatively frequent practical cases when we know for sure that `expr - 1` will never underflow. In particular KT-22334 listed one such example (`array.size - 1`; can never underflow because `array.size` is always non-negative). Same is true about `collection.size` and `charSequence.size`."}
{"patch": "@@ -75,7 +78,20 @@ internal class ArrayIterationHandler(context: CommonBackendContext) : IndexedGet\n     private val supportsUnsignedArrays = context.optimizeLoopsOverUnsignedArrays\n \n     override fun matchIterable(expression: IrExpression) =\n-        expression.type.run { isArray() || isPrimitiveArray() || (supportsUnsignedArrays && isUnsignedArray()) }\n+        expression.type.run { isArray() || isPrimitiveArray() || (supportsUnsignedArrays && isUnsignedArray()) } || expression.run {", "msg": "Minor: I'd rather write it as \r\n```\r\nexpression.type.run { ... } ||\r\n    expression.run { ... }\r\n```\r\notherwise it's somewhat harder to understand that the last `||` is not actually a part of condition under `expression.type.run { ... }`.    "}
{"patch": "@@ -75,7 +78,20 @@ internal class ArrayIterationHandler(context: CommonBackendContext) : IndexedGet\n     private val supportsUnsignedArrays = context.optimizeLoopsOverUnsignedArrays\n \n     override fun matchIterable(expression: IrExpression) =\n-        expression.type.run { isArray() || isPrimitiveArray() || (supportsUnsignedArrays && isUnsignedArray()) }\n+        expression.type.run { isArray() || isPrimitiveArray() || (supportsUnsignedArrays && isUnsignedArray()) } || expression.run {\n+            this is IrCall && matcher(this)\n+        }\n+\n+    private val matcher =", "msg": "Minor: give it a meaningful name - not just `matcher`, but something like `reversedArrayMatcher`."}
{"patch": "@@ -18,10 +18,9 @@ package org.jetbrains.kotlin.ir.declarations.impl\n \n import org.jetbrains.kotlin.descriptors.ModuleDescriptor\n import org.jetbrains.kotlin.ir.IrBuiltIns\n+import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI", "msg": "unused"}
{"patch": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+//This file was generated automatically\n+//DO NOT MODIFY IT MANUALLY\n+\n+package org.jetbrains.kotlin.ir.expressions\n+\n+import org.jetbrains.kotlin.ir.visitors.IrElementVisitor\n+\n+/**\n+ * A leaf IR tree element.\n+ * @sample org.jetbrains.kotlin.ir.generator.IrTree.getValue\n+ */\n+abstract class IrGetValue : IrValueAccessExpression() {\n+    override fun <R, D> accept(visitor: IrElementVisitor<R, D>, data: D): R =\n+        visitor.visitGetValue(this, data)\n+\n+    abstract fun copyWithOffsets(newStartOffset: Int, newEndOffset: Int): IrGetValue", "msg": "Minor: probably it could be extracted to extension function, same as for IrConst"}
{"patch": "@@ -594,11 +594,7 @@ object Generators : TemplateGroupBase() {\n             val first = ArrayList<T>()\n             val second = ArrayList<T>()\n             for (element in this) {\n-                if (predicate(element)) {\n-                    first.add(element)\n-                } else {\n-                    second.add(element)\n-                }\n+                (if (predicate(element)) first else second).add(element)", "msg": "There's a similar pattern in line 620 for CharSequences and Strings, would you want to improve it as well?"}
{"patch": "@@ -147,6 +151,16 @@ open class BoxingInterpreter(\n                 value is CleanBoxedValue ||\n                 value.type != null && isProgressionClass(value.type)\n \n+    private fun isCastToProgression(insn: AbstractInsnNode): Boolean {\n+        // insn can only be of type TypeInsnNode, so the type conversion here is safe", "msg": "Minor: better add an assertion that `insn.opcode == Opcodes.CHECKCAST` or something like that."}
{"patch": "@@ -177,7 +177,7 @@ class DeserializedClassDescriptor(\n     override fun getInlineClassRepresentation(): InlineClassRepresentation<SimpleType>? = inlineClassRepresentation()\n \n     private fun computeInlineClassRepresentation(): InlineClassRepresentation<SimpleType>? {\n-        if (!isInlineClass()) return null\n+        if (!isInlineOrValueClass()) return null", "msg": "BTW even though this change doesn't seem to affect anything, it looks a bit incorrect because multi-field _value_ classes (`LanguageFeature.ValueClasses`, the feature which @zhelenskiy is working on) will not be represented in the way inline classes are represented in Kotlin metadata. We'll need at least a list of all primary constructor properties, not just the single one.\r\n\r\nBut since we haven't started working on, or even discussing, metadata for multi-field value classes, I don't think it matters a lot."}
{"patch": "@@ -0,0 +1,5 @@\n+// TARGET_BACKEND: JVM_IR", "msg": "Please, add `// CHECK_BYTECODE_LISTING` directive and re-run the test.\r\nIt'll produce `kt50986.txt` file containing generated bytecode signatures.\r\nCheck that it passes in the old back-end as well (to make sure that we don't break ABI)."}
{"patch": "@@ -68,3 +78,26 @@ class RuntimePublicAPITest {\n \n }\n \n+/*\n+Copied from `binary-compatibility-validator\n+Can be removed after:\n+https://github.com/Kotlin/binary-compatibility-validator/pull/75\n+*/\n+private fun List<ClassBinarySignature>.filterOutAnnotated(targetAnnotations: Set<String>): List<ClassBinarySignature> {", "msg": "cc @qwwdfsad "}
{"patch": "@@ -33,3 +30,7 @@ fun KotlinGradleModule.createExternalJvmVariant(\n @ExternalVariantApi\n val KotlinGradleVariantInternal.compilationData\n     get() = this.compilationData\n+\n+@ExternalVariantApi\n+val KotlinGradleFragment.external: KotlinMutableExternalModelContainer", "msg": "IMHO an API where there is just a registry of `AdditionalDataProvider<T, Key<T>>` may express the intention in a nicer way. Then, the registry is realized during model building and adding new providers will fail (as a safety check)."}
{"patch": "@@ -46,17 +46,21 @@ class SerializableIrGenerator(\n \n     private val addElementFun = serialDescImplClass.referenceFunctionSymbol(CallingConventions.addElement)\n \n-    private fun IrClass.hasSerializableAnnotationWithoutArgs(): Boolean {\n-        val annot = getAnnotation(SerializationAnnotations.serializableAnnotationFqName) ?: return false\n-\n-        for (i in 0 until annot.valueArgumentsCount) {\n-            if (annot.getValueArgument(i) != null) return false\n+    private fun IrClass.hasSerializableOrMetaAnnotationWithoutArgs(): Boolean {\n+        val annot = getAnnotation(SerializationAnnotations.serializableAnnotationFqName)\n+        if (annot != null) {\n+            for (i in 0 until annot.valueArgumentsCount) {\n+                if (annot.getValueArgument(i) != null) return false", "msg": "serializable annotation always have one argument so I think we may skip a loop here"}
{"patch": "@@ -111,12 +107,4 @@ class BuildScanStatisticsListener(\n         splattedString.add(tempStr)\n         return splattedString\n     }\n-\n-    private fun readableFileLength(length: Long): String =\n-        when {\n-            length / gbSize > 0 -> \"${length / gbSize} GB\"", "msg": "Well spotted issue!"}
{"patch": "@@ -38,6 +40,16 @@ internal class InlineClassAwareCaller<out M : Member?>(\n     override val parameterTypes: List<Type>\n         get() = caller.parameterTypes\n \n+    private val memberParameterTypes: List<Class<*>>\n+        get() = when (val m = member) {\n+            is Method -> m.parameterTypes.asList()\n+            is Constructor<*> -> m.parameterTypes.asList()\n+            is Field -> listOf(m.type)\n+            // TODO: Check if there are any cases other than the above three, especially if they result in null.\n+            // TODO: Check the Exceptions and error messages to be thrown.\n+            else -> throw IllegalArgumentException(\"temp err\")", "msg": "I have a question about the `member` property.\r\n\r\nLooking at the `Javadoc` of the `Member` interface, it appears that this interface is not inherited by any classes other than `Method`, `Constructor` and `Field`.\r\nhttps://docs.oracle.com/javase/jp/8/docs/api/java/lang/reflect/Member.html\r\nIn other words, this `else` clause is executed when the `member` property is `null`.\r\n\r\nNow, is there a situation where the `member` property is `null` in `InlineClassAwareCaller`?\r\nIf present, modify the processing in `else`, and if not, modify the error message, respectively."}
{"patch": "@@ -10,6 +10,7 @@ import com.intellij.openapi.diagnostic.Logger\n \n object IdeaStandaloneExecutionSetup {\n     private val LOG: Logger = Logger.getInstance(IdeaStandaloneExecutionSetup::class.java)\n+    private const val FALLBACK_IDEA_BUILD_NUMBER = \"999.SNAPSHOT\"", "msg": "```suggestion\r\n    // Copy-pasted from com.intellij.openapi.util.BuildNumber#FALLBACK_VERSION\r\n    private const val FALLBACK_IDEA_BUILD_NUMBER = \"999.SNAPSHOT\"\r\n```"}
{"patch": "@@ -0,0 +1,38 @@\n+", "msg": "As mentioned in the PR, these stepping tests are not directly related to this PR, but support the corresponding PR on the plug-in side by clarifying the stepping behavior of the JVM backend v/ the IR backend."}
{"patch": "@@ -156,7 +159,7 @@ open class FirJvmMangleComputer(\n             appendSignature(specialValueParamPrefix(it))\n             mangleValueParameter(this, it)\n         }\n-        typeParameters.filterIsInstance<FirTypeParameter>().withIndex().toList()\n+        ((container as? FirTypeParametersOwner)?.typeParameters?.withIndex()?.toList() ?: emptyList())", "msg": "```suggestion\r\n        (container as? FirTypeParametersOwner)?.typeParameters?.withIndex()?.toList().orEmpty()\r\n```"}
{"patch": "@@ -1,4 +1,5 @@\n // TARGET_BACKEND: JVM\n+// IGNORE_BACKEND_FIR: JVM_IR", "msg": "Please add `// FIR status: ...` line with some description what's happening now"}
{"patch": "@@ -38,14 +38,28 @@ class FragmentModuleGenerator(\n                             patchDeclarationParents()\n                         }\n                     } else {\n-                        val fileContext = context.createFileScopeContext(ktFile)\n-                        generateSingleFile(DeclarationGenerator(fileContext), ktFile, irModule)\n+                        generateInContextWithoutFragmentInfo(ktFile) {\n+                            generateSingleFile(DeclarationGenerator(it), ktFile, irModule)\n+                        }\n                     }\n                 )\n             }\n         }\n     }\n \n+    private fun <T> generateInContextWithoutFragmentInfo(ktFile: KtFile, block: (GeneratorContext) -> T): T {\n+        val symbolTableDecorator = (context.symbolTable as FragmentCompilerSymbolTableDecorator)", "msg": "```suggestion\r\n        val symbolTableDecorator = context.symbolTable as FragmentCompilerSymbolTableDecorator\r\n```"}
{"patch": "@@ -96,6 +93,11 @@ internal class InlineClassAwareCaller<out M : Member?>(\n \n             descriptor.valueParameters.mapTo(kotlinParameterTypes, ValueParameterDescriptor::getType)\n         }\n+\n+        // If the default argument is set,\n+        // (kotlinParameterTypes.size + Integer.SIZE - 1) / Integer.SIZE masks and one marker are added to the end of the argument.\n+        val extraArgumentsTail = (if (isDefault) ((kotlinParameterTypes.size + 31) / Integer.SIZE) + 1 else 0) +", "msg": "```suggestion\r\n        val extraArgumentsTail = (if (isDefault) ((kotlinParameterTypes.size + Integer.SIZE - 1) / Integer.SIZE) + 1 else 0) +\r\n```\r\nMinor, but let's either use numbers in both places, or the constant `Integer.SIZE` in both places. :)"}
{"patch": "@@ -16,3 +16,18 @@ package kotlin.native\n @Retention(AnnotationRetention.BINARY)\n @OptionalExpectation\n public expect annotation class CName(val externName: String = \"\", val shortName: String = \"\")\n+\n+/**\n+ * Instructs the Kotlin compiler to use a custom Objective-C and/or Swift name for this class, property, parameter, function or file.\n+ */\n+@Target(\n+    AnnotationTarget.CLASS,\n+    AnnotationTarget.PROPERTY,\n+    AnnotationTarget.VALUE_PARAMETER,\n+    AnnotationTarget.FUNCTION,\n+    AnnotationTarget.FILE\n+)\n+@Retention(AnnotationRetention.BINARY)\n+@MustBeDocumented\n+@OptionalExpectation\n+public expect annotation class ObjCName(val name: String = \"\", val swiftName: String = \"\")", "msg": "It should be opt-in. See the explanation in https://github.com/JetBrains/kotlin/pull/4818#discussion_r874853864."}
{"patch": "@@ -324,7 +327,14 @@ internal class ObjCExportNamerImpl(\n         // Note: this condition is correct but can be too strict.\n     }\n \n-    private val propertyNames = object : Mapping<PropertyDescriptor, String>() {\n+    private val objCPropertyNames = object : Mapping<PropertyDescriptor, String>() {\n+        override fun reserved(name: String) = name in Reserved.propertyNames\n+\n+        override fun conflict(first: PropertyDescriptor, second: PropertyDescriptor): Boolean =\n+                !mapper.canHaveSameName(first, second)\n+    }\n+\n+    private val swiftPropertyNames = object : Mapping<PropertyDescriptor, String>() {", "msg": "Seem a bit duplicated. Maybe extract a tiny inner class for `objCPropertyNames` and `swiftPropertyNames`?"}
{"patch": "@@ -417,7 +426,7 @@ internal class ObjCExportNamerImpl(\n             containingClass: ClassDescriptor\n     ) = helper.appendNameWithContainer(\n             this,\n-            clazz, clazz.name.asString().toIdentifier(),\n+            clazz, clazz.getObjCName(true).toIdentifier(),", "msg": "Please add `Swift` to the enclosing function name then."}
{"patch": "@@ -0,0 +1,13 @@\n+// WITH_STDLIB\n+// WITH_REFLECT\n+\n+operator fun Any?.getValue(x: Any?, y: Any?): String {\n+    return \"OK\"\n+}\n+\n+val s: String by 1\n+\n+fun box(): String {\n+    assert(::s.getDelegate() == 1)", "msg": "Please use `assertEquals` instead:\r\n```\r\nimport kotlin.test.assertEquals\r\n\r\n...\r\n\r\nassertEquals(1, ::s.getDelegate())\r\n```"}
{"patch": "@@ -0,0 +1,14 @@\n+// WITH_STDLIB\n+// WITH_REFLECT\n+\n+operator fun Any?.getValue(x: Any?, y: Any?): String {\n+    return \"OK\"\n+}\n+const val a = 1", "msg": "Maybe also change the type to e.g. String in one of the tests, to check that not only integer types are supported. :)"}
{"patch": "@@ -38,7 +38,14 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@ThreadLocal is applicable only to property with backing field, to property with delegation or to objects\"\n         )\n         put(ErrorsNative.INAPPLICABLE_THREAD_LOCAL_TOP_LEVEL, \"@ThreadLocal is applicable only to top level declarations\")\n-        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING);\n+        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING)\n+        put(ErrorsNative.REDUNDANT_SWIFT_REFINEMENT, \"An ObjC refined declaration can't also be refined in Swift\")\n+        put(\n+            ErrorsNative.INCOMPATIBLE_OBJC_REFINEMENT_OVERRIDE,\n+            \"Refined declaration overrides non refined declarations from {0}\",\n+            CommonRenderers.commaSeparated(Renderers.NAME)\n+        )\n+        put(ErrorsNative.INVALID_OBJC_REFINEMENT_TARGETS, \"Only properties and functions can be refined\")", "msg": "When a user gets this error, it might be a bit unclear for them that the error is caused by annotation targets."}
{"patch": "@@ -38,7 +38,14 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@ThreadLocal is applicable only to property with backing field, to property with delegation or to objects\"\n         )\n         put(ErrorsNative.INAPPLICABLE_THREAD_LOCAL_TOP_LEVEL, \"@ThreadLocal is applicable only to top level declarations\")\n-        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING);\n+        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING)\n+        put(ErrorsNative.REDUNDANT_SWIFT_REFINEMENT, \"An ObjC refined declaration can't also be refined in Swift\")\n+        put(\n+            ErrorsNative.INCOMPATIBLE_OBJC_REFINEMENT_OVERRIDE,\n+            \"Refined declaration overrides non refined declarations from {0}\",", "msg": "The message is probably not clear enough for different kinds of refinements, e.g. if super method is refined in Swift and this method is refined for Obj-C.\r\nIt should be enough to simply clarify the language."}
{"patch": "@@ -142,14 +144,17 @@ class FirTypeResolverImpl(private val session: FirSession) : FirTypeResolver() {\n             }\n         }\n \n-        for (scope in scopes) {\n-            if (applicability == CandidateApplicability.RESOLVED) break\n+        fun processClassifiers(scope: FirScope): Unit =", "msg": "I recommend to revert these changes"}
{"patch": "@@ -38,7 +38,11 @@ private val DIAGNOSTIC_FACTORY_TO_RENDERER by lazy {\n             \"@ThreadLocal is applicable only to property with backing field, to property with delegation or to objects\"\n         )\n         put(ErrorsNative.INAPPLICABLE_THREAD_LOCAL_TOP_LEVEL, \"@ThreadLocal is applicable only to top level declarations\")\n-        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING);\n+        put(ErrorsNative.INVALID_CHARACTERS_NATIVE, \"Name {0}\", CommonRenderers.STRING)\n+        put(ErrorsNative.INAPPLICABLE_OBJC_NAME, \"@ObjCName is not applicable on overrides\")\n+        put(ErrorsNative.INVALID_OBJC_NAME, \"@ObjCName should have a name and/or swiftName\")\n+        put(ErrorsNative.INVALID_CHARACTERS_OBJC_NAME, \"@ObjCName contains illegal characters: \\\"{0}\\\"\", CommonRenderers.STRING)\n+        put(ErrorsNative.INCOMPATIBLE_OBJC_NAME_OVERRIDE, \"Member inherits inconsistent @ObjCName\")", "msg": "This error message should also mention the types incompatible `@ObjCName` were inherited from."}
{"patch": "@@ -0,0 +1,27 @@\n+// CHECK_BYTECODE_LISTING\n+\n+import kotlin.reflect.KProperty\n+\n+class A {\n+    val b = B()\n+}\n+\n+class B {\n+    val c = C()\n+}\n+\n+class C {\n+    val d = D()\n+}\n+\n+class D {\n+    val e = 1\n+}\n+\n+val a = A()\n+\n+operator fun Int.getValue(thisRef: Any?, property: KProperty<*>) = \"OK\"", "msg": "```suggestion\r\noperator fun Int.getValue(thisRef: Any?, property: KProperty<*>): String =\r\n    if (this == 1) \"OK\" else \"Fail\"\r\n```\r\nJust in case, let's check that the correct value is passed. Perhaps in other tests too."}
{"patch": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.backend.jvm\n+\n+import org.jetbrains.kotlin.ir.builders.*\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.symbols.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+\n+class AtomicfuIrBuilder internal constructor(", "msg": "Same here, would be nice to drop a comment on each transformation -- what is transformed and to what"}
{"patch": "@@ -16,3 +16,30 @@ package kotlin.native\n @Retention(AnnotationRetention.BINARY)\n @OptionalExpectation\n public expect annotation class CName(val externName: String = \"\", val shortName: String = \"\")\n+\n+/**\n+ * This annotation marks the experimental [ObjCName] annotation.\n+ */\n+@RequiresOptIn\n+@Target(AnnotationTarget.ANNOTATION_CLASS)\n+@Retention(AnnotationRetention.BINARY)\n+@MustBeDocumented\n+@OptionalExpectation\n+public expect annotation class ExperimentalObjCName()\n+\n+/**\n+ * Instructs the Kotlin compiler to use a custom Objective-C and/or Swift name for this class, property, parameter or function.\n+ * @param exact specifies if the name of a class, object or interface should be interpreted as the exact name.", "msg": "The line above mentions that the annotation is applicable to \"class, property, parameter or function\".\nThis line uses \"object or interface\" that are not mentioned above. A little bit inconsistent."}
{"patch": "@@ -7,23 +7,23 @@ class PropertyDeclarationTest {\n     private val head: AtomicRef<String>\n     private val lateIntArr: AtomicIntArray\n     private val lateRefArr: AtomicArray<String?>\n-    private val lock: ReentrantLock\n+    //private val lock: ReentrantLock\n \n     init {\n         a = atomic(0)\n         head = atomic(\"AAA\")\n         lateIntArr = AtomicIntArray(55)\n         lateRefArr = atomicArrayOfNulls<String?>(10)\n-        lock = reentrantLock()\n+        //lock = reentrantLock()\n     }\n \n     fun test() {\n         assertEquals(0, a.value)\n-        check(head.compareAndSet(\"AAA\", \"BBB\"))\n+        assertTrue(head.compareAndSet(\"AAA\", \"BBB\"))\n         assertEquals(\"BBB\", head.value)\n         assertEquals(0, lateIntArr[35].value)\n         assertEquals(null, lateRefArr[5].value)\n-        assertEquals(null, lock)\n+        //assertEquals(null, lock)", "msg": "Looks like this can be removed."}
{"patch": "@@ -20,6 +21,9 @@ class JvmAbiComponentRegistrar : ComponentRegistrar {\n     override fun registerProjectComponents(project: MockProject, configuration: CompilerConfiguration) {\n         val outputPath = configuration.getNotNull(JvmAbiConfigurationKeys.OUTPUT_PATH)\n         if (configuration.get(JvmAbiConfigurationKeys.LEGACY_ABI_GEN, false)) {\n+            require(!configuration.getBoolean(CommonConfigurationKeys.USE_FIR)) {", "msg": "Throwing exceptions from compiler is a bad practice. I'll replace this `require` with reporting an error to message collector"}
{"patch": "@@ -1351,8 +1353,11 @@ internal fun ClassDescriptor.needCompanionObjectProperty(namer: ObjCExportNamer,\n     val companionObject = companionObjectDescriptor\n     if (companionObject == null || !mapper.shouldBeExposed(companionObject)) return false\n \n-    if (kind == ClassKind.ENUM_CLASS && enumEntries.any { namer.getEnumEntrySelector(it) == ObjCExportNamer.companionObjectPropertyName })\n-        return false // 'companion' property would clash with enum entry, don't generate it.\n+    if (kind == ClassKind.ENUM_CLASS && enumEntries.any {\n+                namer.getEnumEntrySelector(it) == ObjCExportNamer.companionObjectPropertyName ||\n+                        namer.getEnumEntrySwiftName(it) == ObjCExportNamer.companionObjectPropertyName", "msg": "Could you please add a test for this case?"}
{"patch": "@@ -0,0 +1,11 @@\n+// FIR_IDENTICAL\n+fun main() {\n+    var p: String?\n+    var block: () -> Int = { 1 }\n+    p = \"2\"\n+    run {\n+        block = { <!SMARTCAST_IMPOSSIBLE!>p<!>.length }", "msg": "I don't really like this error here BTW because it says \"'p' is a local variable that is captured by a changing closure\" but that's wrong, the variable is changed *outside* the closure."}
{"patch": "@@ -1249,6 +1249,15 @@ object DIAGNOSTICS_LIST : DiagnosticList(\"FirErrors\") {\n         val VARIABLE_INITIALIZER_IS_REDUNDANT by warning<PsiElement>()\n         val VARIABLE_NEVER_READ by warning<KtNamedDeclaration>(PositioningStrategy.DECLARATION_NAME)\n         val USELESS_CALL_ON_NOT_NULL by warning<PsiElement>(PositioningStrategy.SELECTOR_BY_QUALIFIED)\n+        val VALUE_CANNOT_BE_PROMOTED by warning<KtElement>() {", "msg": "When possible, it's better to set more precise element than just `KtElement`"}
{"patch": "@@ -37,4 +38,9 @@ object ExtendedDeclarationCheckers : DeclarationCheckers() {\n         get() = setOf(\n             RedundantReturnUnitType,\n         )\n+\n+    override val regularClassCheckers: Set<FirRegularClassChecker>\n+        get() = setOf(\n+            SafeInitialisationChecker            ", "msg": "I'd recommend to make an experiment by adding this checker also to `CommonDeclarationCheckers` and run all tests after that."}
{"patch": "@@ -21,6 +21,9 @@ interface DeserializedContainerSource : SourceElement {\n \n     // This string should only be used in error messages\n     val presentableString: String\n+\n+    // This string used in error messages\n+    val languageVersion: String?", "msg": "I'd prefer it to be declared as `val metadataVersion: BinaryVersion?`"}
{"patch": "@@ -21,6 +21,9 @@ interface DeserializedContainerSource : SourceElement {\n \n     // This string should only be used in error messages\n     val presentableString: String\n+\n+    // This string used in error messages", "msg": "This comment is unneeded"}
{"patch": "@@ -185,10 +182,10 @@ abstract class IncrementalCompilerRunner<\n             }\n \n             exitCode\n-        } finally {\n-            if (cachesMayBeCorrupted) {\n-                cleanOutputsAndLocalStateOnRebuild(args)\n-            }\n+        } catch (e: Throwable) {", "msg": "@nav-nav: Hi Nataliya, last week @ausatiy mentioned that he'd like to remove this commit from this PR for \"code style\" reasons. However, I think this commit improves readability because:\r\n  - The logic here is that if something is thrown, we'll clean up the state. The new code with `try-catch` directly matches this logic, whereas with the previous `try-finally` approach, the code is spread at 3 different places (line 118, 173, 188) and we'd have to follow the value of the `cachesMayBeCorrupted` variable (i.e., it takes extra effort to express the same thing).\r\n   - The behaviors before and after this commit are exactly the same (note that `finally` catches `Throwable`, which includes `Error` and `Exception`). With this commit, it's easier to change `catch(e: Throwable)` to `catch(e: Exception)` or `catch(e: SomeSpecificException)` later if we want.\r\n\r\nI'm fine if you want to remove this commit, but if so it would be nice if you could let me know your reasons so we can have a discussion here."}
{"patch": "@@ -1713,8 +1713,6 @@ public infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n \n /**\n  * Returns `true` if all elements match the given [predicate].\n- * \n- * @sample samples.collections.Collections.Aggregates.all", "msg": "Seems like you have unintentionally removed a sample reference in some functions. Or is it on purpose?"}
{"patch": "@@ -507,4 +507,18 @@ class Strings {\n \n         assertPrints(mixedColor, \"brown&blue\")\n     }\n+\n+    @Sample\n+    fun all() {\n+        assertPrints(\"fatima\".any(Char::isWhitespace), \"false\")\n+        assertPrints(\"Ariya\".all(Char::isLowerCase), \"false\")", "msg": "Let's have here two strings that have opposite properties. e.g:\r\n```\r\nassertPrints(\"London\".any(Char::isWhitespace), \"false\")\r\nassertPrints(\"Rio de Janeiro\".any(Char::isWhitespace), \"true\")\r\n\r\nassertPrints(\"London\".all(Char::isLetter), \"true\")\r\nassertPrints(\"Rio de Janeiro\".all(Char::isLetter), \"false\")\r\n```\r\nIn my opinion, it better shows how `all` and `any` differs. What do you think?"}
{"patch": "@@ -31,14 +31,22 @@ object Aggregates : TemplateGroupBase() {\n         include(Maps, CharSequences, ArraysOfUnsigned)\n     } builder {\n         inline()\n-        specialFor(ArraysOfUnsigned) { inlineOnly() }\n+        specialFor(ArraysOfUnsigned) {\n+            inlineOnly()\n+            sample(\"samples.collections.Collections.Aggregates.all\")\n+        }\n+        specialFor(Maps) {\n+            sample(\"samples.collections.Collections.Aggregates.all\")\n+        }\n+        specialFor(CharSequences) {", "msg": "This should be enough:\r\n```\r\nsample(\"samples.collections.Collections.Aggregates.all\")\r\nspecialFor(CharSequences) {\r\n    sample(\"samples.text.Strings.all\")\r\n}\r\n```\r\n\r\nThe DSL means _\"samples.collections.Collections.Aggregates.all\" is the sample for all receivers, but for CharSequences there is a different sample_\r\n\r\nSo basically the second `sample(...)` overrides the previous."}
{"patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.", "msg": "Please rebase onto a fresh master, the updated copyright is already there."}
{"patch": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.resolve.checkers\n+\n+import com.intellij.psi.PsiElement\n+import com.intellij.psi.tree.IElementType\n+import org.jetbrains.kotlin.KtNodeTypes\n+import org.jetbrains.kotlin.config.LanguageFeature\n+import org.jetbrains.kotlin.descriptors.DeclarationDescriptor\n+import org.jetbrains.kotlin.diagnostics.Errors\n+import org.jetbrains.kotlin.psi.*\n+\n+object TypeArgumentListLikeExpressionsChecker : DeclarationChecker {\n+\n+    override fun check(declaration: KtDeclaration, descriptor: DeclarationDescriptor, context: DeclarationCheckerContext) {\n+        if (context.languageVersionSettings.supportsFeature(LanguageFeature.AllowTypeArgumentListLikeExpressions)) return", "msg": "I would also add a fast-path for non-top level declarations (ones that don't have KtFile as a parent) to return here, too, because they would be traversed anyway when the checker is run on their containing declaration"}
{"patch": "@@ -0,0 +1,69 @@\n+fun f() {\n+    call<>\n+    call<x>\n+    call<x.>", "msg": "Please, separate cases with error nodes (ones that are not assumed to be parsed) into a different file named `*_ERR.kt`\nDitto, for other tests inside `testData/psi`\n"}
{"patch": "@@ -52,5 +53,6 @@ public interface KtCallResolverMixIn : KtAnalysisSessionMixIn {\n }\n \n private inline fun <reified PSI : KtElement> unresolvedKtCallError(element: PSI): Nothing {\n-    error(\"${PSI::class.simpleName} should always resolve to a KtCallInfo\\nelement: ${element::class.simpleName}\\ntext:\\n${element.getElementTextInContext()}\")\n+    throw KotlinExceptionWithAttachments(\"${PSI::class.simpleName} should always resolve to a KtCallInfo\")\n+        .withAttachment(element::class.simpleName ?: \"element\", element.getElementTextInContext())", "msg": "The `element::class.simpleName` is useful information too (and it's not a secret \ud83d\ude03). Let's move it to the error message string. For the attachment name, we should use something static, e.g., `elementText`"}
{"patch": "@@ -248,7 +248,7 @@ private val returnableBlocksPhase = makeIrFilePhase(\n     ::ReturnableBlockLowering,\n     name = \"ReturnableBlock\",\n     description = \"Replace returnable blocks with do-while(false) loops\",\n-    prerequisite = setOf(arrayConstructorPhase, assertionPhase)\n+    prerequisite = setOf(arrayConstructorPhase, assertionPhase, directInvokeLowering)", "msg": "Note that this is a change from the previous commit. Since `DirectInvokeLowering` creates returnable blocks it should be a prerequisite of `ReturnableBlockLowering`."}
{"patch": "@@ -465,12 +491,12 @@ internal class ObjCExportNamerImpl(\n             parameters.forEachIndexed { index, (bridge, it) ->\n                 val name = when (bridge) {\n                     is MethodBridgeValueParameter.Mapped -> when {\n-                        it is ReceiverParameterDescriptor -> \"\"\n+                        it is ReceiverParameterDescriptor -> it.getObjCName().asIdentifier(false) { \"\" }\n                         method is PropertySetterDescriptor -> when (parameters.size) {", "msg": "(Possible future improvement:)\r\nIn certain cases Kotlin property accessors are translated to methods. In this case, `@ObjCName` can be applied to the setter parameter but likely has no effect."}
{"patch": "@@ -7,6 +7,7 @@ package org.jetbrains.kotlin.ir.backend.js.lower\n \n import org.jetbrains.kotlin.backend.common.BodyLoweringPass\n import org.jetbrains.kotlin.backend.common.compilationException\n+import org.jetbrains.kotlin.backend.common.DefaultInlineClassesUtils.getInlineClassUnderlyingType", "msg": "Looks like an unused import?"}
{"patch": "@@ -511,4 +576,51 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n \n         valueClass.declarations += function\n     }\n+\n+    private fun buildSpecializedEqualsMethodForSealed(\n+        irClass: IrClass,\n+        inlineSubclasses: List<IrClassSymbol>,\n+        noinlineSubclasses: List<IrClassSymbol>\n+    ) {\n+        val boolAnd = context.ir.symbols.getBinaryOperator(\n+            OperatorNameConventions.AND, context.irBuiltIns.booleanType, context.irBuiltIns.booleanType\n+        )\n+        val equals = context.ir.symbols.getBinaryOperator(", "msg": "`context.irBuiltins.eqeqSymbol`"}
{"patch": "@@ -511,4 +576,51 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n \n         valueClass.declarations += function\n     }\n+\n+    private fun buildSpecializedEqualsMethodForSealed(\n+        irClass: IrClass,\n+        inlineSubclasses: List<IrClassSymbol>,\n+        noinlineSubclasses: List<IrClassSymbol>\n+    ) {\n+        val boolAnd = context.ir.symbols.getBinaryOperator(", "msg": "`context.irBuiltins.andandSymbol`"}
{"patch": "@@ -511,4 +576,51 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n \n         valueClass.declarations += function\n     }\n+\n+    private fun buildSpecializedEqualsMethodForSealed(", "msg": "How would this work for\r\n```kotlin\r\ninterface I\r\nobject Impl : I\r\n\r\nsealed value class A : I\r\nvalue class B(val x: I) : A()\r\nobject C : A() {\r\n  override fun equals(other: Any?) = true\r\n}\r\n\r\nB(Impl) == C\r\n```\r\nIt looks like the code would end up calling `B.eq-impl0(Impl, C as I)` which will incorrectly return true?"}
{"patch": "@@ -120,7 +123,9 @@ class MemoizedInlineClassReplacements(\n                 copyTypeParametersFrom(irClass)\n                 addValueParameter {\n                     name = InlineClassDescriptorResolver.BOXING_VALUE_PARAMETER_NAME\n-                    type = irClass.inlineClassRepresentation!!.underlyingType\n+                    type =\n+                        if (irClass.modality == Modality.SEALED) context.irBuiltIns.anyNType\n+                        else getInlineClassUnderlyingType(irClass)", "msg": "Isn't `getInlineClassUnderlyingType` just looking up the inline class representation in the metadata? What are we serializing there for sealed inline classes? Are we omitting it?\r\n\r\n---\r\n\r\nIn any case, it might be better to add this check to the `getInlineClassUnderlyingType` function instead of duplicating it here and below. Unless that ends up breaking some other code, which it might..."}
{"patch": "@@ -155,7 +165,10 @@ class MemoizedInlineClassReplacements(\n                 parent = irClass\n                 // We ignore type arguments here, since there is no good way to go from type arguments to types in the IR anyway.\n                 val typeArgument =", "msg": "Since you're touching this code anyway, could you please rename this variable to `argumentType`? It's really not a type argument..."}
{"patch": "@@ -679,35 +679,64 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n         )\n \n         val function = context.inlineClassReplacements.getSpecializedEqualsMethod(irClass, context.irBuiltIns)\n-        val left = function.valueParameters[0]\n-        val right = function.valueParameters[1]\n \n-        function.body = context.createIrBuilder(irClass.symbol).run {\n-            val branches = noinlineSubclasses.map {\n-                irBranch(\n-                    irCallOp(\n-                        boolAnd, context.irBuiltIns.booleanType,\n-                        irIs(irGet(left), it.owner.defaultType),\n-                        irIs(irGet(right), it.owner.defaultType),\n-                    ),\n-                    irCallOp(equals, context.irBuiltIns.booleanType, irGet(left), irGet(right))\n+        with(context.createIrBuilder(function.symbol)) {\n+            function.body = irBlockBody {\n+                val left = irTemporary(", "msg": "The specialized equals method takes two unboxed arguments, so `coerceInlineClasses` here doesn't do anything except inform `ExpressionCodegen` of the new type before storing a copy of the argument in a local. You can probably just coerce the value parameters at each use instead."}
{"patch": "@@ -583,7 +586,7 @@ private class JvmInlineClassLowering(context: JvmBackendContext) : JvmValueClass\n                     .single { it is IrSimpleFunction && it.name.asString() == name } as IrFunction\n                 val branches = noinlineSubclasses\n                     .filter { info ->\n-                        info.bottom.declarations.any { it is IrSimpleFunction && it.name.asString() == name && !it.isFakeOverride }\n+                        info.bottom.isFunctionDeclared() || info.sealedParents.any { it.owner.isFunctionDeclared() }", "msg": "Maybe you could use `overriddenSymbols` to figure out if there is an implementation of a function from `Any` with the correct name?"}
{"patch": "@@ -65,36 +67,54 @@ object InlineClassDeclarationChecker : DeclarationChecker {\n             trace.report(Errors.INLINE_CLASS_CANNOT_HAVE_CONTEXT_RECEIVERS.on(contextReceiverList))\n         }\n \n+        val isSealed = descriptor.modality == Modality.SEALED\n+\n+        if (isSealed && valueKeyword == null) {\n+            trace.report(Errors.SEALED_INLINE_CLASS_WRONG_MODIFIER.on(inlineOrValueKeyword))\n+        }\n+\n         val modalityModifier = declaration.modalityModifier()\n-        if (modalityModifier != null && descriptor.modality != Modality.FINAL) {\n+        if (modalityModifier != null && descriptor.modality != Modality.FINAL && !isSealed) {\n+            trace.report(Errors.VALUE_CLASS_NOT_FINAL.on(modalityModifier))\n+            return\n+        }\n+\n+        if (modalityModifier != null && isSealed && !context.languageVersionSettings.supportsFeature(LanguageFeature.SealedInlineClasses)) {", "msg": "Error reporting could be slightly better. Currently this error is reported if the feature is not enabled:\r\n```\r\n1.kt:2:1: error: value classes can be only final or sealed\r\nsealed value class A\r\n^\r\n```\r\nwhich reads weird. I'd expect something usual like `UNSUPPORTED_FEATURE` here."}
{"patch": "@@ -457,6 +531,53 @@ class ClassGenerator(\n         }\n     }\n \n+    private fun generatePropertyForSealedInlineClass(irClass: IrClass) {", "msg": "This way you're not setting `correspondingPropertySymbol` for field/getter, getter name is non-conventional, and maybe there are some other problems. Let's use the builder API instead\r\n```\r\n    private fun generatePropertyForSealedInlineClass(irClass: IrClass) {\r\n        irClass.addProperty {\r\n            name = Name.identifier(\"\\$value\")\r\n            origin = IrDeclarationOrigin.FIELD_FOR_SEALED_INLINE_CLASS\r\n            visibility = DescriptorVisibilities.PROTECTED\r\n        }.also { irProperty ->\r\n            irProperty.addBackingField {\r\n                type = context.irBuiltIns.anyNType\r\n                origin = IrDeclarationOrigin.FIELD_FOR_SEALED_INLINE_CLASS\r\n                visibility = DescriptorVisibilities.PROTECTED\r\n                isFinal = true\r\n            }\r\n            irProperty.addGetter {\r\n                returnType = context.irBuiltIns.anyNType\r\n                origin = IrDeclarationOrigin.GETTER_OF_SEALED_INLINE_CLASS_FIELD\r\n                visibility = DescriptorVisibilities.PROTECTED\r\n            }\r\n        }\r\n    }\r\n```"}
{"patch": "@@ -136,8 +136,9 @@ private class TypeVariableImpl(private val typeParameter: KTypeParameter) : Type\n     @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n     fun getDeclaredAnnotations(): Array<Annotation> = emptyArray()\n \n-    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n-    fun getAnnotatedBounds(): Array<Annotation> = emptyArray()\n+    // There is also [getAnnotatedBounds] which returns an array of [AnnotatedType]; because [AnnotatedType] is JDK 8+,\n+    // we can't declare that method here for compatibiility with Android SDK 25 and lower, so we leave it unimplemented", "msg": "```suggestion\r\n    // we can't declare that method here for compatibility with Android SDK 25 and lower, so we leave it unimplemented\r\n```"}
{"patch": "@@ -24,30 +24,39 @@ open class KotlinClass {\n \n @ObjCName(\"ObjCSubClass\", \"SwiftSubClass\")\n class KotlinSubClass: KotlinClass() {\n-    @ObjCName(\"objCProperty\")\n+    <!INAPPLICABLE_OBJC_NAME!>@ObjCName(\"objCProperty\")<!>\n     override var kotlinProperty: Int = 1\n-    @ObjCName(swiftName = \"swiftFunction\")\n-    override fun @receiver:ObjCName(\"objCReceiver\") Int.kotlinFunction(\n-        @ObjCName(\"objCParam\") kotlinParam: Int\n+    <!INAPPLICABLE_OBJC_NAME!>@ObjCName(swiftName = \"swiftFunction\")<!>\n+    override fun <!INAPPLICABLE_OBJC_NAME!>@receiver:ObjCName(\"objCReceiver\")<!> Int.kotlinFunction(\n+        <!INAPPLICABLE_OBJC_NAME!>@ObjCName(\"objCParam\")<!> kotlinParam: Int\n     ): Int = this + kotlinParam * 2\n }\n \n-@ObjCName()\n-val invalidObjCName: Int = 0\n+<!INVALID_OBJC_NAME!>@ObjCName()<!>", "msg": "`test.kt` and `test.fir.kt` must be identical modulo reported diagnostics. I'll fix it myself, so it's just a note for the future"}
{"patch": "@@ -0,0 +1,33 @@\n+// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE, -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n+// !RENDER_DIAGNOSTICS_FULL_TEXT\n+\n+data class StringProperty(var v: String) {\n+    fun assign(v: String) {\n+        this.v = v\n+    }\n+    fun assign(v: StringProperty) {\n+        this.v = v.get()\n+    }\n+    fun get(): String = v\n+}\n+\n+fun StringProperty.assign(v: Int) = this.assign(\"OK\")\n+\n+data class Task(val input: StringProperty)\n+\n+fun test() {\n+    // Should not work with assignment\n+    val task = Task(StringProperty(\"Fail\"))\n+    task.input = <!ASSIGNMENT_TYPE_MISMATCH!>\"OK\"<!>", "msg": "It's very strange that `VAL_REASSIGNMENT` is not reported here. Looks like compiler bug. I've created an issue for it: [KT-53898](https://youtrack.jetbrains.com/issue/KT-53898)"}
{"patch": "@@ -0,0 +1,18 @@\n+// ISSUE: KT-30054", "msg": "Please, add a test with `KeepNullabilityWhenApproximatingLocalType` feature enabled, too"}
{"patch": "@@ -17,9 +17,7 @@ public inline fun measureTimeMillis(block: () -> Unit): Long {\n     contract {\n         callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n     }\n-    val start = System.currentTimeMillis()\n-    block()\n-    return System.currentTimeMillis() - start\n+    return measureNanoTime(block) / 1_000_000L", "msg": "I'm debating if `convertDurationUnit` should be used instead, though this is likely quicker."}
{"patch": "@@ -751,6 +752,11 @@ class ClassFileToSourceStubConverter(val kaptContext: KaptContextForStubGenerati\n         val value = field.value\n \n         val origin = kaptContext.origins[field]\n+        val isConstantValue = when (val declaration = origin?.element) {\n+            is KtProperty -> declaration.hasModifier(KtTokens.CONST_KEYWORD)", "msg": "This is effectively a breaking change, so I'm wondering if we should treat:\r\n- `const`\r\n- any kind of primitive + String values for a `val`\r\nas constants and inline them?\r\n\r\nThis ensures existing users do not break."}
{"patch": "@@ -61,7 +61,9 @@ internal fun Project.setupKotlinNativePlatformDependencies() {\n internal fun Project.getNativeDistributionDependencies(target: CommonizerTarget): FileCollection {\n     return when (target) {\n         is LeafCommonizerTarget -> getOriginalPlatformLibrariesFor(target)\n-        is SharedCommonizerTarget -> commonizeNativeDistributionTask?.get()?.getCommonizedPlatformLibrariesFor(target) ?: project.files()\n+        is SharedCommonizerTarget -> project.files(", "msg": "What do you think about defining another function like \r\n```\r\nfun TaskProvider<NativeDistributionCommonizerTask>.getCommonizedPlatformLibrariesFor(target: SharedCommonizerTarget) = project.filesProvider {  ... } \r\n```\r\n\r\non the TaskProvider?\r\nWith this, others will have intuitively use this better version instead!"}
{"patch": "@@ -132,6 +133,9 @@ fun writeOutputs(\n     try {\n         for (state in outputs) {\n             ProgressIndicatorAndCompilationCanceledStatus.checkCanceled()\n+            if ((state.diagnosticReporter as? BaseDiagnosticsCollector)?.hasErrors == true) {", "msg": "1) I guess this check should be outside of the loop, in the beginning of the method, because `writeOutput` cannot introduce new compilation errors\r\n2) The following would be more reliable: `projectConfiguration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY).hasErrors()`\r\n3) I'd prefer to rename the method to `writeOutputsIfNeeded` to make it clear that outputs are not guaranteed to be written"}
{"patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.cli\n+\n+import org.jetbrains.kotlin.cli.common.ExitCode\n+import org.jetbrains.kotlin.cli.jvm.K2JVMCompiler\n+import org.jetbrains.kotlin.config.LanguageFeature\n+import org.jetbrains.kotlin.test.TestCaseWithTmpdir\n+import java.io.File\n+\n+class PlatformDeclarationClashTest : TestCaseWithTmpdir() {", "msg": "1) Let's use the standard `AbstractCliTest` for this (`compiler/testData/cli/jvm`), and check that the file is absent using the `ABSENT` directive (e.g. https://github.com/JetBrains/kotlin/blob/049b6899b729fd4c04ab4588743404150525019c/compiler/testData/cli/jvm/jvmIrByDefault1_5.test#L1)\r\n2) I'd prefer to avoid using unstable language features, let's make the test cause platform declaration clash via `@JvmName`\r\n3) Please add a copy of the test with K2 (`-Xuse-k2`), because it has another entrypoint which also needs to be checked\r\n\r\n"}
{"patch": "@@ -0,0 +1,7 @@\n+class Foo {", "msg": "Move this file to [compiler/testData/diagnostics/tests/redeclarations](https://github.com/JetBrains/kotlin/tree/4737bb07dfa131d4167ae9fe0966c48ce11268c0/compiler/testData/diagnostics/tests/redeclarations). Rename it to `RedeclaratedVals.kt` (don't use `k2` prefix/suffix for test data since it's used in both frontends)."}
{"patch": "@@ -0,0 +1,7 @@\n+class Foo {\n+    fun getY() {\n+        val someVal = \"One\"\n+        val someVal = 42\n+        println(someVal)", "msg": "No need to use stdlib methods here (since it requires adding `// WITH_STDLIB` directive). You can just make the function returnable:\r\n\r\n```suggestion\r\n        return someVal\r\n```"}
{"patch": "@@ -322,6 +329,22 @@ object FirConflictsChecker : FirBasicDeclarationChecker() {\n         }\n     }\n \n+    private fun checkBlock(body: FirBlock, inspector: DeclarationInspector) {\n+        for (it in body.statements) {\n+            when (it) {\n+                is FirVariable -> {\n+                    inspector.collect(it)\n+                }\n+\n+                is FirBlock -> {\n+                    checkBlock(it, inspector)", "msg": "Your test doesn't cover this case. Please extend the test sample."}
{"patch": "@@ -322,6 +329,22 @@ object FirConflictsChecker : FirBasicDeclarationChecker() {\n         }\n     }\n \n+    private fun checkBlock(body: FirBlock, inspector: DeclarationInspector) {", "msg": "The method doesn't check in the following case:\r\n\r\n```kt\r\nfun main(b: Boolean) {\r\n    if (b) {\r\n        val someVal2 = 2\r\n        val someVal2 = \"Two\"\r\n    }\r\n}\r\n```\r\n\r\nPlease consider more cases."}
{"patch": "@@ -167,26 +170,20 @@ object FirConflictsChecker : FirBasicDeclarationChecker() {\n                         declaration.onConstructors { constructor ->\n                             packageMemberScope.processFunctionsByName(declarationName!!) {\n                                 collectExternalConflict(\n-                                    constructor, presenter.represent(constructor, declaration), containingFile,\n-                                    it, null, null, session\n+                                    constructor, presenter.represent(constructor, declaration), containingFile, it, null, null, session", "msg": "Remove formatting changes."}
{"patch": "@@ -220,40 +212,28 @@ object FirConflictsChecker : FirBasicDeclarationChecker() {\n         }\n     }\n \n-    override fun check(declaration: FirDeclaration, context: CheckerContext, reporter: DiagnosticReporter) {\n-        val inspector = DeclarationInspector()\n-\n-        when (declaration) {\n-            is FirFile -> checkFile(declaration, inspector, context)\n-            is FirRegularClass -> checkRegularClass(declaration, inspector)\n-            is FirFunction -> {\n-                val body = declaration.body ?: return\n-                checkBlock(body, inspector)\n-            }\n-\n-            else -> {\n-            }\n-        }\n-\n-        context.addDeclaration(declaration)\n-        try {\n+    private fun resolveConflictingSymbols(", "msg": "Incorrect function naming. Resolving is being performed on the previous stage, checkers only detect incorrect semantics. Rename it to something else, probably to `checkConflictingSymbols`."}
{"patch": "@@ -72,7 +72,7 @@ class KotlinTestsRegistry(val project: Project, val allTestsTaskName: String = \"\n             aggregate.description = description\n             aggregate.group = JavaBasePlugin.VERIFICATION_GROUP\n \n-            aggregate.destinationDir = project.testReportsDir.resolve(reportName)\n+            aggregate.destinationDirectory.set(project.testReportsDir.resolve(reportName))", "msg": "`TestReport.destinationDirectory` input was added only in Gradle 7.4. Since KGP supports all Gradle versions from 6.8.3 I could not accept this change.\r\n\r\nI need to think how to fix it better."}
{"patch": "@@ -92,7 +92,7 @@ abstract class DataClassMembersGenerator(\n             // data classes and corresponding properties can be non-final.\n             // We should use getters for such properties (see KT-41284).\n             val backingField = property.backingField\n-            return if (!forbidDirectFieldAccess && property.modality == Modality.FINAL && backingField != null) {\n+            return if (!forbidDirectFieldAccess && irClass.isFinalClass && backingField != null) {", "msg": "Could you please comment this change? It influences not only K2 but also K1, so it's not so clear for me."}
{"patch": "@@ -0,0 +1,50 @@\n+// SKIP_TXT\n+\n+import kotlin.contracts.*\n+\n+class C(val x: Int)\n+\n+@OptIn(ExperimentalContracts::class)\n+fun isNotNullAlsoCall(a: String?, b: () -> Unit): Boolean {\n+    contract {\n+        returns(true) implies (a != null)\n+        callsInPlace(b, InvocationKind.EXACTLY_ONCE)\n+    }\n+    b()\n+    return a != null\n+}\n+\n+fun binaryBooleanExpression() {\n+    var x: String? = \"\"\n+    if (x is String || (x is String).also { x = null }) {\n+        x<!UNSAFE_CALL!>.<!>length // bad (x#0 is String, x#1 is Nothing?, this is either)\n+    }\n+}\n+\n+fun unoverriddenEquals(a: Any?) {\n+    val c = C(1)\n+    var b: Any?\n+    b = c\n+    if (b == c.also { b = a }) {\n+        a.x // bad (b#0 is C, b#1 = a)", "msg": "I've created [KT-55096](https://youtrack.jetbrains.com/issue/KT-55096) to track this problem"}
{"patch": "@@ -14,7 +14,7 @@ package kotlin.ranges\n private open class ComparableRange<T : Comparable<T>>(\n     override val start: T,\n     override val endInclusive: T\n-) : ClosedRange<T> {\n+) : ClosedRange<T>, Serializable {", "msg": "Shouldn't all of these implementations have a `serialVersionUID` property?"}
{"patch": "@@ -0,0 +1,15 @@\n+// WITH_STDLIB\n+// REWRITE_JVM_STATIC_IN_COMPANION\n+// JVM_TARGET: 1.8\n+\n+object TestObject {", "msg": "Add a test with `@JvmStatic` function accessing private properties of the object."}
{"patch": "@@ -22,11 +22,11 @@ class Test4 : InvT<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>*<!>>\n class Test5 : InvT<InvT<*>>\n \n class Test6 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>OutStar<!>\n-class Test7 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>OutOut<!>\n+class Test7 : OutOut\n class Test8 : OutT<Int>\n class Test9 : OutT<<!PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE!>out<!> Int>\n \n class Test10 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InStar<!>\n-class Test11 : <!EXPANDED_TYPE_CANNOT_BE_INHERITED!>InIn<!>\n+class Test11 : InIn", "msg": "Changes like these make me uncomfortable with this change. I don't feel like I understand what is going on here. It looks like all the actual functional tests are passing, but it is clear that this changes things in subtle ways."}
{"patch": "@@ -495,4 +495,44 @@ class LldbTests {\n         \"\"\".trimIndent().lldb(program)\n     }\n \n+    @Test\n+    fun `inline function parameters are visible`() = lldbTest(\"\"\"\n+        data class A(var x: Int)\n+\n+        inline fun foo(p1: Int, p2: Int, f: (A, Int, Int) -> Unit) { \n+            val tmp = A(0)\n+            println()\n+            f(tmp, p1, p2)\n+        }\n+\n+        fun main() {\n+            val tmp1 = 1\n+            val tmp2 = 2\n+            foo(tmp1, tmp2) { pix, piy, piz ->", "msg": "It seams, that the current code works only if the variable is passed to an argument. \r\n\r\nFor example, if I change the code to `foo(1, 2)` variables disappear. Also p2 disappear if use `foo(tmp1, tmp1+tmp1)`. Can you please check it, and add more complex tests?"}
{"patch": "@@ -227,6 +229,13 @@ class FunctionInlining(\n             }\n         }\n \n+        private fun saveParameterToExpressionMapping(callee: IrFunction, copiedCallee: IrFunction) {\n+            for ((parameter, copiedParameter) in callee.valueParameters.zip(copiedCallee.valueParameters)) {\n+                val expression = substituteMap[copiedParameter] ?: continue\n+                context.mapping.inlinedParameterToExpression[parameter] = expression", "msg": "Did I understand correctly that you are using the inline function parameter as the key in the map? How it's supposed to work if the function is called several times? Can you please add a test on this case, if I'm missing something and it works?"}
{"patch": "@@ -199,6 +199,8 @@ class FunctionInlining(\n             newStatements.addAll(evaluationStatements)\n             statements.mapTo(newStatements) { it.transform(transformer, data = null) as IrStatement }\n \n+            saveParameterToExpressionMapping(callee, copiedCallee)", "msg": "There should be variables for these parameters in most cases. I think they are not shown now, as they are temporary variables. What do you think about creating a separate origin for them? I'm not sure about the name and scope, but this should be an easier solution, at least for cases, where variables are not optimized-out. "}
{"patch": "@@ -515,9 +510,7 @@ open class FirDeclarationsResolveTransformer(transformer: FirAbstractBodyResolve\n         val result = context.withScopesForScript(script, components) {\n             transformDeclarationContent(script, data) as FirScript\n         }\n-\n-        dataFlowAnalyzer.exitScript(script)\n-\n+        dataFlowAnalyzer.exitScript() // TODO: FirScript should be a FirControlFlowGraphOwner", "msg": "@ligee FYI"}
{"patch": "@@ -571,51 +561,19 @@ open class FirDeclarationsResolveTransformer(transformer: FirAbstractBodyResolve\n                 transformer.firProviderInterceptor\n             )\n         }\n-        if (!implicitTypeOnly && anonymousObject.controlFlowGraphReference == null) {\n-            dataFlowAnalyzer.enterAnonymousObject(anonymousObject)\n-        } else {\n-            dataFlowAnalyzer.enterClass()\n-        }\n+        // TODO: why would there be a graph already?", "msg": "Most likely at this point this situation would never happen\n\nI'll add assertion and check if something fail"}
{"patch": "@@ -0,0 +1,27 @@\n+// TARGET_BACKEND: JVM\n+// WITH_STDLIB\n+\n+open class A {\n+\n+    companion object {\n+\n+        @JvmStatic\n+        protected const val x = 1\n+\n+        @JvmStatic\n+        @JvmField\n+        protected val z = 1", "msg": "Please make this a `var` and check that changing its value works"}
{"patch": "@@ -233,6 +233,9 @@ class KonanConfig(val project: Project, val configuration: CompilerConfiguration\n     val fullExportedNamePrefix: String\n         get() = configuration.get(KonanConfigKeys.FULL_EXPORTED_NAME_PREFIX) ?: implicitModuleName\n \n+    val ignoreInterfaceMethodCollisions: Boolean\n+        get() = configuration.get(KonanConfigKeys.IGNORE_INTERFACE_COLLISIONS) ?: false", "msg": "Seems unused."}
{"patch": "@@ -112,12 +114,14 @@ internal class ObjCExport(\n         if (!config.isFinalBinary) return // TODO: emit RTTI to the same modules as classes belong to.\n \n         val mapper = exportedInterface?.mapper ?: ObjCExportMapper(unitSuspendFunctionExport = config.unitSuspendFunctionObjCExport)\n+        val ignoreInterfaceMethodCollisions = config.configuration.getBoolean(BinaryOptions.objcExportIgnoreInterfaceMethodCollisions)\n         namer = exportedInterface?.namer ?: ObjCExportNamerImpl(\n                 setOf(moduleDescriptor),\n                 moduleDescriptor.builtIns,\n                 mapper,\n                 topLevelNamePrefix,\n-                local = false\n+                local = false,\n+                ignoreInterfaceMethodCollisions = ignoreInterfaceMethodCollisions,", "msg": "Shouldn't actually be required here: no header is generated in this mode (e.g. the compiler is producing an executable)."}
{"patch": "@@ -49,6 +49,7 @@ interface ObjCExportLazy {\n             get() = false\n \n         val unitSuspendFunctionExport: UnitSuspendFunctionObjCExport\n+        val ignoreInterfaceMethodCollisions: Boolean", "msg": "Please add a default implementation (`false`). This interface has subclasses outside this repository, and adding a default implementation would prevent breaking those subclasses."}
{"patch": "@@ -54,9 +54,9 @@ interface ObjCExportNamer {\n         val topLevelNamePrefix: String\n         fun getAdditionalPrefix(module: ModuleDescriptor): String?\n         val objcGenerics: Boolean\n-\n         val disableSwiftMemberNameMangling: Boolean\n             get() = false\n+        val ignoreInterfaceMethodCollisions: Boolean", "msg": "Please add a default implementation. See `ObjCExportLazy.Configuration.ignoreInterfaceMethodCollisions` comment for details."}
{"patch": "@@ -186,7 +186,12 @@ internal val wrapInlineDeclarationsWithReifiedTypeParametersLowering = makeKonan\n \n internal val inlinePhase = makeKonanFileOpPhase(\n         { context, irFile ->\n-            FunctionInlining(context, NativeInlineFunctionResolver(context, context.generationState)).lower(irFile)\n+            val generationState = context.generationState\n+            FunctionInlining(\n+                    context,\n+                    NativeInlineFunctionResolver(context, generationState),\n+                    alwaysCreateTemporaryVariablesForArguments = generationState.config.debug", "msg": "Please use `generationState.shouldContainDebugInfo` instead"}
{"patch": "@@ -451,7 +451,7 @@ open class FirSupertypeResolverVisitor(\n     private fun addSelfToTypeParameters(firClass: FirClassLikeDeclaration, session: FirSession) {\n         val isSelf = firClass.getAnnotationByClassId(StandardClassIds.Annotations.Self, session) != null\n         val params = firClass.typeParameters\n-        if (params is MutableList && isSelf) {\n+        if (params is MutableList && isSelf && params.find { it.symbol.name == SpecialNames.SELF_TYPE } == null) {", "msg": "Please add a test confirming this check is needed"}
{"patch": "@@ -36,8 +40,33 @@ internal val IrClass.implementedInterfaces: List<IrClass>\n                 superInterfaces).distinct()\n     }\n \n-internal val IrFunction.isTypedIntrinsic: Boolean\n-    get() = annotations.hasAnnotation(KonanFqNames.typedIntrinsic)\n+internal val IrFunction.isTypedIntrinsic: Boolean get() = getTypedIntrinsic() != null\n+\n+internal fun IrFunction.getTypedIntrinsic(): IrConstructorCall? {\n+    if (true) { // @TODO: check laxTypedIntrinsic, do we need to propagate something here, or we can access the context from the Ir node?", "msg": "Question: how can I access the `LanguageSettings` object here to check for the enabled feature? Is it possible to get that instance from an Ir node, or I will need to propagate the instance up to here?"}
{"patch": "@@ -43,18 +43,24 @@ class JvmLateinitLowering(\n ) : FileLoweringPass {\n \n     override fun lower(irFile: IrFile) {\n-        irFile.transformChildrenVoid(Transformer(context))\n+        val transformer = Transformer(context)\n+        irFile.transformChildrenVoid(transformer)\n+\n+        for(variable in transformer.lateinitVariables) {", "msg": "Please run \"reformat\" on the whole file"}
{"patch": "@@ -65,5 +65,7 @@ private class NotNullVar<T : Any>() : ReadWriteProperty<Any?, T> {\n     public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n         this.value = value\n     }\n+\n+    public override fun toString(): String = if (value != null) value.toString() else \"Not-null value not initialized yet.\"", "msg": "I've experimented with toString variants in the debugger, and I think that for this purpose it would be better to keep things consistent with other delegates provided by `Delegates` object.\r\n```suggestion\r\n    public override fun toString(): String = \r\n        \"NotNullProperty(${if (value != null) \"value=$value\" else \"value not initialized yet\"})\"\r\n```"}
{"patch": "@@ -23,4 +23,6 @@ private class ThreadLocalDelegate<T>(private val initializer: () -> T) : ReadWri\n     override operator fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n         map[Thread.currentThread()] = value\n     }\n+\n+    override fun toString(): String = \"ThreadLocalDelegate(map=$map)\"", "msg": "When a thread is used as a map key, the result of toString is not nice to read \r\n```suggestion\r\n    override fun toString(): String =\r\n        \"ThreadLocalDelegate(${map.entries.joinToString { \"#${it.key.id}=>${it.value}\" }})\"    \r\n```"}
{"patch": "@@ -71,7 +71,7 @@ public actual open class ArrayList<E> internal constructor(private var array: Ar\n         checkIsMutable()\n         if (elements.isEmpty()) return false\n \n-        array += elements.toTypedArray<Any?>()\n+        dummy.push.apply(array, elements.toTypedArray<Any?>())", "msg": "AFAIK, there was some limitation on how many parameters can be spread using this approach, so it may fail on large `elements` collection"}
{"patch": "@@ -164,4 +163,6 @@ public actual open class ArrayList<E> internal constructor(private var array: Ar\n     private fun insertionRangeCheck(index: Int) = index.apply {\n         AbstractList.checkPositionIndex(index, size)\n     }\n-}\n\\ No newline at end of file\n+    \n+    private val dummy = js(\"[]\")", "msg": "Not a very descriptive name, perhaps would be better `jsArrayPrototype` or something like that."}
{"patch": "@@ -71,7 +71,8 @@ public actual open class ArrayList<E> internal constructor(private var array: Ar\n         checkIsMutable()\n         if (elements.isEmpty()) return false\n \n-        array += elements.toTypedArray<Any?>()\n+\n+        elements.forEach(array.asDynamic()::push)", "msg": "Would be better to expand the array by setting its length and then fill elements manually."}
{"patch": "@@ -82,10 +83,11 @@ public actual open class ArrayList<E> internal constructor(private var array: Ar\n \n         if (index == size) return addAll(elements)\n         if (elements.isEmpty()) return false\n-        when (index) {\n-            size -> return addAll(elements)\n-            0 -> array = elements.toTypedArray<Any?>() + array\n-            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n+\n+        var i = index\n+        elements.forEach { element ->\n+            array.asDynamic().splice(i, 0, element)", "msg": "Moving array tail on each element insertion would result in quadratic complexity."}
{"patch": "@@ -149,7 +151,7 @@ public actual open class ArrayList<E> internal constructor(private var array: Ar\n     }\n \n     override fun toArray(): Array<Any?> {\n-        return js(\"[]\").slice.call(array)\n+        return jsArrayPrototype.slice.call(array)", "msg": "It doesn't seem that jsArrayPrototype is now used anywhere except this function. Does it make sense to extract it then to a variable?"}
{"patch": "@@ -0,0 +1,86 @@\n+// TARGET_BACKEND: JVM_IR\n+\n+// WITH_STDLIB\n+\n+import kotlinx.serialization.*\n+import kotlinx.serialization.descriptors.*\n+import kotlinx.serialization.encoding.*\n+import kotlinx.serialization.json.*\n+import kotlin.reflect.KProperty\n+import kotlin.properties.*\n+\n+@Serializable\n+data class SimpleDTO(\n+    val realProp: Int,\n+) {\n+    @Transient\n+    private val additionalProperties: Map<String, Int> = mapOf(\"delegatedProp\" to 123)\n+    @Transient", "msg": "I think `@Transient` shouldn't be here, as delegated property is transient automatically? At least it works without it."}
{"patch": "@@ -0,0 +1,17 @@\n+// !LANGUAGE: +EnumEntries\n+// TARGET_BACKEND: JVM_IR\n+// WITH_STDLIB\n+\n+enum class MyEnum {\n+    OK, NOPE;\n+\n+    companion object {\n+        //use values() instead - and it works as expected", "msg": "Please remove this comment"}
{"patch": "@@ -0,0 +1,17 @@\n+// !LANGUAGE: +EnumEntries\n+// TARGET_BACKEND: JVM_IR", "msg": "Let's use `IGNORE_BACKEND: JVM, JS` instead, so that this test will run for Native."}
{"patch": "@@ -100,6 +100,9 @@ fun BaseKotlinLibrary.unresolvedDependencies(lenient: Boolean = false): List<Unr\n     manifestProperties.propertyList(KLIB_PROPERTY_DEPENDS, escapeInQuotes = true)\n         .map { UnresolvedLibrary(it, manifestProperties.getProperty(\"dependency_version_$it\"), lenient = lenient) }\n \n+val BaseKotlinLibrary.hasUnresolvedDependencies: Boolean", "msg": "I would just call it `hasDependencies`. \"Unresolved\" is a special additional property used to indicate that `fun BaseKotlinLibrary.unresolvedDependencies()` returns `UnresolvedLibrary`s that need further resolve."}
{"patch": "@@ -72,9 +121,32 @@ class KaptJavaFileManager(context: Context) : JavacFileManager(context, true, nu\n         }\n     }\n \n+    inner class AccessMonitoredJavaFileObject(innerFile: JavaFileObject) : ForwardingJavaFileObject<JavaFileObject>(innerFile) {", "msg": "Nit: could be private"}
{"patch": "@@ -76,6 +76,7 @@ object RangeOps : TemplateGroupBase() {\n             return TProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n             \"\"\"\n         }\n+        sample(\"samples.ranges.Ranges.step${primitive!!.name}\")", "msg": "```suggestion\r\n        sample(\"samples.ranges.Ranges.step$primitive\")\r\n```\r\nMinor: calling `name` is redundant because enum's toString simply returns its name."}
{"patch": "@@ -770,4 +770,4 @@ internal class HashMapEntrySet<K, V> internal constructor(\n }\n \n // This hash map keeps insertion order.\n-actual typealias LinkedHashMap<K, V> = HashMap<K, V>\n\\ No newline at end of file\n+actual typealias LinkedHashMap<K, V> = HashMap<K, V>", "msg": "GH's source editor is to blame here, I can roll it back if needed."}
{"patch": "@@ -536,6 +572,6 @@ class AndroidSymbols(\n     fun createBuilder(\n         symbol: IrSymbol,\n         startOffset: Int = UNDEFINED_OFFSET,\n-        endOffset: Int = UNDEFINED_OFFSET\n+        endOffset: Int = UNDEFINED_OFFSET,", "msg": "Please revert this change."}
{"patch": "@@ -27,7 +57,7 @@ class IrParcelSerializerFactory(private val symbols: AndroidSymbols) {\n         scope: IrParcelerScope?,\n         parcelizeType: IrType,\n         strict: Boolean = false,\n-        toplevel: Boolean = false\n+        toplevel: Boolean = false,", "msg": "Please revert this change."}
{"patch": "@@ -132,7 +162,8 @@ class IrParcelSerializerFactory(private val symbols: AndroidSymbols) {\n             // special parceler for the element type.\n             \"kotlin.Array\", \"kotlin.ShortArray\", \"kotlin.IntArray\",\n             \"kotlin.BooleanArray\", \"kotlin.ByteArray\", \"kotlin.CharArray\",\n-            \"kotlin.FloatArray\", \"kotlin.DoubleArray\", \"kotlin.LongArray\" -> {\n+            \"kotlin.FloatArray\", \"kotlin.DoubleArray\", \"kotlin.LongArray\",", "msg": "Please revert this change to keep the style consistent."}
{"patch": "@@ -30,13 +30,30 @@ fun AndroidIrBuilder.writeParcelWith(\n     serializer: IrParcelSerializer,\n     parcel: IrValueDeclaration,\n     flags: IrValueDeclaration,\n-    value: IrExpression\n+    value: IrExpression,", "msg": "Please revert this change."}
{"patch": "@@ -214,7 +231,7 @@ class IrGenericParcelableParcelSerializer(private val parcelizeType: IrType) : I\n class IrParcelSerializerWithClassLoader(\n     private val parcelizeType: IrType,\n     private val reader: IrSimpleFunctionSymbol,\n-    private val writer: IrSimpleFunctionSymbol\n+    private val writer: IrSimpleFunctionSymbol,", "msg": "Please revert this change."}
{"patch": "@@ -247,7 +264,7 @@ class IrCustomParcelSerializer(private val parcelerObject: IrClass) : IrParcelSe\n class IrArrayParcelSerializer(\n     private val arrayType: IrType,\n     private val elementType: IrType,\n-    private val elementSerializer: IrParcelSerializer\n+    private val elementSerializer: IrParcelSerializer,", "msg": "Please revert this change."}
{"patch": "@@ -305,7 +322,7 @@ class IrArrayParcelSerializer(\n class IrSparseArrayParcelSerializer(\n     private val sparseArrayClass: IrClass,\n     private val elementType: IrType,\n-    private val elementSerializer: IrParcelSerializer\n+    private val elementSerializer: IrParcelSerializer,", "msg": "Please revert this change."}
{"patch": "@@ -386,7 +403,7 @@ class IrSparseArrayParcelSerializer(\n class IrListParcelSerializer(\n     private val irClass: IrClass,\n     private val elementType: IrType,\n-    private val elementSerializer: IrParcelSerializer\n+    private val elementSerializer: IrParcelSerializer,", "msg": "Please revert this change."}
{"patch": "@@ -464,7 +503,7 @@ class IrMapParcelSerializer(\n     private val keyType: IrType,\n     private val valueType: IrType,\n     private val keySerializer: IrParcelSerializer,\n-    private val valueSerializer: IrParcelSerializer\n+    private val valueSerializer: IrParcelSerializer,", "msg": "Please revert this change."}
{"patch": "@@ -520,14 +564,27 @@ class IrMapParcelSerializer(\n                 function.name.asString() == \"put\" && function.valueParameters.size == 2\n             }\n \n-            return constructor.symbol to put.symbol\n+            return MapSymbols(\n+                constructor = constructor.symbol,\n+                function = put.symbol,\n+            )\n         }\n \n         return when (irClass.fqNameWhenAvailable?.asString()) {\n-            \"kotlin.collections.MutableMap\", \"kotlin.collections.Map\", \"java.util.Map\" ->\n-                symbols.linkedHashMapConstructor to symbols.linkedHashMapPut\n-            \"java.util.SortedMap\", \"java.util.NavigableMap\" ->\n-                symbols.treeMapConstructor to symbols.treeMapPut\n+            \"kotlin.collections.MutableMap\",\n+            \"kotlin.collections.Map\",\n+            \"java.util.Map\",\n+            in BuiltinParcelableTypes.IMMUTABLE_MAP_FQNAMES,\n+            -> MapSymbols(", "msg": "Move the `->` here and below to the line above to keep the style consistent."}